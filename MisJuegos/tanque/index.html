<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no user-select=none">
    <title>Tanques Destructores: Team Wars</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background-color: #202028;
            color: white;
            font-family: 'Black Ops One', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .menu-screen {
            pointer-events: auto;
            background: rgba(16, 16, 20, 0.95);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            border: 2px solid #555;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            min-width: 400px;
        }

        h1 {
            color: #4caf50;
            font-size: 2.5rem;
            margin: 0 0 20px 0;
            letter-spacing: 3px;
        }

        h2 {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #ddd;
        }

        button {
            background: #444;
            color: white;
            border: 1px solid #fff;
            padding: 10px 20px;
            font-size: 1.2rem;
            margin: 5px;
            cursor: pointer;
            font-family: 'Black Ops One', cursive;
            transition: all 0.2s;
        }

        button:hover {
            background: #666;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button.btn-green {
            background: #388e3c;
            border-color: #4caf50;
        }

        button.btn-blue {
            background: #1976d2;
            border-color: #2196f3;
        }

        button.btn-red {
            background: #d32f2f;
            border-color: #f44336;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
            transform: none;
        }

        input {
            padding: 10px;
            font-size: 1.2rem;
            text-align: center;
            font-family: monospace;
            border: 1px solid #555;
            background: #222;
            color: #fff;
            margin-bottom: 20px;
            width: 250px;
        }

        /* LOBBY STYLES */
        .team-container {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }

        .team-box {
            width: 45%;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            min-height: 200px;
        }

        .team-header {
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-decoration: underline;
        }

        .red-team {
            border: 2px solid #f44336;
            color: #f44336;
        }

        .blue-team {
            border: 2px solid #2196f3;
            color: #2196f3;
        }

        .player-slot {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: monospace;
            font-size: 1rem;
        }

        .ready-status {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #777;
        }

        .is-ready {
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .color-dot {
            width: 20px;
            height: 20px;
            display: inline-block;
            cursor: pointer;
            border: 2px solid white;
            margin-right: 10px;
        }

        #color-picker-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 20;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .palette {
            display: flex;
            gap: 10px;
            padding: 20px;
            background: #222;
            border: 2px solid white;
            flex-wrap: wrap;
            max-width: 270px;
            justify-content: center;
        }

        .palette div {
            width: 40px;
            height: 40px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .palette div:hover {
            border-color: white;
            transform: scale(1.1);
        }

        #main-hud {
            display: none;
        }

        .turn-banner {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
        }

        #weapon-display {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: #ffeb3b;
            text-shadow: 0 0 5px #000;
        }

        #fire-power-bar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            display: none;
        }

        #fire-power-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffeb3b, #f44336);
        }

        /* TOUCH CONTROLS */
        #touch-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Show in landscape on mobile-ish screens */
        @media (max-width: 1024px) and (orientation: landscape) {
            #touch-controls {
                display: block;
            }
        }

        .touch-group {
            position: absolute;
            bottom: 20px;
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .touch-left {
            left: 30px;
            bottom: 30px;
        }

        .touch-right {
            right: 30px;
            bottom: 30px;
            align-items: flex-end;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            user-select: none;
            backdrop-filter: blur(2px);
            transition: all 0.1s;
        }

        .touch-btn:active,
        .touch-btn.active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
            border-color: white;
            color: white;
        }

        .btn-fire {
            width: 80px;
            height: 80px;
            background: rgba(244, 67, 54, 0.2);
            border-color: #f44336;
            margin-left: 15px;
            font-size: 2rem;
        }

        .btn-fire:active,
        .btn-fire.active {
            background: rgba(244, 67, 54, 0.5);
        }

        .column-btns {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <!-- LOGIN -->
        <div id="login-screen" class="menu-screen">
            <h1>TANK TEAM WARS</h1>
            <input type="text" id="player-name" placeholder="TU NOMBRE (Max 10 chars)" maxlength="10">
            <br>
            <button class="btn-green" onclick="createRoom()">CREAR SALA</button>
            <br>
            <div style="margin: 10px 0; color: #aaa;">- O -</div>
            <input type="text" id="room-code-input" placeholder="C√ìDIGO DE SALA">
            <button class="btn-blue" onclick="joinRoomUI()">UNIRSE A SALA</button>
        </div>

        <!-- LOBBY -->
        <div id="lobby-screen" class="menu-screen" style="display:none; min-width: 600px;">
            <h2 id="lobby-title">SALA DE ESPERA</h2>
            <div style="font-size: 0.8rem; color: #81c784; margin-bottom: 8px;">üí° Tip: Clickea tu nombre o color para
                personalizarlo</div>
            <div style="font-size: 0.9rem; color: #aaa;">C√ìDIGO: <span id="lobby-code-display"
                    style="color:white; font-size:1.2rem; user-select: text;">---</span></div>

            <div class="team-container">
                <!-- RED TEAM -->
                <div class="team-box red-team">
                    <div class="team-header">EQUIPO CALIDO</div>
                    <div id="red-list"></div>
                    <button onclick="requestTeam('RED')">UNIRSE AL ROJO</button>
                </div>
                <!-- BLUE TEAM -->
                <div class="team-box blue-team">
                    <div class="team-header">EQUIPO FRIO</div>
                    <div id="blue-list"></div>
                    <button onclick="requestTeam('BLUE')">UNIRSE AL AZUL</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="btn-green" id="btn-ready" onclick="toggleReady()">ESTOY LISTO</button>
            </div>
            <div id="start-timer" style="font-size: 2rem; color: #0f0; min-height: 40px;"></div>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-screen" class="menu-screen" style="display:none;">
            <h1 id="winner-text">GANADOR</h1>
            <button onclick="location.reload()">VOLVER AL MEN√ö</button>
        </div>

        <!-- TOUCH CONTROLS (Only visible on mobile landscape) -->
        <div id="touch-controls">
            <!-- MOVE (Left/Right) -->
            <div class="touch-group touch-left">
                <div class="touch-btn" data-key="ArrowLeft">‚¨ÖÔ∏è</div>
                <div class="touch-btn" data-key="ArrowRight">‚û°Ô∏è</div>
            </div>

            <!-- ACTIONS (Up/Down + Fire) -->
            <div class="touch-group touch-right">
                <div class="column-btns">
                    <div class="touch-btn" data-key="ArrowUp">‚¨ÜÔ∏è</div>
                    <div class="touch-btn" data-key="ArrowDown">‚¨áÔ∏è</div>
                </div>
                <!-- FIRE (Space) -->
                <div class="touch-btn btn-fire" data-key=" ">üî•</div>
            </div>
        </div>
    </div>

    <!-- HUD -->
    <div id="ui-layer" style="pointer-events:none;">
        <div id="main-hud">
            <div class="info-panel">
                <span id="p-name-disp" style="color:#fff">JUGADOR</span>
                <span id="turn-timer-disp">--</span>
            </div>
            <div class="turn-banner" id="turn-banner">ESPERANDO...</div>
            <div id="weapon-display"></div>
            <div id="fire-power-bar">
                <div id="fire-power-fill"></div>
            </div>
            <div id="stats-panel"
                style="position:absolute; bottom:20px; left:20px; text-align:left; font-size:1.5rem; text-shadow:2px 2px 2px #000; font-family: 'Black Ops One', cursive;">
                <div style="color:#4caf50; margin-bottom:5px;">‚ù§Ô∏è <span id="hp-disp">100</span>%</div>
                <div style="color:#ff9800;">‚õΩ <span id="fuel-disp">100</span></div>
            </div>
        </div>
    </div>

    <!-- COLOR PICKER -->
    <div id="color-picker-modal">
        <div class="palette" id="palette-container"></div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script>
        // --- CONSTANTES & CONFIG ---
        const RED_PALETTE = [
            '#ef5350', '#c62828', '#ff1744', '#d50000', '#b71c1c', // Rojos
            '#ff9800', '#ef6c00', '#ffb74d', '#fb8c00', '#ffe0b2', // Naranjas
            '#fdd835', '#f9a825', '#ffeb3b', '#fff176', '#fff59d'  // Amarillos
        ];
        const BLUE_PALETTE = [
            '#42a5f5', '#1565c0', '#0d47a1', '#82b1ff', '#2962ff', // Azules
            '#ab47bc', '#6a1b9a', '#d500f9', '#e1bee7', '#aa00ff', // Morados
            '#66bb6a', '#1b5e20', '#00e676', '#69f0ae', '#b9f6ca'  // Verdes
        ];

        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        let WIDTH = Math.floor(window.innerWidth * 1.3); // Map 30% wider than screen
        let HEIGHT = window.innerHeight;
        CANVAS.width = window.innerWidth; CANVAS.height = HEIGHT;

        const GRAVITY = 0.4;
        const TURN_TIME = 40;

        // --- CAMERA STATE ---
        const camera = { x: 0, y: 0, zoom: 1 };
        let isDraggingRaw = false;
        let lastTouch = { x: 0, y: 0 };
        let WORLD_HEIGHT = HEIGHT; // Synced from host

        // --- ESTADO GLOBAL ---
        let myName = "Invitado";
        let myPeerId = null;
        let isTurnTransition = false; // Block actions during turn change

        // Lobby State
        let players = []; // { id, name, team, color, ready, peerConn (host only) }
        let isHost = location.hash === '#host';
        let isGameOverPending = false; // Flag to delay game over screen

        // Game State
        let gameState = 'MENU'; // MENU, LOBBY, PLAYING, GAMEOVER
        let terrain = [];
        let stoneLevels = []; // Static layer defining where stone begins
        let LAVA_Y = 0; // Flat lava level
        let tanks = []; // { id, x, y, hp, fuel, angle, team, color, name, dead, specialWeapon }
        let projectiles = [];
        let items = [];
        let explosions = [];
        let particles = []; // Smoke/Fire particles
        let floatTexts = [];
        let turnIndex = 0; // Index in 'tanks' array
        let turnTimer = TURN_TIME;
        let timerInterval = null;
        let isCharging = false;
        let chargePower = 0;
        let chargeDir = 1;
        let keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        // --- NETWORKING START ---
        let peer;
        let hostConn = null; // Client -> Host
        let clientConns = {}; // Host -> Clients { peerId: conn }

        function createRoom() {
            myName = document.getElementById('player-name').value || "Host";
            isHost = true;
            initPeer();
        }

        function joinRoomUI() {
            const input = document.getElementById('room-code-input');
            const code = input.value.toUpperCase().trim();
            if (!code) return alert("Ingresa un c√≥digo");

            myName = document.getElementById('player-name').value || "Invitado";
            isHost = false;
            initPeer(code);
        }

        // --- FUNCIONES AUXILIARES ---
        // Force Uppercase on Input
        window.addEventListener('DOMContentLoaded', () => {
            const codeInp = document.getElementById('room-code-input');
            if (codeInp) {
                codeInp.addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
            }
        });

        function generateTerrain() {
            terrain = new Array(WIDTH).fill(0);
            stoneLevels = new Array(WIDTH).fill(0);
            LAVA_Y = (HEIGHT * 0.7) + 200; // Base Lava Level

            // Random Generation Parameters
            const baseHeight = HEIGHT * (0.5 + Math.random() * 0.2); // 50% to 70% down screen

            const freq1 = 0.003 + Math.random() * 0.007; // Hills
            const amp1 = 50 + Math.random() * 70;
            const phase1 = Math.random() * 1000;

            const freq2 = 0.01 + Math.random() * 0.02; // Bumps
            const amp2 = 10 + Math.random() * 20;
            const phase2 = Math.random() * 1000;

            const freq3 = 0.0005 + Math.random() * 0.001; // Large Valley/Hill trend
            const amp3 = Math.random() * 100;

            for (let x = 0; x < WIDTH; x++) {
                const w1 = Math.sin((x + phase1) * freq1) * amp1;
                const w2 = Math.sin((x + phase2) * freq2) * amp2;
                const w3 = Math.sin(x * freq3) * amp3;
                const noise = Math.random() * 2;

                let h = baseHeight + w1 + w2 + w3 + noise;

                // Clamp slightly to stay reasonably within screen
                // h = Math.max(HEIGHT * 0.3, Math.min(HEIGHT * 0.9, h));

                terrain[x] = h;
                stoneLevels[x] = terrain[x] + 100;

                // Ensure terrain doesn't start below lava (clipping)
                if (terrain[x] > LAVA_Y) terrain[x] = LAVA_Y - 10;
            }
        }

        let countdownInterval = null;

        function checkStartGame() {
            if (!isHost) return;
            if (players.length < 1) return;

            const distinctReady = players.every(p => p.ready);

            if (distinctReady) {
                if (countdownInterval) return; // Ya est√° contando

                let sec = 2;
                broadcast({ type: 'GAME_START_COUNTDOWN', sec: 3 });
                document.getElementById('start-timer').innerText = "INICIANDO EN " + 3;

                countdownInterval = setInterval(() => {
                    broadcast({ type: 'GAME_START_COUNTDOWN', sec: sec });
                    document.getElementById('start-timer').innerText = "INICIANDO EN " + sec;

                    if (sec <= 0) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        try {
                            startHostGame();
                        } catch (e) {
                            alert("Error iniciando: " + e);
                            console.error(e);
                        }
                    }
                    sec--;
                }, 1000);
            } else {
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    broadcast({ type: 'GAME_START_COUNTDOWN', sec: "CANCELADO" });
                    document.getElementById('start-timer').innerText = "";
                }
                document.getElementById('start-timer').innerText = "";
            }
        }

        function initPeer(targetId = null) {
            let configId = undefined; // Por defecto undefined para que PeerJS genere UUID si somos clientes

            if (isHost) {
                // SOMOS EL SERVER: Imponemos nuestro ID de 4 caracteres
                // Si ya ten√≠amos uno (reintento), √∫salo, si no, genera uno nuevo.
                if (!myPeerId) {
                    // Generar ID sin 0 ni O para evitar confusi√≥n
                    const chars = "ABCDEFGHIJKLMNPQRSTUVWXYZ123456789";
                    let id = "";
                    for (let i = 0; i < 4; i++) id += chars.charAt(Math.floor(Math.random() * chars.length));
                    myPeerId = id;
                }
                configId = myPeerId;
                console.log("Intentando registrar Host con ID:", configId);
            }

            peer = new Peer(configId);

            peer.on('open', (id) => {
                myPeerId = id;
                console.log('Mi Peer ID:', id);
                if (isHost) {
                    document.getElementById('lobby-code-display').innerText = id;
                    showScreen('lobby-screen');
                    // Auto-add host
                    players = [{ id: id, name: myName, team: 'RED', color: RED_PALETTE[0], ready: false }];
                    updateLobbyUI();
                } else {
                    // Connect to host
                    console.log("Conectando a:", targetId);
                    hostConn = peer.connect(targetId);

                    hostConn.on('open', () => {
                        console.log("Conectado al Host!");
                        showScreen('lobby-screen');
                        hostConn.send({ type: 'HELLO', name: myName });
                    });
                    hostConn.on('data', (data) => handleData(data, hostConn));
                    hostConn.on('error', (err) => alert("Error Conexi√≥n Host: " + err));
                }
            });

            peer.on('connection', (conn) => {
                if (!isHost) { conn.close(); return; } // Client rejects incoming?
                // Host logic
                console.log("Nueva conexi√≥n:", conn.peer);
                clientConns[conn.peer] = conn;
                conn.on('data', (data) => handleData(data, conn));
                conn.on('close', () => {
                    console.log("Cliente desconectado:", conn.peer);
                    delete clientConns[conn.peer];
                    players = players.filter(p => p.id !== conn.peer);
                    broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                    updateLobbyUI();
                });
            });

            peer.on('error', (err) => {
                console.error("Peer Error:", err);
                if (err.type === 'peer-unavailable') {
                    alert("Sala no encontrada o llena.");
                    location.reload();
                }
            });
        }

        function broadcast(data) {
            if (!isHost) return;
            Object.values(clientConns).forEach(c => c.send(data));
        }

        function send(data) {
            if (isHost) return;
            if (hostConn && hostConn.open) hostConn.send(data);
        }

        function sanitizedPlayers() {
            return players.map(p => ({ id: p.id, name: p.name, team: p.team, color: p.color, ready: p.ready }));
        }

        // --- LOBBY LOGIC ---
        function showScreen(id) {
            document.querySelectorAll('.menu-screen').forEach(el => el.style.display = 'none');
            document.getElementById(id).style.display = 'block';
        }

        function updateLobbyUI() {
            if (gameState === 'PLAYING') return; // Ignore if game started

            showScreen('lobby-screen');
            myPlayer = players.find(p => p.id === myPeerId);
            if (!myPlayer) return;

            // Render Lists
            const redDiv = document.getElementById('red-list');
            const blueDiv = document.getElementById('blue-list');
            redDiv.innerHTML = ''; blueDiv.innerHTML = '';

            players.forEach(p => {
                const div = document.createElement('div');
                div.className = 'player-slot';

                // Color Circle (Clickable if me)
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.style.backgroundColor = p.color;
                if (p.id === myPeerId) {
                    dot.onclick = () => openColorPicker();
                    dot.title = "Cambiar Color";
                }

                // Name & Ready
                const nameSpan = document.createElement('span');
                nameSpan.innerText = `${p.name} ${p.id === myPeerId ? '(T√ö)' : ''}`;
                if (p.id === myPeerId) {
                    nameSpan.style.cursor = 'pointer';
                    nameSpan.onclick = () => openColorPicker();
                    nameSpan.title = "Cambiar Color";
                    nameSpan.style.borderBottom = "1px dotted #fff";
                }
                div.appendChild(dot);
                div.appendChild(nameSpan);

                const ready = document.createElement('div');
                ready.className = 'ready-status ' + (p.ready ? 'is-ready' : '');
                div.appendChild(ready);

                if (p.team === 'RED') redDiv.appendChild(div);
                else blueDiv.appendChild(div);
            });

            // Button State
            const readyBtn = document.getElementById('btn-ready');
            if (myPlayer.ready) {
                readyBtn.innerText = "CANCELAR";
                readyBtn.style.background = "#d32f2f";
            } else {
                readyBtn.innerText = "ESTOY LISTO";
                readyBtn.style.background = "#388e3c";
            }
        }

        function requestTeam(team) {
            if (!isHost) send({ type: 'REQ_TEAM', team: team });
            else {
                players.find(p => p.id === myPeerId).team = team;
                players.find(p => p.id === myPeerId).color = (team === 'RED' ? RED_PALETTE[0] : BLUE_PALETTE[0]);
                broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                updateLobbyUI();
            }
        }

        function toggleReady() {
            if (!isHost) send({ type: 'REQ_READY' });
            else {
                const me = players.find(p => p.id === myPeerId);
                me.ready = !me.ready;
                broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                updateLobbyUI();
                checkStartGame();
            }
        }

        function openColorPicker() {
            const modal = document.getElementById('color-picker-modal');
            const pal = document.getElementById('palette-container');
            pal.innerHTML = '';
            modal.style.display = 'flex';

            const myTeamColors = myPlayer.team === 'RED' ? RED_PALETTE : BLUE_PALETTE;

            myTeamColors.forEach(c => {
                const d = document.createElement('div');
                d.style.backgroundColor = c;
                d.onclick = () => {
                    if (isHost) {
                        players.find(p => p.id === myPeerId).color = c;
                        broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                        updateLobbyUI();
                    } else {
                        send({ type: 'REQ_COLOR', color: c });
                    }
                    modal.style.display = 'none';
                };
                pal.appendChild(d);
            });

            // Close on click outside
            modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        }

        function checkStartGame() {
            if (!isHost) return;
            if (players.length < 1) return; // Need at least 1?
            if (players.every(p => p.ready)) {
                // COUNTDOWN
                let sec = 2;
                const intt = setInterval(() => {
                    broadcast({ type: 'GAME_START_COUNTDOWN', sec: sec }); // Broadcast countdown
                    document.getElementById('start-timer').innerText = "INICIANDO EN " + sec;
                    sec--;
                    if (sec < 0) {
                        clearInterval(intt);
                        startHostGame();
                    }
                }, 1000);
            } else {
                document.getElementById('start-timer').innerText = "";
            }
        }


        // Input State (Host tracks inputs for all players)
        const playerInputs = {}; // { peerId: { up, down, left, right, space, charging, power, pDir } }

        function startHostGame() {
            // 1. Setup Terrain & Tanks
            generateTerrain();
            tanks = [];

            // Fix: Interleave teams (Red, Blue, Red, Blue...)
            const reds = players.filter(p => p.team === 'RED');
            const blues = players.filter(p => p.team === 'BLUE');
            const interleaved = [];
            const max = Math.max(reds.length, blues.length);
            for (let i = 0; i < max; i++) {
                if (reds[i]) interleaved.push(reds[i]);
                if (blues[i]) interleaved.push(blues[i]);
            }

            interleaved.forEach(p => {
                const isRed = p.team === 'RED';
                // Spawn areas: Red (10-35%), Blue (65-90%)
                let minX = isRed ? WIDTH * 0.1 : WIDTH * 0.65;
                let maxX = isRed ? WIDTH * 0.35 : WIDTH * 0.9;
                let tx = Math.random() * (maxX - minX) + minX;

                // Initialize clean input state for p
                playerInputs[p.id] = { up: false, down: false, left: false, right: false, space: false, charging: false, power: 0, pDir: 1 };

                tanks.push({
                    id: p.id, name: p.name, team: p.team, color: p.color,
                    x: tx, y: 0, hp: 100, fuel: 100,
                    angle: isRed ? -Math.PI / 4 : -Math.PI * 0.75,
                    dead: false, specialWeapon: null, hasShield: false, poison: null,
                    wasInLava: false
                });
            });

            // 2. Reset Global State
            projectiles = [];
            items = [];
            explosions = [];
            floatTexts = [];
            particles = [];
            turnIndex = -1; // NextTurn will bump to 0
            gameState = 'PLAYING';
            isGameOverPending = false;

            // 3. Notify Everyone
            const startPacket = { type: 'GAME_START', terrain: terrain, stoneLevels: stoneLevels, lavaY: LAVA_Y, tanks: tanks, width: WIDTH, height: HEIGHT };
            broadcast(startPacket);
            initGameClient(startPacket);

            // 4. Start Host Loops
            nextTurn(); // Start first turn
            requestAnimationFrame(hostLoop);

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(hostGameTick, 1000);
        }

        function initGameClient(data) {
            gameState = 'PLAYING';
            terrain = data.terrain || terrain;
            stoneLevels = data.stoneLevels || stoneLevels;
            LAVA_Y = data.lavaY || (HEIGHT * 0.7 + 200);

            // Sync logic: Host sends 'width' and 'height' used for generation.
            // If data.width/height are missing, infer from terrain or defaults.
            WIDTH = data.width || (terrain.length > 0 ? terrain.length : window.innerWidth);
            HEIGHT = data.height || window.innerHeight;
            WORLD_HEIGHT = LAVA_Y + 60; // World ends 60px below lava surface

            // Responsive Canvas: Canvas is Viewport, not World
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;

            tanks = data.tanks;

            // FIX: Host sends tanks with y=0 initially. Snap them to terrain immediately so camera centers correctly.
            if (terrain && terrain.length > 0) {
                tanks.forEach(t => {
                    // If tank is at 0 (uninitialized physics), put it on ground
                    if (t.y === 0) {
                        const gx = Math.floor(Math.max(0, Math.min(WIDTH - 1, t.x)));
                        t.y = (terrain[gx] || HEIGHT / 2) - 20;
                    }
                });
            }
            projectiles = [];
            items = [];
            explosions = [];
            floatTexts = [];
            particles = [];

            // UI Switch
            document.getElementById('ui-layer').style.pointerEvents = 'none';
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('main-hud').style.display = 'block';

            // Detect Mobile for initial Zoom
            const isMobile = window.innerWidth <= 1024 || window.innerHeight <= 500;
            camera.zoom = isMobile ? 0.6 : 1.0;

            // INITIAL CAMERA SETUP
            const me = tanks.find(t => t.id === myPeerId);
            let target = me || tanks[0];
            if (projectiles.length > 0) target = projectiles[0]; // Follow bullet if active

            if (target) {
                // Determine screen center in world units
                // CenterX = (TargetX - CamX) * Zoom
                // WinWidth/2 = (TargetX - CamX) * Zoom
                // CamX = TargetX - (WinWidth / (2 * Zoom))
                camera.x = target.x - (CANVAS.width / (2 * camera.zoom));

                // Align Y slightly above (look ahead) or center
                camera.y = target.y - (CANVAS.height / (2 * camera.zoom));

                // Clamp immediately so we don't start in void
                // (Optional, drawGame loop will also clamp but good for clean start)
                const vw = CANVAS.width / camera.zoom;
                if (WIDTH < vw) camera.x = (WIDTH - vw) / 2;
                else camera.x = Math.max(0, Math.min(camera.x, WIDTH - vw));
            }

            // Sync Resize
            window.addEventListener('resize', () => {
                CANVAS.width = window.innerWidth;
                CANVAS.height = window.innerHeight;
            });

            requestAnimationFrame(clientRenderLoop);
        }

        // --- HOST AUTHORITATIVE LOOP ---
        let lastTime = 0;
        function hostLoop(timestamp) {
            if (gameState !== 'PLAYING') return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            updatePhysics();

            // Broadcast State (Snapshot)
            broadcast({
                type: 'SNAPSHOT',
                tanks: tanks.map(t => ({
                    id: t.id, x: t.x, y: t.y, angle: t.angle, hp: t.hp, fuel: t.fuel, dead: t.dead, sw: t.specialWeapon, hs: t.hasShield, psn: t.poison
                })),
                projectiles: projectiles.map(p => ({ x: p.x, y: p.y, type: p.type })),
                turnIndex: turnIndex,
                timer: turnTimer
            });

            requestAnimationFrame(hostLoop);
        }

        function hostGameTick() {
            if (gameState !== 'PLAYING') return;
            // Countdown only if no projectiles are active (Turn Waiting)
            if (projectiles.length === 0) {
                turnTimer--;
                if (turnTimer <= 0) nextTurn();
            }
        }

        function updatePhysics() {
            const activeTank = tanks[turnIndex];

            // 1. Process Active Player Input
            // Block input if turn is ending or projectile active
            if (activeTank && !activeTank.dead && projectiles.length === 0 && !isTurnTransition) {
                const inp = playerInputs[activeTank.id];

                // Detect Input Logs (Removed to prevent spam)
                // if (Math.random() < 0.05) { ... } // Removed

                if (inp) {
                    if (inp.left && activeTank.fuel > 0) {
                        activeTank.x -= 2; activeTank.fuel -= 0.5;
                    }
                    if (inp.right && activeTank.fuel > 0) {
                        activeTank.x += 2; activeTank.fuel -= 0.5;
                    }
                    // ... (rest of movement)
                    activeTank.x = Math.max(10, Math.min(WIDTH - 10, activeTank.x)); // Clamp

                    if (inp.up) activeTank.angle = Math.max(-Math.PI, activeTank.angle - 0.03);
                    if (inp.down) activeTank.angle = Math.min(0, activeTank.angle + 0.03);

                    // Charging Logic
                    if (inp.space) {
                        if (!inp.charging) { inp.charging = true; inp.power = 0; inp.pDir = 1; }
                        inp.power += 0.5 * inp.pDir;
                        if (inp.power > 25) inp.pDir = -1;
                        if (inp.power < 5) inp.pDir = 1;
                    } else if (!inp.space && inp.charging) {
                        fireWeapon(activeTank, inp.power);
                        inp.charging = false;
                        inp.power = 0;
                    }
                }
            }

            // ... (rest of physics loop)
            tanks.forEach(t => {
                const groundY = terrain[Math.floor(t.x)] || HEIGHT;
                t.y = groundY - 20;

                if (!t.dead) {
                    // Lava Check
                    if (t.y > LAVA_Y) {
                        if (!t.wasInLava) {
                            t.hp = Math.max(0, t.hp - 50); // Lose 50 HP immediately
                            t.wasInLava = true;
                            broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 70, text: "¬°LAVA -50!", color: '#ff5722' });
                            if (t.hp <= 0) {
                                t.dead = true;
                                broadcast({ type: 'TANK_DEATH', x: t.x, y: t.y });
                            }
                            checkWin(); // Check if died
                        }
                        // Drag in lava
                        t.x = t.x * 0.9 + (t.x - 0) * 0.1; // Naive friction? No just leave it
                    } else {
                        t.wasInLava = false;
                    }

                    for (let i = items.length - 1; i >= 0; i--) {
                        const it = items[i];
                        const dx = t.x - it.x;
                        const dy = (t.y + 10) - (terrain[Math.floor(it.x)] - 15);
                        if (Math.hypot(dx, dy) < 45) {
                            collectItemHost(t, i);
                        }
                    }
                }
            });

            // 3. Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx; p.y += p.vy;
                // Gravity only for non-LASER projectiles
                if (p.type !== 'LASER') p.vy += 0.4;

                let hitResult = null;
                // Ceiling (-3000) and Floor (WORLD_HEIGHT) check
                // Note: WORLD_HEIGHT is not fully synced in hostLoop context properly if relying on global var updated in client logic?
                // Host logic usually relies on its own HEIGHT/variables. 
                // We should ensure logic is consistent. LAVA_Y is global.
                const floorLimit = LAVA_Y + 60;

                if (p.x < -100 || p.x > WIDTH + 100 || p.y > floorLimit || p.y < -3000) hitResult = 'OUT';
                else if (p.y >= terrain[Math.floor(p.x)]) hitResult = 'TERRAIN';
                else {
                    for (let t of tanks) {
                        if (!t.dead && Math.hypot(p.x - t.x, p.y - (t.y + 10)) < 20) {
                            hitResult = 'TANK'; break;
                        }
                    }
                    if (!hitResult) {
                        for (let k = items.length - 1; k >= 0; k--) {
                            const it = items[k];
                            const dy = (terrain[Math.floor(it.x)] - 15);
                            if (p.ownerId === activeTank.id && Math.hypot(p.x - it.x, p.y - dy) < 30) {
                                projectiles.splice(i, 1);
                                collectItemHost(tanks.find(z => z.id === p.ownerId), k);
                                broadcast({ type: 'FLOAT_TEXT', x: it.x, y: dy - 50, text: "¬°SNIPER!", color: '#0ff' });
                                checkTurnEnd();
                                return;
                            }
                        }
                    }
                }

                if (hitResult) {
                    if (hitResult !== 'OUT') explode(p.x, p.y, p.type);
                    projectiles.splice(i, 1);
                    checkTurnEnd();
                }
            }
        }

        function explode(x, y, type) {
            const r = type === 'BIG' ? 80 : 40;
            // Apply visual/physics changes to terrain locally
            applyTerrainExplosion(x, y, r, type);

            // Damage Logic (Host only)
            tanks.forEach(t => {
                const d = Math.hypot(t.x - x, (t.y + 10) - y);
                if (d < r + 20) {
                    if (t.hasShield) {
                        t.hasShield = false;
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 50, text: "¬°BLOCKED!", color: '#00ffff' });
                        // Shield consumes the damage instance for this tank completely
                        return;
                    }

                    let dmg = 40 * (1 - d / (r + 20));
                    if (type === 'BIG') dmg *= 2;
                    if (type === 'MOUNTAIN') dmg *= 0.25; // Little damage for Mountain

                    t.hp = Math.max(0, t.hp - dmg);

                    // Poison Application
                    if (type === 'TOXIC' && dmg > 0 && !t.dead) {
                        t.poison = { turns: 4, dmg: dmg * 0.05 }; // 4 Turns duration
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 70, text: "¬°POISON!", color: '#00ff00' });
                    }

                    if (t.hp <= 0 && !t.dead) {
                        t.dead = true;
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 50, text: "¬°BAJA!", color: '#f00' });
                        broadcast({ type: 'TANK_DEATH', x: t.x, y: t.y });
                    }
                }
            });

            checkWin(); // Check if anyone died

            // FIX: Use expType to avoid overwriting 'type'
            broadcast({ type: 'EXPLOSION', x, y, r, expType: type });
        }

        function applyTerrainExplosion(x, y, r, type) {
            if (type === 'MOUNTAIN') {
                const mr = 60; // Double size (was 30)
                const mrSq = mr * mr;
                for (let i = Math.floor(x - mr); i < x + mr; i++) {
                    if (i >= 0 && i < WIDTH) {
                        const distSq = (i - x) ** 2;
                        if (distSq < mrSq) terrain[i] -= Math.sqrt(mrSq - distSq);
                    }
                }
            } else {
                for (let i = Math.floor(x - r); i < x + r; i++) {
                    if (i >= 0 && i < WIDTH) {
                        const distSq = (i - x) ** 2;
                        if (distSq < r * r) {
                            let cut = Math.sqrt(r * r - distSq);

                            // Stone resistance logic
                            const currentY = terrain[i];
                            const rockY = stoneLevels[i];

                            if (currentY >= rockY) {
                                // Already in stone
                                cut *= 0.5;
                            } else if (currentY + cut > rockY) {
                                // Transition from dirt to stone
                                const dirtPart = rockY - currentY;
                                const stonePart = (cut - dirtPart) * 0.5;
                                cut = dirtPart + stonePart;
                            }

                            terrain[i] += cut;
                        }
                    }
                }
            }
        }





        function fireWeapon(tank, power) {
            const type = tank.specialWeapon;
            tank.specialWeapon = null; // Consume
            const spawn = (off) => projectiles.push({
                x: tank.x + Math.cos(tank.angle + off) * 30,
                y: (tank.y - 15) + Math.sin(tank.angle + off) * 30,
                vx: Math.cos(tank.angle + off) * power,
                vy: Math.sin(tank.angle + off) * power,
                type: type, ownerId: tank.id
            });

            if (type === 'TRIPLE') { spawn(-0.2); spawn(0); spawn(0.2); }
            else spawn(0);
        }



        function collectItemHost(tank, idx) {
            const it = items[idx];
            items.splice(idx, 1);
            let txt = it.type; let col = '#ffeb3b';
            if (it.type === 'HEALTH') { tank.hp = Math.min(100, tank.hp + 25); txt = "+25 HP"; col = '#0f0'; }
            else if (it.type === 'SHIELD') { tank.hasShield = true; txt = "SHIELD UP!"; col = '#00ffff'; }
            else if (it.type === 'TOXIC') { tank.specialWeapon = 'TOXIC'; txt = "TOXIC AMMO"; col = '#00ff00'; }
            else { tank.specialWeapon = it.type; }
            broadcast({ type: 'ITEM_COLLECT', items: items, tankId: tank.id, hp: tank.hp, sw: tank.specialWeapon, hs: tank.hasShield, psn: tank.poison });
            broadcast({ type: 'FLOAT_TEXT', x: tank.x, y: tank.y - 50, text: txt, color: col });
        }

        function checkTurnEnd() {
            if (projectiles.length === 0) {
                isTurnTransition = true;
                setTimeout(nextTurn, 1000);
            }
        }

        function nextTurn() {
            isTurnTransition = false;
            let loops = 0;
            do { turnIndex = (turnIndex + 1) % tanks.length; loops++; } while (tanks[turnIndex].dead && loops < tanks.length);

            const active = tanks[turnIndex];

            // Global Poison Update: Everyone takes damage at start of NEW turn (simulating passage of time)
            tanks.forEach(t => {
                if (!t.dead && t.poison) {
                    t.hp = Math.max(0, t.hp - t.poison.dmg);
                    t.poison.turns--;
                    broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 60, text: `-${Math.ceil(t.poison.dmg)}`, color: '#00ff00' });

                    if (t.hp <= 0) {
                        t.dead = true;
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 80, text: "¬°POISON KILL!", color: '#00ff00' });
                        broadcast({ type: 'TANK_DEATH', x: t.x, y: t.y });
                        checkWin();
                    }

                    if (t.poison.turns <= 0) t.poison = null;
                }
            });

            // If active tank died from global poison, skip its turn again
            if (active && active.dead) {
                nextTurn();
                return;
            }

            if (tanks[turnIndex]) tanks[turnIndex].fuel = 100; // Refill Fuel

            // Check Win
            if (checkWin()) return;

            turnTimer = TURN_TIME;
            if (Math.random() < 0.3) spawnItemHost();
        }

        function checkWin() {
            if (isGameOverPending) return true; // Win already decided, waiting for animation
            if (tanks.length === 0) return false; // Not init yet

            const red = tanks.filter(t => t.team === 'RED' && !t.dead).length;
            const blue = tanks.filter(t => t.team === 'BLUE' && !t.dead).length;

            if (red === 0 || blue === 0) {
                isGameOverPending = true; // Stop turns from advancing

                // Delay 3 seconds to let users enjoy the destruction
                setTimeout(() => {
                    const w = red > 0 ? "EQUIPO ROJO" : (blue > 0 ? "EQUIPO AZUL" : "EMPATE");
                    broadcast({ type: 'GAMEOVER', winner: w });
                    gameOver(w);
                }, 3000);

                return true;
            }
            return false;
        }

        function gameOver(winner) {
            gameState = 'GAMEOVER';
            document.getElementById('game-over-screen').style.display = 'block';
            document.getElementById('winner-text').innerText = "GANADOR: " + winner;
            document.getElementById('winner-text').style.color = winner.includes('ROJO') ? '#ff5252' : '#448aff';
        }

        function spawnItemHost() {
            const types = ['HEALTH', 'TRIPLE', 'BIG', 'MOUNTAIN', 'SHIELD', 'TOXIC', 'LASER'];
            let x, valid = false, attempts = 0;

            while (!valid && attempts < 20) {
                x = Math.random() * (WIDTH - 100) + 50;
                valid = true;

                // Check distance from tanks
                for (let t of tanks) {
                    if (!t.dead && Math.abs(t.x - x) < 80) { // Increased safety zone slightly
                        valid = false;
                        break;
                    }
                }

                // Check distance from other items (prevent clustering)
                if (valid) {
                    for (let it of items) {
                        if (Math.abs(it.x - x) < 150) { // 150px gap required
                            valid = false;
                            break;
                        }
                    }
                }

                attempts++;
            }

            if (valid) {
                items.push({ x: x, type: types[Math.floor(Math.random() * types.length)] });
                broadcast({ type: 'SYNC_ITEMS', items: items });
            } else {
                console.log("Item spawn skipped: No safe space found.");
            }
        }

        // --- CLIENT DRAW & INPUT ---
        function clientRenderLoop() {
            if (gameState !== 'PLAYING') return;

            // Update HUD Stats
            const me = tanks.find(t => t.id === myPeerId);
            if (me) {
                document.getElementById('hp-disp').innerText = Math.ceil(me.hp);
                document.getElementById('fuel-disp').innerText = Math.ceil(me.fuel);
            }

            // Send Input
            const active = tanks[turnIndex];

            if (me && !me.dead && active && active.id === me.id) {
                const inp = {
                    left: !!(keys['ArrowLeft'] || keys['a']),
                    right: !!(keys['ArrowRight'] || keys['d']),
                    up: !!(keys['ArrowUp'] || keys['w']),
                    down: !!(keys['ArrowDown'] || keys['s']),
                    space: !!(keys[' '])
                };

                if (isHost) {
                    // Host Self-Inject Input
                    if (!playerInputs[myPeerId]) {
                        playerInputs[myPeerId] = { ...inp, charging: false, power: 0, pDir: 1 };
                    } else {
                        playerInputs[myPeerId] = { ...playerInputs[myPeerId], ...inp };
                    }
                } else {
                    send({ type: 'INPUT', inputs: inp });
                }

                // Local charging visual
                if (inp.space) {
                    if (!isCharging) { isCharging = true; chargePower = 0; chargeDir = 1; }
                    chargePower += 0.5 * chargeDir;
                    if (chargePower > 25) chargeDir = -1; else if (chargePower < 5) chargeDir = 1;
                    document.getElementById('fire-power-bar').style.display = 'block';
                    document.getElementById('fire-power-fill').style.width = (chargePower / 25 * 100) + '%';
                } else {
                    isCharging = false;
                    document.getElementById('fire-power-bar').style.display = 'none';
                }
            }

            drawGame();
            requestAnimationFrame(clientRenderLoop);
        }


        function clampCamera() {
            const vw = CANVAS.width / camera.zoom;
            const vh = CANVAS.height / camera.zoom;

            // X Clamp
            if (WIDTH < vw) camera.x = (WIDTH - vw) / 2;
            else camera.x = Math.max(0, Math.min(camera.x, WIDTH - vw));

            // Y Clamp: Don't let bottom of view go below WORLD_HEIGHT
            const maxCamY = WORLD_HEIGHT - vh;
            // Allow looking up freely (negative y), but cap bottom
            camera.y = Math.min(camera.y, maxCamY);
        }

        function drawGame() {
            CTX.fillStyle = '#202028';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            clampCamera();

            CTX.save();
            CTX.translate(-camera.x, -camera.y);
            CTX.scale(camera.zoom, camera.zoom);

            CTX.scale(camera.zoom, camera.zoom);

            // 1. Draw Stone Layer (Grey)
            CTX.fillStyle = '#757575'; // Stone Grey
            CTX.beginPath();
            CTX.moveTo(0, WORLD_HEIGHT + 2000);
            for (let x = 0; x < WIDTH; x++) {
                // Stone starts at max(currentTerrain, stoneLevel)
                // If we dug pass stoneLevel, currentTerrain is deeper (higher value)
                // If we piled up mountain, currentTerrain is lower. Stone level remains static?
                // Actually, mountains are dirt.
                // Draw stone from stoneLevels down. But if terrain is deeper than stoneLevel, start at terrain.
                const top = Math.max(terrain[x], stoneLevels[x]);
                CTX.lineTo(x, top);
            }
            CTX.lineTo(WIDTH, WORLD_HEIGHT + 2000);
            CTX.fill();

            // 2. Draw Dirt Layer (Brown) on top
            CTX.fillStyle = '#5d4037'; // Dirt Brown
            CTX.beginPath();
            // We want to fill the area between terrain[x] and stoneLevels[x]
            // But only where terrain[x] < stoneLevels[x]

            // It's easier to just draw simple polygons for dirt columns or a path
            // Let's loop and create a path that follows terrain top and stone bottom
            CTX.moveTo(0, Math.max(terrain[0], stoneLevels[0])); // Start at stone/terrain interface

            // Trace the top surface (Terrain)
            for (let x = 0; x < WIDTH; x++) {
                CTX.lineTo(x, terrain[x]);
            }

            // Trace the bottom (Stone Interface) backwards
            for (let x = WIDTH - 1; x >= 0; x--) {
                CTX.lineTo(x, Math.max(terrain[x], stoneLevels[x]));
            }
            CTX.closePath();
            CTX.fill();

            CTX.strokeStyle = '#4caf50'; CTX.lineWidth = 4;
            // Redraw top stroke
            CTX.beginPath();
            for (let x = 0; x < WIDTH; x++) CTX.lineTo(x, terrain[x]);
            CTX.stroke();

            // 3. LAVA LAYER (NEON)
            CTX.save();
            CTX.shadowBlur = 20;
            CTX.shadowColor = '#ff5722';
            CTX.fillStyle = 'rgba(255, 87, 34, 0.8)'; // Lava Orange/Red
            // Draw only 60px of lava
            CTX.fillRect(0, LAVA_Y, WIDTH, 60);

            // Lava Surface Line
            CTX.strokeStyle = '#fff';
            CTX.lineWidth = 2;
            CTX.shadowBlur = 10;
            CTX.shadowColor = '#fff';
            CTX.beginPath();
            CTX.moveTo(0, LAVA_Y);
            CTX.lineTo(WIDTH, LAVA_Y);
            CTX.stroke();
            CTX.restore();

            // 4. Void/Bedrock below lava (Black) to ensure clean edge
            CTX.fillStyle = '#101010';
            CTX.fillRect(0, LAVA_Y + 60, WIDTH, 2000);

            // Items
            items.forEach(it => {
                const y = terrain[Math.floor(it.x)];
                CTX.fillStyle = '#ff9800'; CTX.fillRect(it.x - 15, y - 30, 30, 30);
                CTX.fillStyle = '#000'; CTX.font = '20px Arial'; CTX.textAlign = 'center';
                let s = '?';
                if (it.type === 'HEALTH') s = '+';
                else if (it.type === 'TRIPLE') s = 'iii';
                else if (it.type === 'BIG') s = '‚ò¢';
                else if (it.type === 'MOUNTAIN') s = '‚ñ≤';
                else if (it.type === 'SHIELD') s = 'üõ°Ô∏è';
                else if (it.type === 'TOXIC') s = '‚ò†Ô∏è';
                else if (it.type === 'LASER') s = 'üéØ';
                CTX.fillText(s, it.x, y - 8);
            });

            // Tanks
            tanks.forEach(t => {
                if (t.dead) return;
                CTX.save();
                CTX.translate(t.x, t.y);

                // Draw Tank
                // 1. Tracks (Dark Gray)
                CTX.fillStyle = '#333';
                CTX.fillRect(-18, 0, 36, 6); // Bottom track

                // 2. Chassis (Body Color)
                CTX.fillStyle = t.color;
                // Main body with slight bevel
                CTX.beginPath();
                CTX.moveTo(-15, -10);
                CTX.lineTo(15, -10);
                CTX.lineTo(18, 0); // Flare out to track
                CTX.lineTo(-18, 0);
                CTX.closePath();
                CTX.fill();

                // 3. Turret Dome (Darker Shade or same color)
                CTX.beginPath();
                CTX.arc(0, -10, 8, Math.PI, 0); // Semicircle dome
                CTX.fill();

                // 4. Cannon (Rotates with angle)
                CTX.save();
                CTX.translate(0, -10); // Pivot at turret center
                CTX.rotate(t.angle);
                CTX.fillStyle = '#222'; // Black barrel
                CTX.fillRect(0, -3, 22, 6); // Barrel length
                // Muzzle tip
                CTX.fillStyle = '#555';
                CTX.fillRect(20, -4, 4, 8);
                CTX.restore();

                // Name & HP (Floating above)
                CTX.fillStyle = '#fff'; CTX.font = '10px Arial'; CTX.textAlign = 'center';
                CTX.fillText(t.name, 0, -35);
                // HP Bar
                CTX.fillStyle = '#f00'; CTX.fillRect(-15, -30, 30, 4);
                CTX.fillStyle = '#0f0'; CTX.fillRect(-15, -30, 30 * (t.hp / 100), 4);

                // Special Weapon Indicator
                if (t.specialWeapon) {
                    CTX.fillStyle = '#ffeb3b';
                    let wTxt = "WEAPON";
                    if (t.specialWeapon === 'TRIPLE') wTxt = "TRIPLE";
                    if (t.specialWeapon === 'BIG') wTxt = "BIG";
                    if (t.specialWeapon === 'MOUNTAIN') wTxt = "MOUNT";
                    if (t.specialWeapon === 'SHIELD') wTxt = "SHIELD";
                    if (t.specialWeapon === 'TOXIC') wTxt = "TOXIC";
                    if (t.specialWeapon === 'LASER') wTxt = "SNIPER";
                    CTX.fillText(wTxt, 0, -45);
                }

                // Shield Visual
                if (t.hasShield) {
                    CTX.beginPath();
                    CTX.arc(0, -5, 25, 0, Math.PI * 2);
                    CTX.strokeStyle = 'cyan';
                    CTX.lineWidth = 2;
                    CTX.stroke();
                    CTX.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    CTX.fill();
                }
                // Poison Visual
                if (t.poison) {
                    CTX.fillStyle = '#00ff00';
                    CTX.font = '12px Arial';
                    CTX.fillText("‚ò†Ô∏è", 0, -50);
                }

                CTX.restore();

                // Aim line (local) - Needs to be outside the save/restore relative transform to work with world coords? 
                // Wait, t.x/t.y are world coords. The previous block used translate(t.x, t.y).
                // Aim line uses world coords (px, py). So we should do it AFTER restore() if we want to use world coords logic 
                // OR we have to adapt the aim line to be local.
                // The existing aim line code: `let px = t.x` implies WORLD coords.
                // So it must be outside the `CTX.save()/restore()` block that translates to tank position.

                if (t.id === myPeerId && isCharging) {
                    let px = t.x, py = t.y - 12; // Start from turret roughly
                    let vx = Math.cos(t.angle) * chargePower;
                    let vy = Math.sin(t.angle) * chargePower;
                    // Gravity for preview
                    const isLaser = t.specialWeapon === 'LASER';

                    CTX.fillStyle = isLaser ? '#e040fb' : 'rgba(255,255,255,0.5)';
                    const steps = isLaser ? 50 : 20; // Sniper sees further

                    for (let k = 0; k < steps; k++) {
                        px += vx; py += vy;
                        if (!isLaser) vy += 0.4; // Apply gravity if not laser
                        CTX.beginPath(); CTX.arc(px, py, 2, 0, 6.28); CTX.fill();
                    }
                }
            });
            // Projectiles
            projectiles.forEach(p => {
                CTX.beginPath();
                CTX.arc(p.x, p.y, p.type === 'BIG' ? 10 : 4, 0, 6.28);

                let col = '#ff5252';
                if (p.type === 'TOXIC') col = '#00ff00';
                else if (p.type === 'LASER') col = '#e040fb';

                CTX.fillStyle = col;
                CTX.fill();
            });
            // Explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const e = explosions[i];
                e.life--;
                CTX.beginPath();
                CTX.arc(e.x, e.y, e.r * (e.life / 30), 0, Math.PI * 2);
                CTX.fillStyle = `rgba(255, 100, 0, ${e.life / 30})`;
                CTX.fill();
                if (e.life <= 0) explosions.splice(i, 1);
            }

            // Particles (Smoke/Fire)
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.size *= 1.02; // Grow smoke

                CTX.beginPath();
                CTX.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                // Reconstruct rgba with new alpha
                // Assuming color is "rgba(r,g,b," 
                // Let's use simple logic: p.color is base string like "rgba(50,50,50,"
                CTX.fillStyle = p.color.replace('A', p.life / 60);
                CTX.fill();

                if (p.life <= 0) particles.splice(i, 1);
            }

            // FloatText
            for (let i = floatTexts.length - 1; i >= 0; i--) {
                const f = floatTexts[i];
                CTX.fillStyle = f.color; CTX.font = 'bold 20px Arial'; CTX.textAlign = 'center'; CTX.fillText(f.text, f.x, f.y);
                f.y -= 1; f.life--; if (f.life <= 0) floatTexts.splice(i, 1);
            }

            CTX.restore(); // Restore camera fix

            // HUD
            const active = tanks[turnIndex];
            if (active) {
                document.getElementById('turn-banner').innerText = `TURNO DE ${active.name.toUpperCase()}`;
                document.getElementById('turn-banner').style.color = active.team === 'RED' ? RED_PALETTE[0] : BLUE_PALETTE[0];
                document.getElementById('turn-timer-disp').innerText = turnTimer;
            }
        }

        // --- DATA DISPATCHER ---
        function handleData(data, conn) {
            if (isHost) {
                if (data.type === 'INPUT') {
                    // FIX: Merge inputs to preserve host-side state (charging, etc.)
                    if (playerInputs[conn.peer]) {
                        playerInputs[conn.peer] = { ...playerInputs[conn.peer], ...data.inputs };
                    } else {
                        playerInputs[conn.peer] = data.inputs;
                    }
                }
                else if (data.type === 'HELLO') { const np = { id: conn.peer, name: data.name, team: 'BLUE', color: BLUE_PALETTE[0], ready: false }; players.push(np); broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); }
                else if (data.type === 'REQ_TEAM') { const p = players.find(x => x.id === conn.peer); if (p) { p.team = data.team; p.color = p.team === 'RED' ? RED_PALETTE[0] : BLUE_PALETTE[0]; broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); } }
                else if (data.type === 'REQ_COLOR') { const p = players.find(x => x.id === conn.peer); if (p) { p.color = data.color; broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); } }
                else if (data.type === 'REQ_READY') { const p = players.find(x => x.id === conn.peer); if (p) { p.ready = !p.ready; broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); checkStartGame(); } }
            } else {
                if (data.type === 'SNAPSHOT') {
                    data.tanks.forEach(s => { const l = tanks.find(t => t.id === s.id); if (l) { l.x = s.x; l.y = s.y; l.angle = s.angle; l.hp = s.hp; l.fuel = s.fuel; l.dead = s.dead; l.specialWeapon = s.sw; l.hasShield = s.hs; l.poison = s.psn; } });
                    projectiles = data.projectiles; turnIndex = data.turnIndex; turnTimer = data.timer;
                }
                else if (data.type === 'EXPLOSION') {
                    console.log("[CLIENT] EXP Received:", data);
                    applyTerrainExplosion(data.x, data.y, data.r, data.expType);
                    explosions.push({ x: data.x, y: data.y, r: data.r, life: 30 });
                }
                else if (data.type === 'TANK_DEATH') {
                    // Big Boom
                    explosions.push({ x: data.x, y: data.y, r: 80, life: 50 });
                    // Smoke
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: data.x, y: data.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() * -5) - 2, // Upward
                            life: 60 + Math.random() * 40,
                            size: 5 + Math.random() * 10,
                            color: `rgba(80, 80, 80, A` // Placeholder for alpha logic
                        });
                    }
                }
                else if (data.type === 'FLOAT_TEXT') { floatTexts.push({ x: data.x, y: data.y, text: data.text, color: data.color, life: 60 }); }
                else if (data.type === 'SYNC_ITEMS' || data.type === 'ITEM_COLLECT') { items = data.items; if (data.tankId) { const t = tanks.find(x => x.id === data.tankId); if (t) { t.hp = data.hp; t.specialWeapon = data.sw; t.hasShield = data.hs; t.poison = data.psn; } } }
                else if (data.type === 'GAME_START') { initGameClient(data); }
                else if (data.type === 'LOBBY_UPDATE') { players = data.players; updateLobbyUI(); }
                else if (data.type === 'GAME_START_COUNTDOWN') { document.getElementById('start-timer').innerText = data.sec === "CANCELADO" ? "" : "INICIANDO EN " + data.sec; }
                else if (data.type === 'GAMEOVER') { gameState = 'GAMEOVER'; gameOver(data.winner); }
            }
        }

        // --- TOUCH INPUT HANDLER ---
        document.querySelectorAll('.touch-btn').forEach(btn => {
            const k = btn.getAttribute('data-key');

            const activate = (e) => {
                if (e.cancelable) e.preventDefault();
                keys[k] = true;
                btn.classList.add('active');
            };

            const deactivate = (e) => {
                if (e.cancelable) e.preventDefault();
                keys[k] = false;
                btn.classList.remove('active');
            };

            btn.addEventListener('touchstart', activate, { passive: false });
            btn.addEventListener('touchend', deactivate);
            btn.addEventListener('touchcancel', deactivate);

            // Mouse fallbacks for testing
            btn.addEventListener('mouseup', deactivate);
            btn.addEventListener('mouseleave', deactivate);
        });

        // --- CAMERA PAN HANDLER (TOUCH) ---
        // Basic drag logic for the camera
        window.addEventListener('touchstart', e => {
            // If touching a control, ignore drag
            if (e.target.closest('#touch-controls') || e.target.closest('#ui-layer')) return;

            // Only consider single touch for dragging
            if (e.touches.length === 1) {
                isDraggingRaw = true;
                lastTouch.x = e.touches[0].clientX;
                lastTouch.y = e.touches[0].clientY;
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            if (!isDraggingRaw) return;
            // Prevent scrolling page
            if (e.cancelable) e.preventDefault();

            const tx = e.touches[0].clientX;
            const ty = e.touches[0].clientY;

            const dx = tx - lastTouch.x;
            const dy = ty - lastTouch.y;

            camera.x -= dx; // Dragging moves camera opposite
            camera.y -= dy;

            lastTouch.x = tx;
            lastTouch.y = ty;
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isDraggingRaw = false;
        });
        window.addEventListener('touchcancel', () => {
            isDraggingRaw = false;
        });


        // --- PC MOUSE CONTROLS (Right/Middle drag to pan, Wheel to zoom) ---
        let isMouseDragging = false;
        let lastMouse = { x: 0, y: 0 };

        window.addEventListener('mousedown', e => {
            // Right click (2) or Middle click (1) for panning
            if (e.button === 2 || e.button === 1) {
                isMouseDragging = true;
                lastMouse.x = e.clientX;
                lastMouse.y = e.clientY;
            }
        });

        window.addEventListener('mousemove', e => {
            if (isMouseDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;

                // Adjust sensitivity logic if needed, but 1:1 is standard
                // Divide by zoom if you want screen-pixels to match world-movement exactly?
                // Actually if we translate, then scale:
                // View = (World - Cam) * Zoom
                // dView = -dCam * Zoom
                // dCam = -dView / Zoom
                camera.x -= dx / camera.zoom;
                camera.y -= dy / camera.zoom;

                lastMouse.x = e.clientX;
                lastMouse.y = e.clientY;
            }
        });

        window.addEventListener('mouseup', () => isMouseDragging = false);
        window.addEventListener('contextmenu', e => e.preventDefault()); // Block context menu

        window.addEventListener('wheel', e => {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            const zoomSpeed = 0.1;
            const newZoom = camera.zoom - Math.sign(e.deltaY) * zoomSpeed;
            camera.zoom = Math.max(0.2, Math.min(2.0, newZoom));
        }, { passive: false });

    </script>
</body>

</html>