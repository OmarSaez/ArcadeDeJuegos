<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no user-select=none">
    <title>Tanques Destructores: Team Wars</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background-color: #202028;
            color: white;
            font-family: 'Black Ops One', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .menu-screen {
            pointer-events: auto;
            background: rgba(16, 16, 20, 0.95);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            border: 2px solid #555;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
            min-width: 900px;
            /* Large but not screen-filling */
            min-height: 600px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            max-width: 95%;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Mobile Adjustments (Strict Overrides) */
        @media (max-width: 768px) {
            .menu-screen {
                min-width: 300px !important;
                min-height: auto !important;
                padding: 15px !important;
                width: 90%;
            }

            h1 {
                font-size: 2rem !important;
                margin-bottom: 10px !important;
            }

            button {
                font-size: 1rem !important;
                padding: 8px 16px !important;
            }

            .team-box {
                flex: 1 1 100% !important;
                min-height: 150px !important;
            }

            input {
                width: 100% !important;
                font-size: 1rem !important;
            }

            h2 {
                font-size: 1.5rem !important;
            }

            .team-header {
                font-size: 1.2rem !important;
            }

            #lobby-tip {
                font-size: 0.8rem !important;
            }

            #lobby-code-label {
                font-size: 1rem !important;
            }

            #lobby-code-display {
                font-size: 1.2rem !important;
            }

            .player-slot {
                font-size: 1rem !important;
                padding: 5px !important;
            }

            .ready-status {
                width: 15px !important;
                height: 15px !important;
            }

            .color-dot {
                width: 20px !important;
                height: 20px !important;
            }

            /* Mobile Overrides for New UI Changes */
            #stats-panel {
                font-size: 1.2rem !important;
                top: 50px !important;
                left: 10px !important;
            }

            .turn-banner {
                font-size: 1.5rem !important;
                top: 90px !important;
            }
        }

        h1 {
            color: #4caf50;
            font-size: 3.5rem;
            /* Large Title */
            margin: 0 0 20px 0;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        h2 {
            font-size: 2.2rem;
            /* Medium-Large Subtitles */
            margin: 15px 0;
            color: #ddd;
        }

        button {
            background: #444;
            color: white;
            border: 2px solid #fff;
            padding: 12px 24px;
            font-size: 1.2rem;
            /* Standard Large Button */
            margin: 8px;
            cursor: pointer;
            font-family: 'Black Ops One', cursive;
            transition: all 0.2s;
        }

        button:hover {
            background: #666;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button.btn-green {
            background: #388e3c;
            border-color: #4caf50;
        }

        button.btn-blue {
            background: #1976d2;
            border-color: #2196f3;
        }

        button.btn-red {
            background: #d32f2f;
            border-color: #f44336;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
            transform: none;
        }

        input {
            padding: 12px;
            font-size: 1.5rem;
            /* Readable Input */
            text-align: center;
            font-family: monospace;
            border: 1px solid #555;
            background: #222;
            color: #fff;
            margin-bottom: 25px;
            width: 350px;
        }

        /* LOBBY STYLES */
        .team-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 20px;
            flex-wrap: wrap;
            /* Allow stacking on mobile */
        }

        .team-box {
            flex: 1 1 200px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            min-height: 300px;
            /* Medium-Taller team boxes */
        }

        .team-header {
            font-size: 2rem;
            /* Big Team Headers */
            margin-bottom: 15px;
            text-decoration: underline;
        }

        #lobby-tip {
            font-size: 1.5rem;
            /* Big Tip */
            color: #81c784;
            margin-bottom: 15px;
        }

        #lobby-code-label {
            font-size: 2rem;
            /* Big Code Label */
            color: #aaa;
            margin-bottom: 20px;
        }

        #lobby-code-display {
            font-size: 3rem;
            /* Huge Code */
            color: white;
            user-select: text;
        }

        .red-team {
            border: 2px solid #f44336;
            color: #f44336;
        }

        .blue-team {
            border: 2px solid #2196f3;
            color: #2196f3;
        }

        .player-slot {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: monospace;
            font-size: 2rem;
            /* Big Player Names */
        }

        .ready-status {
            width: 25px;
            /* Bigger ready dot */
            height: 25px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #777;
        }

        .is-ready {
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .color-dot {
            width: 30px;
            /* Bigger color dot */
            height: 30px;
            display: inline-block;
            cursor: pointer;
            border: 2px solid white;
            margin-right: 10px;
        }

        #color-picker-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 20;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .palette {
            display: flex;
            gap: 10px;
            padding: 20px;
            background: #222;
            border: 2px solid white;
            flex-wrap: wrap;
            max-width: 270px;
            justify-content: center;
        }

        .palette div {
            width: 40px;
            height: 40px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .palette div:hover {
            border-color: white;
            transform: scale(1.1);
        }

        #main-hud {
            display: none;
        }

        .turn-banner {
            position: absolute;
            top: 50px;
            /* Higher up */
            width: 100%;
            text-align: center;
            pointer-events: none;
            font-size: 3.5rem;
            /* Doubled size for PC */
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 5;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: 1.5rem;
            text-shadow: 1px 1px 2px black;
        }

        #stats-panel {
            position: absolute;
            top: 60px;
            /* Top Left now, below name */
            left: 20px;
            text-align: left;
            font-size: 2rem;
            /* Slighly larger for PC */
            text-shadow: 2px 2px 2px #000;
            font-family: 'Black Ops One', cursive;
            color: white;
            z-index: 5;
        }

        /* Shrink Game Over Buttons for PC */
        #game-over-screen button {
            font-size: 1rem;
            /* Reduced to half of standard 2rem */
            padding: 8px 16px;
            margin: 5px;
            min-width: auto;
        }

        #weapon-display {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: #ffeb3b;
            text-shadow: 0 0 5px #000;
        }

        #fire-power-bar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            display: none;
        }

        #fire-power-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffeb3b, #f44336);
        }

        /* TOUCH CONTROLS */
        #touch-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Show in landscape on mobile-ish screens */
        @media (max-width: 1024px) and (orientation: landscape) {
            #touch-controls {
                display: block;
            }
        }

        .touch-group {
            position: absolute;
            bottom: 20px;
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .touch-left {
            left: 30px;
            bottom: 30px;
        }

        .touch-right {
            right: 30px;
            bottom: 30px;
            align-items: flex-end;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            user-select: none;
            backdrop-filter: blur(2px);
            transition: all 0.1s;
        }

        .touch-btn:active,
        .touch-btn.active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
            border-color: white;
            color: white;
        }

        .btn-fire {
            width: 80px;
            height: 80px;
            background: rgba(244, 67, 54, 0.2);
            border-color: #f44336;
            margin-left: 15px;
            font-size: 2rem;
        }

        .btn-fire:active,
        .btn-fire.active {
            background: rgba(244, 67, 54, 0.5);
        }

        .column-btns {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none;
        }

        /* Stats Table */
        #stats-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            color: #fff;
            font-size: 14px;
        }

        #stats-table th,
        #stats-table td {
            border: 1px solid #555;
            padding: 8px;
            text-align: center;
        }

        #stats-table th {
            background: #333;
            color: #ffeb3b;
        }

        #stats-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <!-- LOGIN -->
        <div id="login-screen" class="menu-screen">
            <h1>TANK TEAM WARS</h1>
            <input type="text" id="player-name" placeholder="TU NOMBRE (Max 20 chars)" maxlength="20">
            <br>
            <button class="btn-green" onclick="createRoom()">CREAR SALA</button>
            <br>
            <div style="margin: 10px 0; color: #aaa;">- O -</div>
            <input type="text" id="room-code-input" placeholder="C√ìDIGO DE SALA">
            <button class="btn-blue" onclick="joinRoomUI()">UNIRSE A SALA</button>
        </div>

        <!-- LOBBY -->
        <div id="lobby-screen" class="menu-screen" style="display:none; width: 90%; max-width: 700px;">
            <h2 id="lobby-title">SALA DE ESPERA</h2>
            <div id="lobby-tip">üí° Tip: Clickea tu nombre o color para personalizarlo</div>
            <div id="lobby-code-label">C√ìDIGO: <span id="lobby-code-display">---</span></div>

            <div class="team-container">
                <!-- RED TEAM -->
                <div class="team-box red-team">
                    <div class="team-header">EQUIPO ROJO</div>
                    <div id="red-list"></div>
                    <button onclick="requestTeam('RED')">UNIRSE AL ROJO</button>
                </div>
                <!-- BLUE TEAM -->
                <div class="team-box blue-team">
                    <div class="team-header">EQUIPO AZUL</div>
                    <div id="blue-list"></div>
                    <button onclick="requestTeam('BLUE')">UNIRSE AL AZUL</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="btn-green" id="btn-ready" onclick="toggleReady()">ESTOY LISTO</button>
            </div>
            <div id="start-timer" style="font-size: 2rem; color: #0f0; min-height: 40px;"></div>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-screen"
            style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.95); padding:40px; border-radius:10px; text-align:center; border: 2px solid #fff; z-index:20; width: 80%; max-width: 800px; pointer-events: auto;">
            <h1 id="winner-text" style="font-size:40px; margin:0 0 10px 0;">GANADOR</h1>
            <h3 id="match-time" style="color:#aaa; margin-bottom: 20px;">Tiempo: 00:00</h3>

            <table id="stats-table">
                <thead>
                    <tr>
                        <th>Jugador</th>
                        <th>Bajas</th>
                        <th>Disparos</th>
                        <th>Precisi√≥n</th>
                        <th>Items</th>
                        <th>Vida Recup.</th>
                    </tr>
                </thead>
                <tbody id="stats-body"></tbody>
            </table>

            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button onclick="location.reload()" style="background:#f44336;">Volver al Men√∫</button>
                <button id="btn-lobby" onclick="returnToLobby()" style="background:#ff9800;">Volver a Elegir</button>
                <button id="btn-rematch" onclick="rematch()" style="background:#4caf50;">Volver a Jugar</button>
            </div>
            <p id="rematch-wait" style="display:none; color:#bbb; margin-top:10px;">Esperando al anfitri√≥n...</p>
        </div>

        <!-- TOUCH CONTROLS (Only visible on mobile landscape) -->
        <div id="touch-controls">
            <!-- MOVE (Left/Right) -->
            <div class="touch-group touch-left">
                <div class="touch-btn" data-key="ArrowLeft">‚¨ÖÔ∏è</div>
                <div class="touch-btn" data-key="ArrowRight">‚û°Ô∏è</div>
            </div>

            <!-- ACTIONS (Up/Down + Fire) -->
            <div class="touch-group touch-right">
                <div class="column-btns">
                    <div class="touch-btn" data-key="ArrowUp">‚¨ÜÔ∏è</div>
                    <div class="touch-btn" data-key="ArrowDown">‚¨áÔ∏è</div>
                </div>
                <!-- FIRE (Space) -->
                <div class="touch-btn btn-fire" data-key=" ">üî•</div>
            </div>
        </div>
    </div>

    <!-- HUD -->
    <div id="ui-layer" style="pointer-events:none;">
        <div id="main-hud">
            <div class="info-panel">
                <span id="p-name-disp" style="color:#fff">JUGADOR</span>
                <span id="turn-timer-disp">--</span>
            </div>
            <div class="turn-banner" id="turn-banner">ESPERANDO...</div>
            <div id="weapon-display"></div>
            <div id="fire-power-bar">
                <div id="fire-power-fill"></div>
            </div>
            <div id="stats-panel">
                ‚ù§Ô∏è <span id="hp-disp">100</span>% <br>
                ‚õΩ <span id="fuel-disp">100</span>
            </div>
        </div>
    </div>

    <!-- COLOR PICKER -->
    <div id="color-picker-modal">
        <div class="palette" id="palette-container"></div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script>
        // --- CONSTANTES & CONFIG ---
        const RED_PALETTE = [
            '#b71c1c', '#ff5252', '#880e4f', '#ec407a', '#ff80ab', // Reds & Pinks (Dark Red, Red, Dark Pink, Pink, Light Pink)
            '#e65100', '#ff9800', '#ffcc80', '#ffd600', '#ffff00', // Oranges & Yellows (Dark Orange, Orange, Pale Orange, Gold, Yellow)
            '#3e2723', '#795548', '#d7ccc8', '#bf360c', '#6d4c41'  // Browns (Dark Brown, Brown, Beige, Rust, Cocoa)
        ];
        const BLUE_PALETTE = [
            '#42a5f5', '#1565c0', '#0d47a1', '#82b1ff', '#2962ff', // Azules
            '#ab47bc', '#6a1b9a', '#d500f9', '#e1bee7', '#aa00ff', // Morados
            '#66bb6a', '#1b5e20', '#00e676', '#69f0ae', '#b9f6ca'  // Verdes
        ];

        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        // WORLD DIMENSIONS
        // Fixed minimum dimensions to prevent tiny maps on mobile
        let WIDTH = Math.max(window.innerWidth, 2500);
        let HEIGHT = Math.max(window.innerHeight, 900);
        CANVAS.width = window.innerWidth; CANVAS.height = window.innerHeight;

        const GRAVITY = 0.4;
        const TURN_TIME = 40;

        // --- CAMERA STATE ---
        const camera = { x: 0, y: 0, zoom: 1 };
        let isDraggingRaw = false;
        let lastTouch = { x: 0, y: 0 };
        let WORLD_HEIGHT = HEIGHT; // Synced from host

        // --- ESTADO GLOBAL ---
        let myName = "Invitado";
        let myPeerId = null;
        let isTurnTransition = false; // Block actions during turn change

        // Lobby State
        let players = []; // { id, name, team, color, ready, peerConn (host only) }
        let isHost = location.hash === '#host';
        let isGameOverPending = false; // Flag to delay game over screen

        // Game State
        let gameState = 'MENU'; // MENU, LOBBY, PLAYING, GAMEOVER
        let terrain = [];
        let stoneLevels = []; // Static layer defining where stone begins
        let LAVA_Y = 0; // Flat lava level
        let tanks = []; // { id, x, y, hp, fuel, angle, team, color, name, dead, specialWeapon }
        let projectiles = [];
        let items = [];
        let explosions = [];
        let particles = []; // Smoke/Fire particles
        let debris = []; // Physics terrain chunks
        let floatTexts = [];
        let turnIndex = 0; // Index in 'tanks' array
        let turnTimer = TURN_TIME;
        let timerInterval = null;
        let matchStartTime = 0;

        let isCharging = false;
        let chargePower = 0;
        let chargeDir = 1;
        let keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        // --- NETWORKING START ---
        let peer;
        let hostConn = null; // Client -> Host
        let clientConns = {}; // Host -> Clients { peerId: conn }
        let lastSentInput = ""; // Dedup string for network
        let frameCounter = 0; // For heartbeat input

        function createRoom() {
            myName = document.getElementById('player-name').value || "Host";
            isHost = true;
            initPeer();
        }

        function joinRoomUI() {
            const input = document.getElementById('room-code-input');
            const code = input.value.toUpperCase().trim();
            if (!code) return alert("Ingresa un c√≥digo");

            myName = document.getElementById('player-name').value || "Invitado";
            isHost = false;
            initPeer(code);
        }

        // --- FUNCIONES AUXILIARES ---
        // Force Uppercase on Input
        window.addEventListener('DOMContentLoaded', () => {
            const codeInp = document.getElementById('room-code-input');
            if (codeInp) {
                codeInp.addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
            }
        });

        function generateTerrain() {
            terrain = new Array(WIDTH).fill(0);
            stoneLevels = new Array(WIDTH).fill(0);
            LAVA_Y = (HEIGHT * 0.7) + 200; // Base Lava Level

            // Random Generation Parameters
            const baseHeight = HEIGHT * (0.5 + Math.random() * 0.2); // 50% to 70% down screen

            const freq1 = 0.003 + Math.random() * 0.007; // Hills
            const amp1 = 50 + Math.random() * 70;
            const phase1 = Math.random() * 1000;

            const freq2 = 0.01 + Math.random() * 0.02; // Bumps
            const amp2 = 10 + Math.random() * 20;
            const phase2 = Math.random() * 1000;

            const freq3 = 0.0005 + Math.random() * 0.001; // Large Valley/Hill trend
            const amp3 = Math.random() * 100;

            for (let x = 0; x < WIDTH; x++) {
                const w1 = Math.sin((x + phase1) * freq1) * amp1;
                const w2 = Math.sin((x + phase2) * freq2) * amp2;
                const w3 = Math.sin(x * freq3) * amp3;
                const noise = Math.random() * 2;

                let h = baseHeight + w1 + w2 + w3 + noise;

                // Clamp slightly to stay reasonably within screen
                // h = Math.max(HEIGHT * 0.3, Math.min(HEIGHT * 0.9, h));

                terrain[x] = h;
                stoneLevels[x] = terrain[x] + 100;

                // Ensure terrain doesn't start below lava (clipping)
                if (terrain[x] > LAVA_Y) terrain[x] = LAVA_Y - 10;
            }
        }

        let countdownInterval = null;

        function checkStartGame() {
            if (!isHost) return;
            if (players.length < 1) return;

            const distinctReady = players.every(p => p.ready);

            if (distinctReady) {
                if (countdownInterval) return; // Ya est√° contando

                let sec = 2;
                broadcast({ type: 'GAME_START_COUNTDOWN', sec: 3 });
                document.getElementById('start-timer').innerText = "INICIANDO EN " + 3;

                countdownInterval = setInterval(() => {
                    broadcast({ type: 'GAME_START_COUNTDOWN', sec: sec });
                    document.getElementById('start-timer').innerText = "INICIANDO EN " + sec;

                    if (sec <= 0) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        try {
                            startHostGame();
                        } catch (e) {
                            alert("Error iniciando: " + e);
                            console.error(e);
                        }
                    }
                    sec--;
                }, 1000);
            } else {
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    broadcast({ type: 'GAME_START_COUNTDOWN', sec: "CANCELADO" });
                    document.getElementById('start-timer').innerText = "";
                }
                document.getElementById('start-timer').innerText = "";
            }
        }

        function initPeer(targetId = null) {
            let configId = undefined; // Por defecto undefined para que PeerJS genere UUID si somos clientes

            if (isHost) {
                // SOMOS EL SERVER: Imponemos nuestro ID de 4 caracteres
                // Si ya ten√≠amos uno (reintento), √∫salo, si no, genera uno nuevo.
                if (!myPeerId) {
                    // Generar ID sin 0 ni O para evitar confusi√≥n
                    const chars = "ABCDEFGHIJKLMNPQRSTUVWXYZ123456789";
                    let id = "";
                    for (let i = 0; i < 4; i++) id += chars.charAt(Math.floor(Math.random() * chars.length));
                    myPeerId = id;
                }
                configId = myPeerId;
                console.log("Intentando registrar Host con ID:", configId);
            }

            peer = new Peer(configId);

            peer.on('open', (id) => {
                myPeerId = id;
                console.log('Mi Peer ID:', id);
                if (isHost) {
                    document.getElementById('lobby-code-display').innerText = id;
                    showScreen('lobby-screen');
                    // Auto-add host
                    players = [{ id: id, name: myName, team: 'RED', color: RED_PALETTE[0], ready: false }];
                    updateLobbyUI();
                } else {
                    // Connect to host
                    console.log("Conectando a:", targetId);
                    hostConn = peer.connect(targetId);

                    hostConn.on('open', () => {
                        console.log("Conectado al Host!");
                        showScreen('lobby-screen');
                        hostConn.send({ type: 'HELLO', name: myName });
                    });
                    hostConn.on('data', (data) => handleData(data, hostConn));
                    hostConn.on('error', (err) => alert("Error Conexi√≥n Host: " + err));
                }
            });

            peer.on('connection', (conn) => {
                if (!isHost) { conn.close(); return; } // Client rejects incoming?
                // Host logic
                console.log("Nueva conexi√≥n:", conn.peer);
                clientConns[conn.peer] = conn;
                conn.on('data', (data) => handleData(data, conn));
                conn.on('close', () => {
                    console.log("Cliente desconectado:", conn.peer);
                    delete clientConns[conn.peer];
                    players = players.filter(p => p.id !== conn.peer);
                    broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                    updateLobbyUI();
                });
            });

            peer.on('error', (err) => {
                console.error("Peer Error:", err);
                if (err.type === 'peer-unavailable') {
                    alert("Sala no encontrada o llena.");
                    location.reload();
                }
            });
        }

        function broadcast(data) {
            if (!isHost) return;
            Object.values(clientConns).forEach(c => c.send(data));
        }

        function send(data) {
            if (isHost) return;
            if (hostConn && hostConn.open) hostConn.send(data);
        }

        function sanitizedPlayers() {
            return players.map(p => ({ id: p.id, name: p.name, team: p.team, color: p.color, ready: p.ready }));
        }

        function rematch() {
            if (isHost) {
                startHostGame();
            }
        }

        function returnToLobby() {
            if (isHost) {
                broadcast({ type: 'RETURN_TO_LOBBY' });
                resetToLobby();
            }
        }

        function resetToLobby() {
            gameState = 'LOBBY';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('main-hud').style.display = 'none';
            document.getElementById('lobby-screen').style.display = 'block';
            document.getElementById('ui-layer').style.pointerEvents = 'auto'; // Re-enable clicks

            // Reset ready state
            players.forEach(p => p.ready = false);
            updateLobbyUI();

            // Stop game loops if running locally as client (though host loop keeps running, just waits for PLAYING)
            isGameOverPending = false;
        }

        // --- LOBBY LOGIC ---
        function showScreen(id) {
            document.querySelectorAll('.menu-screen').forEach(el => el.style.display = 'none');
            document.getElementById(id).style.display = 'block';
        }

        function updateLobbyUI() {
            if (gameState === 'PLAYING') return; // Ignore if game started

            showScreen('lobby-screen');
            myPlayer = players.find(p => p.id === myPeerId);
            if (!myPlayer) return;

            // Render Lists
            const redDiv = document.getElementById('red-list');
            const blueDiv = document.getElementById('blue-list');
            redDiv.innerHTML = ''; blueDiv.innerHTML = '';

            players.forEach(p => {
                const div = document.createElement('div');
                div.className = 'player-slot';

                // Color Circle (Clickable if me)
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.style.backgroundColor = p.color;
                if (p.id === myPeerId) {
                    dot.onclick = () => openColorPicker();
                    dot.title = "Cambiar Color";
                }

                // Name & Ready
                const nameSpan = document.createElement('span');
                nameSpan.innerText = `${p.name} ${p.id === myPeerId ? '(T√ö)' : ''}`;
                if (p.id === myPeerId) {
                    nameSpan.style.cursor = 'pointer';
                    nameSpan.onclick = () => openColorPicker();
                    nameSpan.title = "Cambiar Color";
                    nameSpan.style.borderBottom = "1px dotted #fff";
                }
                div.appendChild(dot);
                div.appendChild(nameSpan);

                const ready = document.createElement('div');
                ready.className = 'ready-status ' + (p.ready ? 'is-ready' : '');
                div.appendChild(ready);

                if (p.team === 'RED') redDiv.appendChild(div);
                else blueDiv.appendChild(div);
            });

            // Button State
            const readyBtn = document.getElementById('btn-ready');
            if (myPlayer.ready) {
                readyBtn.innerText = "CANCELAR";
                readyBtn.style.background = "#d32f2f";
            } else {
                readyBtn.innerText = "ESTOY LISTO";
                readyBtn.style.background = "#388e3c";
            }
        }

        function requestTeam(team) {
            if (!isHost) send({ type: 'REQ_TEAM', team: team });
            else {
                players.find(p => p.id === myPeerId).team = team;
                players.find(p => p.id === myPeerId).color = (team === 'RED' ? RED_PALETTE[0] : BLUE_PALETTE[0]);
                broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                updateLobbyUI();
            }
        }

        function toggleReady() {
            if (!isHost) send({ type: 'REQ_READY' });
            else {
                const me = players.find(p => p.id === myPeerId);
                me.ready = !me.ready;
                broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                updateLobbyUI();
                checkStartGame();
            }
        }

        function openColorPicker() {
            const modal = document.getElementById('color-picker-modal');
            const pal = document.getElementById('palette-container');
            pal.innerHTML = '';
            modal.style.display = 'flex';

            const myTeamColors = myPlayer.team === 'RED' ? RED_PALETTE : BLUE_PALETTE;

            myTeamColors.forEach(c => {
                const d = document.createElement('div');
                d.style.backgroundColor = c;
                d.onclick = () => {
                    if (isHost) {
                        players.find(p => p.id === myPeerId).color = c;
                        broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() });
                        updateLobbyUI();
                    } else {
                        send({ type: 'REQ_COLOR', color: c });
                    }
                    modal.style.display = 'none';
                };
                pal.appendChild(d);
            });

            // Close on click outside
            modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        }

        function checkStartGame() {
            if (!isHost) return;
            if (players.length < 1) return; // Need at least 1?
            if (players.every(p => p.ready)) {
                // COUNTDOWN
                let sec = 2;
                const intt = setInterval(() => {
                    broadcast({ type: 'GAME_START_COUNTDOWN', sec: sec }); // Broadcast countdown
                    document.getElementById('start-timer').innerText = "INICIANDO EN " + sec;
                    sec--;
                    if (sec < 0) {
                        clearInterval(intt);
                        startHostGame();
                    }
                }, 1000);
            } else {
                document.getElementById('start-timer').innerText = "";
            }
        }


        // Input State (Host tracks inputs for all players)
        const playerInputs = {}; // { peerId: { up, down, left, right, space, charging, power, pDir } }

        function startHostGame() {
            // 1. Setup Terrain & Tanks
            generateTerrain();
            tanks = [];

            // Fix: Interleave teams (Red, Blue, Red, Blue...)
            const reds = players.filter(p => p.team === 'RED');
            const blues = players.filter(p => p.team === 'BLUE');
            const interleaved = [];
            const max = Math.max(reds.length, blues.length);
            for (let i = 0; i < max; i++) {
                if (reds[i]) interleaved.push(reds[i]);
                if (blues[i]) interleaved.push(blues[i]);
            }

            interleaved.forEach(p => {
                const isRed = p.team === 'RED';
                // Spawn areas: Red (10-35%), Blue (65-90%)
                let minX = isRed ? WIDTH * 0.1 : WIDTH * 0.65;
                let maxX = isRed ? WIDTH * 0.35 : WIDTH * 0.9;
                let tx = Math.random() * (maxX - minX) + minX;

                // Initialize clean input state for p
                playerInputs[p.id] = { up: false, down: false, left: false, right: false, space: false, charging: false, power: 0, pDir: 1 };

                tanks.push({
                    id: p.id, name: p.name, team: p.team, color: p.color,
                    x: tx, y: 0, hp: 100, fuel: 100,
                    angle: isRed ? -Math.PI / 4 : -Math.PI * 0.75,
                    dead: false, specialWeapon: null, hasShield: false, poison: null,
                    wasInLava: false,
                    stats: { kills: 0, shots: 0, hits: 0, items: 0, healed: 0 }
                });
            });

            // 2. Reset Global State
            projectiles = [];
            items = [];
            explosions = [];
            floatTexts = [];
            particles = [];
            debris = [];
            turnIndex = -1; // NextTurn will bump to 0
            gameState = 'PLAYING';
            isGameOverPending = false;
            matchStartTime = Date.now();

            // 3. Notify Everyone
            const startPacket = { type: 'GAME_START', terrain: terrain, stoneLevels: stoneLevels, lavaY: LAVA_Y, tanks: tanks, width: WIDTH, height: HEIGHT };
            broadcast(startPacket);
            initGameClient(startPacket);

            // 4. Start Host Loops
            nextTurn(); // Start first turn
            requestAnimationFrame(hostLoop);

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(hostGameTick, 1000);
        }

        function initGameClient(data) {
            gameState = 'PLAYING';
            terrain = data.terrain || terrain;
            stoneLevels = data.stoneLevels || stoneLevels;
            LAVA_Y = data.lavaY || (HEIGHT * 0.7 + 200);

            // Sync logic: Host sends 'width' and 'height' used for generation.
            // If data.width/height are missing, infer from terrain or defaults.
            WIDTH = data.width || (terrain.length > 0 ? terrain.length : window.innerWidth);
            HEIGHT = data.height || window.innerHeight;
            WORLD_HEIGHT = LAVA_Y + 60; // World ends 60px below lava surface

            // Responsive Canvas: Canvas is Viewport, not World
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;

            tanks = data.tanks;

            // FIX: Host sends tanks with y=0 initially. Snap them to terrain immediately so camera centers correctly.
            if (terrain && terrain.length > 0) {
                tanks.forEach(t => {
                    // If tank is at 0 (uninitialized physics), put it on ground
                    if (t.y === 0) {
                        const gx = Math.floor(Math.max(0, Math.min(WIDTH - 1, t.x)));
                        t.y = (terrain[gx] || HEIGHT / 2) - 20;
                    }
                });
            }
            projectiles = [];
            items = [];
            explosions = [];
            floatTexts = [];
            particles = [];
            debris = [];

            // UI Switch
            document.getElementById('ui-layer').style.pointerEvents = 'none';
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('main-hud').style.display = 'block';

            // Detect Mobile for initial Zoom
            const isMobile = window.innerWidth <= 1024 || window.innerHeight <= 500;
            camera.zoom = isMobile ? 0.6 : 1.0;

            // INITIAL CAMERA SETUP
            const me = tanks.find(t => t.id === myPeerId);
            let target = me || tanks[0];
            if (projectiles.length > 0) target = projectiles[0]; // Follow bullet if active

            if (target) {
                // Determine screen center in world units
                // CenterX = (TargetX - CamX) * Zoom
                // WinWidth/2 = (TargetX - CamX) * Zoom
                // CamX = TargetX - (WinWidth / (2 * Zoom))
                camera.x = target.x - (CANVAS.width / (2 * camera.zoom));

                // Align Y slightly above (look ahead) or center
                camera.y = target.y - (CANVAS.height / (2 * camera.zoom));

                // Clamp immediately so we don't start in void
                // (Optional, drawGame loop will also clamp but good for clean start)
                const vw = CANVAS.width / camera.zoom;
                if (WIDTH < vw) camera.x = (WIDTH - vw) / 2;
                else camera.x = Math.max(0, Math.min(camera.x, WIDTH - vw));
            }

            // Sync Resize
            window.addEventListener('resize', () => {
                CANVAS.height = window.innerHeight;
            });

            requestAnimationFrame(clientRenderLoop);
        }



        // --- HOST AUTHORITATIVE LOOP ---
        let lastTime = 0;
        function hostLoop(timestamp) {
            if (gameState !== 'PLAYING') return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            updatePhysics();

            // Broadcast State (Snapshot)
            broadcast({
                type: 'SNAPSHOT',
                tanks: tanks.map(t => ({
                    id: t.id, x: t.x, y: t.y, angle: t.angle, hp: t.hp, fuel: t.fuel, dead: t.dead, sw: t.specialWeapon, hs: t.hasShield, psn: t.poison
                })),
                projectiles: projectiles.map(p => ({ x: p.x, y: p.y, type: p.type })),
                turnIndex: turnIndex,
                timer: turnTimer
            });

            requestAnimationFrame(hostLoop);
        }

        function hostGameTick() {
            if (gameState !== 'PLAYING') return;
            // Countdown only if no projectiles are active (Turn Waiting)
            if (projectiles.length === 0) {
                turnTimer--;
                if (turnTimer <= 0) nextTurn();
            }
        }

        function updatePhysics() {
            updateLocalEffects(); // Host also runs this for its own view
            const activeTank = tanks[turnIndex];

            // 1. Process Active Player Input
            // Block input if turn is ending or projectile active
            if (activeTank && !activeTank.dead && projectiles.length === 0 && !isTurnTransition) {
                const inp = playerInputs[activeTank.id];
                // Detect Input Logs (Removed to prevent spam)
                // if (Math.random() < 0.05) { ... } // Removed

                if (inp) {
                    if (inp.left && activeTank.fuel > 0) {
                        activeTank.x -= 2; activeTank.fuel -= 0.5;
                    }
                    if (inp.right && activeTank.fuel > 0) {
                        activeTank.x += 2; activeTank.fuel -= 0.5;
                    }
                    // ... (rest of movement)
                    activeTank.x = Math.max(10, Math.min(WIDTH - 10, activeTank.x)); // Clamp

                    if (inp.up) activeTank.angle = Math.max(-Math.PI, activeTank.angle - 0.03);
                    if (inp.down) activeTank.angle = Math.min(0, activeTank.angle + 0.03);

                    // Charging Logic
                    if (inp.space) {
                        if (!inp.charging) { inp.charging = true; inp.power = 0; inp.pDir = 1; }
                        inp.power += 0.5 * inp.pDir;
                        if (inp.power > 25) inp.pDir = -1;
                        if (inp.power < 5) inp.pDir = 1;
                    } else if (!inp.space && inp.charging) {
                        fireWeapon(activeTank, inp.power);
                        inp.charging = false;
                        inp.power = 0;
                    }
                }
            }

            // ... (rest of physics loop)
            tanks.forEach(t => {
                const groundY = terrain[Math.floor(t.x)] || HEIGHT;
                t.y = groundY - 20;

                if (!t.dead) {
                    // Lava Check
                    if (t.y > LAVA_Y) {
                        if (!t.wasInLava) {
                            t.hp = Math.max(0, t.hp - 50); // Lose 50 HP immediately
                            t.wasInLava = true;
                            broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 70, text: "¬°LAVA -50!", color: '#ff5722' });
                            if (t.hp <= 0) {
                                t.dead = true;
                                broadcast({ type: 'TANK_DEATH', x: t.x, y: t.y });
                            }
                            checkWin(); // Check if died
                        }
                        // Drag in lava
                        t.x = t.x * 0.9 + (t.x - 0) * 0.1; // Naive friction? No just leave it
                    } else {
                        t.wasInLava = false;
                    }

                    for (let i = items.length - 1; i >= 0; i--) {
                        const it = items[i];
                        const dx = t.x - it.x;
                        const dy = (t.y + 10) - (terrain[Math.floor(it.x)] - 15);
                        if (Math.hypot(dx, dy) < 45) {
                            collectItemHost(t, i);
                        }
                    }
                }
            });

            // 3. Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx; p.y += p.vy;
                // Gravity only for non-LASER projectiles
                if (p.type !== 'LASER') p.vy += 0.4;

                let hitResult = null;
                // Ceiling (-3000) and Floor (WORLD_HEIGHT) check
                // Note: WORLD_HEIGHT is not fully synced in hostLoop context properly if relying on global var updated in client logic?
                // Host logic usually relies on its own HEIGHT/variables. 
                // We should ensure logic is consistent. LAVA_Y is global.
                const floorLimit = LAVA_Y + 60;

                if (p.x < -100 || p.x > WIDTH + 100 || p.y > floorLimit || p.y < -3000) hitResult = 'OUT';
                else if (p.y >= terrain[Math.floor(p.x)]) {
                    if (p.type === 'DRILL') {
                        // Drill Logic: Don't stop on terrain immediately.
                        // Apply friction/drag while underground
                        p.vx *= 0.95;
                        p.vy *= 0.9;
                        // If too slow, explode
                        if (Math.abs(p.vx) < 0.5 && Math.abs(p.vy) < 0.5) hitResult = 'TERRAIN';
                        else hitResult = null; // Keep going

                        // Add drilling visual particles?
                        if (Math.random() < 0.3) {
                            broadcast({ type: 'FLOAT_TEXT', x: p.x, y: p.y - 10, text: ".", color: '#aaa' });
                        }
                    } else {
                        hitResult = 'TERRAIN';
                    }
                }
                else {
                    for (let t of tanks) {
                        // Improved Hitbox: Tank is roughly 36x20. 
                        // Check simple box or elliptical distance. 
                        // Let's us a closer check: |dx| < 18 and |dy| < 15 (shifted up slightly as y is ground)
                        // Tank center visual is roughly y - 10.
                        if (!t.dead) {
                            const dx = Math.abs(p.x - t.x);
                            const dy = Math.abs(p.y - (t.y - 10));
                            if (dx < 18 && dy < 15) {
                                hitResult = 'TANK'; break;
                            }
                        }
                    }
                    if (!hitResult && p.type !== 'AIR_MISSILE' && p.type !== 'CLUSTER_FRAG') { // Don't let sub-munitions pick up items
                        for (let k = items.length - 1; k >= 0; k--) {
                            const it = items[k];
                            const dy = (terrain[Math.floor(it.x)] - 15);
                            if (p.ownerId === activeTank.id && Math.hypot(p.x - it.x, p.y - dy) < 30) {
                                projectiles.splice(i, 1);
                                collectItemHost(tanks.find(z => z.id === p.ownerId), k);
                                broadcast({ type: 'FLOAT_TEXT', x: it.x, y: dy - 50, text: "¬°SNIPER!", color: '#0ff' });
                                checkTurnEnd();
                                return;
                            }
                        }
                    }
                }

                if (hitResult) {
                    if (hitResult === 'TANK') {
                        const shooter = tanks.find(t => t.id === p.ownerId);
                        if (shooter) shooter.stats.hits++;
                    }
                    if (hitResult !== 'OUT') {
                        if (p.type === 'AIRSTRIKE') {
                            triggerAirstrike(p.x, p.ownerId);
                        } else {
                            explode(p.x, p.y, p.type, p.ownerId);
                        }
                    }
                    projectiles.splice(i, 1);
                    checkTurnEnd();
                }
            }

        }

        // Shared Local Physics (Run on both Host and Client)
        function updateLocalEffects() {
            // 3. Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.vy += 0.05; // Light gravity
                p.size *= 0.95;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // 4. Debris Physics (Loose dirt falling)
            for (let i = debris.length - 1; i >= 0; i--) {
                const d = debris[i];
                d.x += d.vx;
                d.y += d.vy;
                d.vy += 0.4; // Gravity

                // Boundary / Out
                if (d.x < 0 || d.x >= WIDTH || d.y > LAVA_Y + 50) { debris.splice(i, 1); continue; }

                // Hit Terrain
                // Check bounds to avoid NaN
                const idx = Math.floor(d.x);
                if (idx < 0 || idx >= WIDTH) { debris.splice(i, 1); continue; }

                const ground = terrain[idx];
                if (d.y >= ground) {
                    // Reintegrate into terrain
                    const pileX = Math.min(WIDTH - 1, Math.max(0, idx));
                    terrain[pileX] -= 3; // Pile height

                    // Smooth neighbors slightly to form hills
                    if (pileX > 0) terrain[pileX - 1] -= 1;
                    if (pileX < WIDTH - 1) terrain[pileX + 1] -= 1;

                    debris.splice(i, 1);
                }
            }
        }



        function triggerAirstrike(latX, ownerId) {
            broadcast({ type: 'FLOAT_TEXT', x: latX, y: 100, text: "‚ö† AIRSTRIKE ‚ö†", color: '#ff9800' });
            // Spawn 3 missiles
            for (let k = 0; k < 3; k++) {
                setTimeout(() => {
                    projectiles.push({
                        x: latX + (Math.random() - 0.5) * 100,
                        y: -200 - (k * 100), // Staggered height
                        vx: 0,
                        vy: 15, // Fast drop
                        type: 'AIR_MISSILE',
                        ownerId: ownerId
                    });
                }, k * 200);
            }
        }

        function explode(x, y, type, ownerId) {
            let r = 40;
            if (type === 'BIG' || type === 'AIR_MISSILE') r = 80;
            if (type === 'CLUSTER_FRAG') r = 20;

            // Apply visual/physics changes to terrain locally
            applyTerrainExplosion(x, y, r, type);

            // Cluster Logic: Spawn fragments
            if (type === 'CLUSTER') {
                for (let i = 0; i < 5; i++) {
                    projectiles.push({
                        x: x, y: y - 10,
                        vx: (Math.random() - 0.5) * 15,
                        vy: -(Math.random() * 10 + 5), // Up and out
                        type: 'CLUSTER_FRAG',
                        ownerId: ownerId
                    });
                }
            }

            // Damage Logic (Host only)
            tanks.forEach(t => {
                const d = Math.hypot(t.x - x, (t.y + 10) - y);
                if (d < r + 20) {
                    if (t.hasShield) {
                        t.hasShield = false;
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 50, text: "¬°BLOCKED!", color: '#00ffff' });
                        // Shield consumes the damage instance for this tank completely
                        return;
                    }

                    let dmg = 40 * (1 - d / (r + 20));
                    if (type === 'BIG') dmg *= 2;
                    if (type === 'AIR_MISSILE') dmg *= 2.5; // High damage
                    if (type === 'CLUSTER_FRAG') dmg *= 0.5; // Low damage per frag
                    if (type === 'MOUNTAIN') dmg *= 0.25; // Little damage for Mountain

                    t.hp = Math.max(0, t.hp - dmg);

                    // Vampire Healing
                    if (type === 'VAMPIRE' && dmg > 0) {
                        const shooter = tanks.find(s => s.id === ownerId);
                        if (shooter && !shooter.dead) {
                            const heal = dmg * 0.5;
                            shooter.hp = Math.min(100, shooter.hp + heal);
                            shooter.stats.healed += heal;
                            broadcast({ type: 'FLOAT_TEXT', x: shooter.x, y: shooter.y - 40, text: `+${Math.ceil(heal)}`, color: '#f00' });
                        }
                    }

                    // Poison Application
                    if (type === 'TOXIC' && dmg > 0 && !t.dead) {
                        t.poison = { turns: 4, dmg: dmg * 0.05 }; // 4 Turns duration
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 70, text: "¬°POISON!", color: '#00ff00' });
                    }

                    if (t.hp <= 0 && !t.dead) {
                        t.dead = true;
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 50, text: "¬°BAJA!", color: '#f00' });
                        broadcast({ type: 'TANK_DEATH', x: t.x, y: t.y });

                        // Attribute Kill
                        if (ownerId) {
                            const killer = tanks.find(k => k.id === ownerId);
                            if (killer && killer.id !== t.id) killer.stats.kills++; // Self-kill doesn't count? Or counts? usually no.
                            else if (killer && killer.id === t.id) killer.stats.kills = Math.max(0, killer.stats.kills - 1); // Penalty for suicide?
                        }
                    }
                }
            });

            checkWin(); // Check if anyone died

            // FIX: Use expType to avoid overwriting 'type'
            broadcast({ type: 'EXPLOSION', x, y, r, expType: type });
        }

        function applyTerrainExplosion(x, y, r, type) {
            if (type === 'MOUNTAIN') {
                const mr = 60; // Double size (was 30)
                const mrSq = mr * mr;
                for (let i = Math.floor(x - mr); i < x + mr; i++) {
                    if (i >= 0 && i < WIDTH) {
                        const distSq = (i - x) ** 2;
                        if (distSq < mrSq) terrain[i] -= Math.sqrt(mrSq - distSq);
                    }
                }
            } else {
                // Jagged Crater & Debris
                const chunksToSpawn = Math.floor(r / 2); // Amount of debris depends on explosion size (Reduced)

                for (let i = Math.floor(x - r); i < x + r; i++) {
                    if (i >= 0 && i < WIDTH) {
                        const distSq = (i - x) ** 2;
                        if (distSq < r * r) {
                            let cut = Math.sqrt(r * r - distSq);

                            // 1. Add randomized noise for jagged edges (Reduced)
                            cut += (Math.random() - 0.5) * 5;
                            if (cut < 0) cut = 0;

                            // Stone resistance logic
                            const currentY = terrain[i];
                            const rockY = stoneLevels[i];

                            if (currentY >= rockY) {
                                // Already in stone
                                cut *= 0.5;
                            } else if (currentY + cut > rockY) {
                                // Transition from dirt to stone
                                const dirtPart = rockY - currentY;
                                const stonePart = (cut - dirtPart) * 0.5;
                                cut = dirtPart + stonePart;
                            }

                            terrain[i] += cut;
                        }
                    }
                }

                // Spawn Debris
                for (let k = 0; k < chunksToSpawn; k++) {
                    debris.push({
                        x: x + (Math.random() - 0.5) * r,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -(Math.random() * 10 + 5), // Fly up
                        color: Math.random() < 0.5 ? '#5d4037' : '#757575' // Dirt or Stone
                    });
                }
            }
        }





        function fireWeapon(tank, power) {
            const type = tank.specialWeapon;
            tank.specialWeapon = null; // Consume
            const spawn = (off) => {
                projectiles.push({
                    x: tank.x + Math.cos(tank.angle + off) * 30,
                    y: (tank.y - 15) + Math.sin(tank.angle + off) * 30,
                    vx: Math.cos(tank.angle + off) * power,
                    vy: Math.sin(tank.angle + off) * power,
                    type: type, ownerId: tank.id
                });
                tank.stats.shots++;
            };

            if (type === 'TRIPLE') { spawn(-0.2); spawn(0); spawn(0.2); }
            else spawn(0);
        }



        function collectItemHost(tank, idx) {
            const it = items[idx];
            items.splice(idx, 1);
            let txt = it.type; let col = '#ffeb3b';
            if (it.type === 'HEALTH') {
                tank.hp = Math.min(100, tank.hp + 25);
                txt = "+25 HP"; col = '#0f0';
                tank.stats.healed += 25;
            }
            else if (it.type === 'SHIELD') { tank.hasShield = true; txt = "SHIELD UP!"; col = '#00ffff'; }
            else if (it.type === 'TOXIC') { tank.specialWeapon = 'TOXIC'; txt = "TOXIC AMMO"; col = '#00ff00'; }
            else if (it.type === 'LASER') { tank.specialWeapon = 'LASER'; txt = "SNIPER RIFLE"; col = '#e040fb'; }
            else if (it.type === 'CLUSTER') { tank.specialWeapon = 'CLUSTER'; txt = "CLUSTER BOMB"; col = '#9c27b0'; }
            else if (it.type === 'DRILL') { tank.specialWeapon = 'DRILL'; txt = "DRILL SHOT"; col = '#9e9e9e'; }
            else if (it.type === 'VAMPIRE') { tank.specialWeapon = 'VAMPIRE'; txt = "VAMPIRE"; col = '#f44336'; }
            else if (it.type === 'AIRSTRIKE') { tank.specialWeapon = 'AIRSTRIKE'; txt = "AIRSTRIKE"; col = '#ff9800'; }
            else { tank.specialWeapon = it.type; }

            tank.stats.items++;

            broadcast({ type: 'ITEM_COLLECT', items: items, tankId: tank.id, hp: tank.hp, sw: tank.specialWeapon, hs: tank.hasShield, psn: tank.poison });
            broadcast({ type: 'FLOAT_TEXT', x: tank.x, y: tank.y - 50, text: txt, color: col });
        }

        function checkTurnEnd() {
            if (projectiles.length === 0) {
                isTurnTransition = true;
                setTimeout(nextTurn, 1000);
            }
        }

        function nextTurn() {
            isTurnTransition = false;
            let loops = 0;
            do { turnIndex = (turnIndex + 1) % tanks.length; loops++; } while (tanks[turnIndex].dead && loops < tanks.length);

            const active = tanks[turnIndex];

            // Global Poison Update: Everyone takes damage at start of NEW turn (simulating passage of time)
            tanks.forEach(t => {
                if (!t.dead && t.poison) {
                    t.hp = Math.max(0, t.hp - t.poison.dmg);
                    t.poison.turns--;
                    broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 60, text: `-${Math.ceil(t.poison.dmg)}`, color: '#00ff00' });

                    if (t.hp <= 0) {
                        t.dead = true;
                        broadcast({ type: 'FLOAT_TEXT', x: t.x, y: t.y - 80, text: "¬°POISON KILL!", color: '#00ff00' });
                        broadcast({ type: 'TANK_DEATH', x: t.x, y: t.y });
                        checkWin();
                    }

                    if (t.poison.turns <= 0) t.poison = null;
                }
            });

            // If active tank died from global poison, skip its turn again
            if (active && active.dead) {
                nextTurn();
                return;
            }

            if (tanks[turnIndex]) tanks[turnIndex].fuel = 100; // Refill Fuel

            // Check Win
            if (checkWin()) return;

            turnTimer = TURN_TIME;
            if (Math.random() < 0.3) spawnItemHost();
        }

        function checkWin() {
            if (isGameOverPending) return true; // Win already decided, waiting for animation
            if (tanks.length === 0) return false; // Not init yet

            const red = tanks.filter(t => t.team === 'RED' && !t.dead).length;
            const blue = tanks.filter(t => t.team === 'BLUE' && !t.dead).length;

            if (red === 0 || blue === 0) {
                isGameOverPending = true; // Stop turns from advancing

                // Delay 3 seconds to let users enjoy the destruction
                setTimeout(() => {
                    const w = red > 0 ? "EQUIPO ROJO" : (blue > 0 ? "EQUIPO AZUL" : "EMPATE");

                    // Final Stats Compilation
                    const durationSec = Math.floor((Date.now() - matchStartTime) / 1000);
                    const finalStats = tanks.map(t => ({
                        name: t.name,
                        kills: t.stats.kills,
                        shots: t.stats.shots,
                        hits: t.stats.hits,
                        items: t.stats.items,
                        healed: t.stats.healed
                    }));

                    broadcast({ type: 'GAMEOVER', winner: w, stats: finalStats, duration: durationSec });
                    gameOver(w, finalStats, durationSec);
                }, 3000);

                return true;
            }
            return false;
        }

        function gameOver(winner, stats, duration) {
            gameState = 'GAMEOVER';
            document.getElementById('ui-layer').style.pointerEvents = 'auto'; // Re-enable UI clicks
            document.getElementById('game-over-screen').style.display = 'block';
            document.getElementById('winner-text').innerText = "GANADOR: " + winner;
            document.getElementById('winner-text').style.color = winner.includes('ROJO') ? '#ff5252' : '#448aff';

            // Format time
            const m = Math.floor(duration / 60);
            const s = duration % 60;
            document.getElementById('match-time').innerText = `Tiempo: ${m}:${s < 10 ? '0' + s : s}`;

            // Populate Table
            const tbody = document.getElementById('stats-body');
            tbody.innerHTML = '';
            // Sort by kills? No, preserve order or sort. Let's sort by kills desc.
            if (stats) {
                stats.sort((a, b) => b.kills - a.kills);
                stats.forEach(st => {
                    const tr = document.createElement('tr');
                    const acc = st.shots > 0 ? Math.round((st.hits / st.shots) * 100) + '%' : '0%';
                    tr.innerHTML = `<td>${st.name}</td><td>${st.kills}</td><td>${st.shots}</td><td>${acc}</td><td>${st.items}</td><td>${st.healed}</td>`;
                    tbody.appendChild(tr);
                });
            }

            // Rematch Buttons
            if (isHost) {
                document.getElementById('btn-rematch').style.display = 'inline-block';
                document.getElementById('btn-lobby').style.display = 'inline-block';
                document.getElementById('rematch-wait').style.display = 'none';
            } else {
                document.getElementById('btn-rematch').style.display = 'none';
                document.getElementById('btn-lobby').style.display = 'none';
                document.getElementById('rematch-wait').style.display = 'block';
            }
        }

        function spawnItemHost() {
            const types = ['HEALTH', 'TRIPLE', 'BIG', 'MOUNTAIN', 'SHIELD', 'TOXIC', 'LASER', 'CLUSTER', 'DRILL', 'VAMPIRE', 'AIRSTRIKE'];
            let x, valid = false, attempts = 0;

            while (!valid && attempts < 20) {
                x = Math.random() * (WIDTH - 100) + 50;
                valid = true;

                // Check distance from tanks
                for (let t of tanks) {
                    if (!t.dead && Math.abs(t.x - x) < 80) { // Increased safety zone slightly
                        valid = false;
                        break;
                    }
                }

                // Check distance from other items (prevent clustering)
                if (valid) {
                    for (let it of items) {
                        if (Math.abs(it.x - x) < 150) { // 150px gap required
                            valid = false;
                            break;
                        }
                    }
                }

                attempts++;
            }

            if (valid) {
                items.push({ x: x, type: types[Math.floor(Math.random() * types.length)] });
                broadcast({ type: 'SYNC_ITEMS', items: items });
            } else {
                console.log("Item spawn skipped: No safe space found.");
            }
        }

        // --- CLIENT DRAW & INPUT ---
        function clientRenderLoop() {
            if (gameState !== 'PLAYING') return;

            // Update HUD Stats
            const me = tanks.find(t => t.id === myPeerId);
            if (me) {
                document.getElementById('hp-disp').innerText = Math.ceil(me.hp);
                document.getElementById('fuel-disp').innerText = Math.ceil(me.fuel);
            }

            // Send Input
            const active = tanks[turnIndex];

            if (me && !me.dead && active && active.id === me.id) {
                const inp = {
                    left: !!(keys['ArrowLeft'] || keys['a']),
                    right: !!(keys['ArrowRight'] || keys['d']),
                    up: !!(keys['ArrowUp'] || keys['w']),
                    down: !!(keys['ArrowDown'] || keys['s']),
                    space: !!(keys[' '])
                };

                if (isHost) {
                    // Host Self-Inject Input
                    if (!playerInputs[myPeerId]) {
                        playerInputs[myPeerId] = { ...inp, charging: false, power: 0, pDir: 1 };
                    } else {
                        playerInputs[myPeerId] = { ...playerInputs[myPeerId], ...inp };
                    }
                } else {
                    // Input Throttling: Send only if changed OR every 15 frames (heartbeat)
                    const inputStr = JSON.stringify(inp);
                    if (inputStr !== lastSentInput || frameCounter % 15 === 0) {
                        send({ type: 'INPUT', inputs: inp });
                        lastSentInput = inputStr;
                    }
                }

                // Local charging visual
                if (inp.space) {
                    if (!isCharging) { isCharging = true; chargePower = 0; chargeDir = 1; }
                    chargePower += 0.5 * chargeDir;
                    if (chargePower > 25) chargeDir = -1; else if (chargePower < 5) chargeDir = 1;
                    document.getElementById('fire-power-bar').style.display = 'block';
                    document.getElementById('fire-power-fill').style.width = (chargePower / 25 * 100) + '%';
                } else {
                    isCharging = false;
                    document.getElementById('fire-power-bar').style.display = 'none';
                }
            }

            // Physics & Visuals UPDATE (Client Local)
            if (gameState === 'PLAYING' || gameState === 'GAMEOVER') {
                try {
                    updateLocalEffects();
                } catch (e) {
                    console.error("Visual Effects Error:", e);
                }
            }

            drawGame();
            requestAnimationFrame(clientRenderLoop);
            frameCounter++;
        }


        function clampCamera() {
            const vw = CANVAS.width / camera.zoom;
            const vh = CANVAS.height / camera.zoom;

            // X Clamp
            if (WIDTH < vw) camera.x = (WIDTH - vw) / 2;
            else camera.x = Math.max(0, Math.min(camera.x, WIDTH - vw));

            // Y Clamp: Don't let bottom of view go below WORLD_HEIGHT
            const maxCamY = WORLD_HEIGHT - vh;
            // Allow looking up freely (negative y), but cap bottom
            camera.y = Math.min(camera.y, maxCamY);
        }

        function drawGame() {
            CTX.fillStyle = '#202028';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            clampCamera();

            CTX.save();
            CTX.translate(-camera.x, -camera.y);
            CTX.scale(camera.zoom, camera.zoom);

            CTX.scale(camera.zoom, camera.zoom);

            // 1. Draw Stone Layer (Grey)
            CTX.fillStyle = '#757575'; // Stone Grey
            CTX.beginPath();
            CTX.moveTo(0, WORLD_HEIGHT + 2000);
            for (let x = 0; x < WIDTH; x++) {
                // Stone starts at max(currentTerrain, stoneLevel)
                // If we dug pass stoneLevel, currentTerrain is deeper (higher value)
                // If we piled up mountain, currentTerrain is lower. Stone level remains static?
                // Actually, mountains are dirt.
                // Draw stone from stoneLevels down. But if terrain is deeper than stoneLevel, start at terrain.
                const top = Math.max(terrain[x], stoneLevels[x]);
                CTX.lineTo(x, top);
            }
            CTX.lineTo(WIDTH, WORLD_HEIGHT + 2000);
            CTX.fill();

            // 2. Draw Dirt Layer (Brown) on top
            CTX.fillStyle = '#5d4037'; // Dirt Brown
            CTX.beginPath();
            // We want to fill the area between terrain[x] and stoneLevels[x]
            // But only where terrain[x] < stoneLevels[x]

            // It's easier to just draw simple polygons for dirt columns or a path
            // Let's loop and create a path that follows terrain top and stone bottom
            CTX.moveTo(0, Math.max(terrain[0], stoneLevels[0])); // Start at stone/terrain interface

            // Trace the top surface (Terrain)
            for (let x = 0; x < WIDTH; x++) {
                CTX.lineTo(x, terrain[x]);
            }

            // Trace the bottom (Stone Interface) backwards
            for (let x = WIDTH - 1; x >= 0; x--) {
                CTX.lineTo(x, Math.max(terrain[x], stoneLevels[x]));
            }
            CTX.closePath();
            CTX.fill();

            CTX.lineWidth = 4;
            // Draw surface stroke segment by segment to handle color changes
            for (let x = 0; x < WIDTH - 1; x++) {
                CTX.beginPath();
                CTX.moveTo(x, terrain[x]);
                CTX.lineTo(x + 1, terrain[x + 1]);

                // Color based on material
                // If current surface is below stone level, it's stone.
                const isStone = terrain[x] >= stoneLevels[x];
                CTX.strokeStyle = isStone ? '#757575' : '#4caf50';
                CTX.stroke();
            }

            // 3. LAVA LAYER (NEON)
            CTX.save();
            CTX.shadowBlur = 20;
            CTX.shadowColor = '#ff5722';
            CTX.fillStyle = 'rgba(255, 87, 34, 0.8)'; // Lava Orange/Red
            // Draw only 60px of lava
            CTX.fillRect(0, LAVA_Y, WIDTH, 60);

            // Lava Surface Line
            CTX.strokeStyle = '#fff';
            CTX.lineWidth = 2;
            CTX.shadowBlur = 10;
            CTX.shadowColor = '#fff';
            CTX.beginPath();
            CTX.moveTo(0, LAVA_Y);
            CTX.lineTo(WIDTH, LAVA_Y);
            CTX.stroke();
            CTX.restore();

            // 4. Void/Bedrock below lava (Black) to ensure clean edge
            CTX.fillStyle = '#101010';
            CTX.fillRect(0, LAVA_Y + 60, WIDTH, 2000);

            // Items
            items.forEach(it => {
                const y = terrain[Math.floor(it.x)];
                CTX.fillStyle = '#ff9800'; CTX.fillRect(it.x - 15, y - 30, 30, 30);
                CTX.fillStyle = '#000'; CTX.font = '20px Arial'; CTX.textAlign = 'center';
                let s = '?';
                if (it.type === 'HEALTH') s = '+';
                else if (it.type === 'TRIPLE') s = 'iii';
                else if (it.type === 'BIG') s = '‚ò¢';
                else if (it.type === 'MOUNTAIN') s = '‚ñ≤';
                else if (it.type === 'SHIELD') s = 'üõ°Ô∏è';
                else if (it.type === 'TOXIC') s = '‚ò†Ô∏è';
                else if (it.type === 'LASER') s = 'üéØ';
                else if (it.type === 'CLUSTER') s = 'üçá';
                else if (it.type === 'DRILL') s = 'üî©';
                else if (it.type === 'VAMPIRE') s = 'üßõ';
                else if (it.type === 'AIRSTRIKE') s = '‚úàÔ∏è';
                CTX.fillText(s, it.x, y - 8);
            });

            // Tanks
            tanks.forEach(t => {
                if (t.dead) return;
                CTX.save();
                CTX.translate(t.x, t.y);

                // Draw Tank
                // 1. Tracks (Dark Gray)
                CTX.fillStyle = '#333';
                CTX.fillRect(-18, 0, 36, 6); // Bottom track

                // 2. Chassis (Body Color)
                CTX.fillStyle = t.color;
                // Main body with slight bevel
                CTX.beginPath();
                CTX.moveTo(-15, -10);
                CTX.lineTo(15, -10);
                CTX.lineTo(18, 0); // Flare out to track
                CTX.lineTo(-18, 0);
                CTX.closePath();
                CTX.fill();

                // 3. Turret Dome (Darker Shade or same color)
                CTX.beginPath();
                CTX.arc(0, -10, 8, Math.PI, 0); // Semicircle dome
                CTX.fill();

                // 4. Cannon (Rotates with angle)
                CTX.save();
                CTX.translate(0, -10); // Pivot at turret center
                CTX.rotate(t.angle);
                CTX.fillStyle = '#222'; // Black barrel
                CTX.fillRect(0, -3, 22, 6); // Barrel length
                // Muzzle tip
                CTX.fillStyle = '#555';
                CTX.fillRect(20, -4, 4, 8);
                CTX.restore();

                // Name & HP (Floating above)
                CTX.fillStyle = '#fff'; CTX.font = '10px Arial'; CTX.textAlign = 'center';
                CTX.fillText(t.name, 0, -35);
                // HP Bar
                CTX.fillStyle = '#f00'; CTX.fillRect(-15, -30, 30, 4);
                CTX.fillStyle = '#0f0'; CTX.fillRect(-15, -30, 30 * (t.hp / 100), 4);

                // Special Weapon Indicator
                if (t.specialWeapon) {
                    CTX.fillStyle = '#ffeb3b';
                    let wTxt = "WEAPON";
                    if (t.specialWeapon === 'TRIPLE') wTxt = "TRIPLE";
                    if (t.specialWeapon === 'BIG') wTxt = "BIG";
                    if (t.specialWeapon === 'MOUNTAIN') wTxt = "MOUNT";
                    if (t.specialWeapon === 'SHIELD') wTxt = "SHIELD";
                    if (t.specialWeapon === 'TOXIC') wTxt = "TOXIC";
                    if (t.specialWeapon === 'LASER') wTxt = "SNIPER";
                    if (t.specialWeapon === 'CLUSTER') wTxt = "CLUSTER";
                    if (t.specialWeapon === 'DRILL') wTxt = "DRILL";
                    if (t.specialWeapon === 'VAMPIRE') wTxt = "VAMPIRE";
                    if (t.specialWeapon === 'AIRSTRIKE') wTxt = "AIR STRK";
                    CTX.fillText(wTxt, 0, -45);
                }

                // Shield Visual
                if (t.hasShield) {
                    CTX.beginPath();
                    CTX.arc(0, -5, 25, 0, Math.PI * 2);
                    CTX.strokeStyle = 'cyan';
                    CTX.lineWidth = 2;
                    CTX.stroke();
                    CTX.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    CTX.fill();
                }
                // Poison Visual
                if (t.poison) {
                    CTX.fillStyle = '#00ff00';
                    CTX.font = '12px Arial';
                    CTX.fillText("‚ò†Ô∏è", 0, -50);
                }

                CTX.restore();

                // Aim line (local) - Needs to be outside the save/restore relative transform to work with world coords? 
                // Wait, t.x/t.y are world coords. The previous block used translate(t.x, t.y).
                // Aim line uses world coords (px, py). So we should do it AFTER restore() if we want to use world coords logic 
                // OR we have to adapt the aim line to be local.
                // The existing aim line code: `let px = t.x` implies WORLD coords.
                // So it must be outside the `CTX.save()/restore()` block that translates to tank position.

                if (t.id === myPeerId && isCharging) {
                    let px = t.x, py = t.y - 12; // Start from turret roughly
                    let vx = Math.cos(t.angle) * chargePower;
                    let vy = Math.sin(t.angle) * chargePower;
                    // Gravity for preview
                    const isLaser = t.specialWeapon === 'LASER';

                    CTX.fillStyle = isLaser ? '#e040fb' : 'rgba(255,255,255,0.5)';
                    const steps = isLaser ? 50 : 20; // Sniper sees further

                    for (let k = 0; k < steps; k++) {
                        px += vx; py += vy;
                        if (!isLaser) vy += 0.4; // Apply gravity if not laser
                        CTX.beginPath(); CTX.arc(px, py, 2, 0, 6.28); CTX.fill();
                    }
                }
            });
            // Projectiles
            projectiles.forEach(p => {
                CTX.beginPath();
                CTX.arc(p.x, p.y, p.type === 'BIG' ? 10 : 4, 0, 6.28);

                let col = '#ff5252';
                if (p.type === 'TOXIC') col = '#00ff00';
                else if (p.type === 'LASER') col = '#e040fb';
                else if (p.type === 'DRILL') col = '#9e9e9e';
                else if (p.type === 'VAMPIRE') col = '#b71c1c';
                else if (p.type === 'CLUSTER') col = '#9c27b0';
                else if (p.type === 'AIRSTRIKE') col = '#ff9800';
                else if (p.type === 'AIR_MISSILE') col = '#ff5722';
                else if (p.type === 'CLUSTER_FRAG') col = '#e1bee7';

                CTX.fillStyle = col;
                CTX.fill();
            });
            // Explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const e = explosions[i];
                e.life--;
                CTX.beginPath();
                CTX.arc(e.x, e.y, e.r * (e.life / 30), 0, Math.PI * 2);
                CTX.fillStyle = `rgba(255, 100, 0, ${e.life / 30})`;
                CTX.fill();
                if (e.life <= 0) explosions.splice(i, 1);
            }

            // Particles (Smoke/Fire)
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.size *= 1.02; // Grow smoke

                CTX.beginPath();
                CTX.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                // Reconstruct rgba with new alpha
                // Assuming color is "rgba(r,g,b," 
                // Let's use simple logic: p.color is base string like "rgba(50,50,50,"
                CTX.fillStyle = p.color.replace('A', p.life / 60);
                CTX.fill();

                if (p.life <= 0) particles.splice(i, 1);
            }

            // Debris (Chunks)
            debris.forEach(d => {
                CTX.fillStyle = d.color;
                CTX.fillRect(d.x - 2, d.y - 2, 4, 4);
            });

            // FloatText
            for (let i = floatTexts.length - 1; i >= 0; i--) {
                const f = floatTexts[i];
                CTX.fillStyle = f.color; CTX.font = 'bold 20px Arial'; CTX.textAlign = 'center'; CTX.fillText(f.text, f.x, f.y);
                f.y -= 1; f.life--; if (f.life <= 0) floatTexts.splice(i, 1);
            }

            CTX.restore(); // Restore camera fix

            // HUD
            const active = tanks[turnIndex];
            if (active) {
                document.getElementById('turn-banner').innerText = `TURNO DE ${active.name.toUpperCase()}`;
                document.getElementById('turn-banner').style.color = active.team === 'RED' ? RED_PALETTE[0] : BLUE_PALETTE[0];
                document.getElementById('turn-timer-disp').innerText = turnTimer;
            }
        }

        // --- DATA DISPATCHER ---
        function handleData(data, conn) {
            if (isHost) {
                if (data.type === 'INPUT') {
                    // FIX: Merge inputs to preserve host-side state (charging, etc.)
                    if (playerInputs[conn.peer]) {
                        playerInputs[conn.peer] = { ...playerInputs[conn.peer], ...data.inputs };
                    } else {
                        playerInputs[conn.peer] = data.inputs;
                    }
                }
                else if (data.type === 'HELLO') { const np = { id: conn.peer, name: data.name, team: 'BLUE', color: BLUE_PALETTE[0], ready: false }; players.push(np); broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); }
                else if (data.type === 'REQ_TEAM') { const p = players.find(x => x.id === conn.peer); if (p) { p.team = data.team; p.color = p.team === 'RED' ? RED_PALETTE[0] : BLUE_PALETTE[0]; broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); } }
                else if (data.type === 'REQ_COLOR') { const p = players.find(x => x.id === conn.peer); if (p) { p.color = data.color; broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); } }
                else if (data.type === 'REQ_READY') { const p = players.find(x => x.id === conn.peer); if (p) { p.ready = !p.ready; broadcast({ type: 'LOBBY_UPDATE', players: sanitizedPlayers() }); updateLobbyUI(); checkStartGame(); } }
            } else {
                if (data.type === 'SNAPSHOT') {
                    data.tanks.forEach(s => { const l = tanks.find(t => t.id === s.id); if (l) { l.x = s.x; l.y = s.y; l.angle = s.angle; l.hp = s.hp; l.fuel = s.fuel; l.dead = s.dead; l.specialWeapon = s.sw; l.hasShield = s.hs; l.poison = s.psn; } });
                    projectiles = data.projectiles; turnIndex = data.turnIndex; turnTimer = data.timer;
                }
                else if (data.type === 'EXPLOSION') {
                    console.log("[CLIENT] EXP Received:", data);
                    applyTerrainExplosion(data.x, data.y, data.r, data.expType);
                    explosions.push({ x: data.x, y: data.y, r: data.r, life: 30 });
                }
                else if (data.type === 'TANK_DEATH') {
                    // Big Boom
                    explosions.push({ x: data.x, y: data.y, r: 80, life: 50 });
                    // Smoke
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: data.x, y: data.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() * -5) - 2, // Upward
                            life: 60 + Math.random() * 40,
                            size: 5 + Math.random() * 10,
                            color: `rgba(80, 80, 80, A)` // Placeholder for alpha logic
                        });
                    }
                }
                else if (data.type === 'FLOAT_TEXT') { floatTexts.push({ x: data.x, y: data.y, text: data.text, color: data.color, life: 60 }); }
                else if (data.type === 'SYNC_ITEMS' || data.type === 'ITEM_COLLECT') { items = data.items; if (data.tankId) { const t = tanks.find(x => x.id === data.tankId); if (t) { t.hp = data.hp; t.specialWeapon = data.sw; t.hasShield = data.hs; t.poison = data.psn; } } }
                else if (data.type === 'GAME_START') { initGameClient(data); }
                else if (data.type === 'LOBBY_UPDATE') { players = data.players; updateLobbyUI(); }
                else if (data.type === 'GAME_START_COUNTDOWN') { document.getElementById('start-timer').innerText = data.sec === "CANCELADO" ? "" : "INICIANDO EN " + data.sec; }
                else if (data.type === 'GAMEOVER') { gameState = 'GAMEOVER'; gameOver(data.winner, data.stats, data.duration); }
                else if (data.type === 'RETURN_TO_LOBBY') { resetToLobby(); }
            }
        }

        // --- TOUCH INPUT HANDLER ---
        document.querySelectorAll('.touch-btn').forEach(btn => {
            const k = btn.getAttribute('data-key');

            const activate = (e) => {
                if (e.cancelable) e.preventDefault();
                keys[k] = true;
                btn.classList.add('active');
            };

            const deactivate = (e) => {
                if (e.cancelable) e.preventDefault();
                keys[k] = false;
                btn.classList.remove('active');
            };

            btn.addEventListener('touchstart', activate, { passive: false });
            btn.addEventListener('touchend', deactivate);
            btn.addEventListener('touchcancel', deactivate);

            // Mouse fallbacks for testing
            btn.addEventListener('mouseup', deactivate);
            btn.addEventListener('mouseleave', deactivate);
        });

        // --- CAMERA PAN HANDLER (TOUCH) ---
        // Basic drag logic for the camera
        window.addEventListener('touchstart', e => {
            // If touching a control, ignore drag
            if (e.target.closest('#touch-controls') || e.target.closest('#ui-layer')) return;

            // Only consider single touch for dragging
            if (e.touches.length === 1) {
                isDraggingRaw = true;
                lastTouch.x = e.touches[0].clientX;
                lastTouch.y = e.touches[0].clientY;
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            if (!isDraggingRaw) return;
            // Prevent scrolling page
            if (e.cancelable) e.preventDefault();

            const tx = e.touches[0].clientX;
            const ty = e.touches[0].clientY;

            const dx = tx - lastTouch.x;
            const dy = ty - lastTouch.y;

            camera.x -= dx; // Dragging moves camera opposite
            camera.y -= dy;

            lastTouch.x = tx;
            lastTouch.y = ty;
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isDraggingRaw = false;
        });
        window.addEventListener('touchcancel', () => {
            isDraggingRaw = false;
        });


        // --- PC MOUSE CONTROLS (Right/Middle drag to pan, Wheel to zoom) ---
        let isMouseDragging = false;
        let lastMouse = { x: 0, y: 0 };

        window.addEventListener('mousedown', e => {
            // Right click (2) or Middle click (1) for panning
            if (e.button === 2 || e.button === 1) {
                isMouseDragging = true;
                lastMouse.x = e.clientX;
                lastMouse.y = e.clientY;
            }
        });

        window.addEventListener('mousemove', e => {
            if (isMouseDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;

                // Adjust sensitivity logic if needed, but 1:1 is standard
                // Divide by zoom if you want screen-pixels to match world-movement exactly?
                // Actually if we translate, then scale:
                // View = (World - Cam) * Zoom
                // dView = -dCam * Zoom
                // dCam = -dView / Zoom
                camera.x -= dx / camera.zoom;
                camera.y -= dy / camera.zoom;

                lastMouse.x = e.clientX;
                lastMouse.y = e.clientY;
            }
        });

        window.addEventListener('mouseup', () => isMouseDragging = false);
        window.addEventListener('contextmenu', e => e.preventDefault()); // Block context menu

        window.addEventListener('wheel', e => {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();

            if (e.ctrlKey) {
                // ZOOM (Pinch or Ctrl+Scroll)
                // Use raw delta for smoothness, but dampen it significantly for trackpads
                // Trackpads send frequent small deltas (e.g., 5-20), Mouse wheels send large lumps (100)
                const zoomSensitivity = 0.002;
                camera.zoom -= e.deltaY * zoomSensitivity;
                camera.zoom = Math.max(0.3, Math.min(3.0, camera.zoom)); // Reasonable limits
            } else {
                // PAN (Two-finger scroll / Wheel scroll)
                // Move camera matching the scroll direction
                // Divide by zoom so panning feels 1:1 with finger movement regardless of zoom level
                camera.x += e.deltaX / camera.zoom;
                camera.y += e.deltaY / camera.zoom;
            }
        }, { passive: false });

    </script>
</body>

</html>