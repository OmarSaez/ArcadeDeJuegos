<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cartas Contra la Humanidad</title>
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        :root {
            --bg-color: #f5f5f5;
            --text-color: #1a1a1a;
            --card-white: #ffffff;
            --card-black: #1a1a1a;
            --accent: #2c3e50;
            --border-radius: 12px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        body {
            font-family: 'Inter', Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- SCREEN MANAGEMENT --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-color);
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-weight: 900;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-align: center;
            letter-spacing: -2px;
        }

        /* --- UI ELEMENTS --- */
        .btn {
            background: var(--card-black);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            width: 250px;
            margin: 10px;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            background: #000;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.secondary {
            background: white;
            color: black;
            border: 2px solid black;
        }

        input {
            padding: 15px;
            font-size: 1.1rem;
            border: 2px solid #ccc;
            border-radius: 8px;
            width: 250px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
        }

        /* --- CARDS --- */
        .card {
            width: 180px;
            height: 250px;
            border-radius: var(--border-radius);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            /* Push logo to bottom */
            font-weight: 700;
            font-size: 0.9rem;
            line-height: 1.3;
            position: relative;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease, border-color 0.2s ease;
            cursor: pointer;
            margin: 5px;
            flex-shrink: 0;
            overflow: hidden;
            /* Clip overflow */
            white-space: normal;
            animation: dealCard 0.4s ease-out backwards;
        }

        @keyframes dealCard {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.8);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .card-text-content {
            flex: 1;
            overflow-y: auto;
            /* Scroll if absolutely necessary */
            margin-bottom: 20px;
            /* Space above logo */
            /* Hide scrollbar visually but keep functionality */
            scrollbar-width: thin;
        }

        .card.black {
            background: var(--card-black);
            color: white;
        }

        .card.white {
            background: var(--card-white);
            color: black;
            border: 1px solid #e5e5e5;
        }

        .card.white:hover {
            transform: translateY(-30px) scale(1.05) rotate(2deg);
            z-index: 100;
            box-shadow: 0 25px 30px -5px rgba(0, 0, 0, 0.2);
            border-color: #94a3b8;
        }

        .card.black:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 20px -5px rgba(0, 0, 0, 0.3);
        }

        .card.selected {
            border: 4px solid #3b82f6;
            transform: translateY(-30px);
        }

        .card-logo {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 0.7rem;
            font-weight: 900;
            opacity: 0.8;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .card-logo::before {
            content: '‚ñ´';
            /* Placeholder icon */
            font-size: 1.2rem;
        }

        .card.black .card-logo::before {
            content: '‚óº';
        }

        /* --- GAME LAYOUT --- */
        #game-layout {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background: #d1d5db;
        }

        #table-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        #black-card-spot {
            margin-bottom: 20px;
        }

        #played-cards-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            min-height: 260px;
            /* Space for cards */
        }

        #hand-area {
            height: 300px;
            background: #f3f4f6;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 10px 20px;
            overflow-x: auto;
            border-top: 1px solid #e5e5e5;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* --- INFO BAR --- */
        #info-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            box-shadow: var(--shadow);
            z-index: 50;
        }

        #czar-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #1a1a1a;
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            box-shadow: var(--shadow);
        }

        /* --- LOBBY LIST --- */
        #lobby-list {
            list-style: none;
            padding: 0;
            width: 300px;
            margin-bottom: 20px;
        }

        /* --- STARS --- */
        .star-container {
            display: flex;
            justify-content: center;
            margin-top: 5px;
            flex-wrap: wrap;
            gap: 2px;
        }

        .star-icon {
            font-size: 1.2rem;
            display: inline-block;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;
            margin-right: 2px;
            transform: scale(0);
            /* Start Invisible */
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .star-gold {
            color: #fbbf24;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }

        .star-grey {
            color: #9ca3af;
        }

        .star-black {
            color: #1f2937;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
        }

        @keyframes winnerGlow {
            0% {
                border-color: transparent;
                background-color: transparent;
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                border-color: gold;
                background-color: rgba(255, 215, 0, 0.2);
                transform: scale(1);
            }
        }

        .star-black {
            color: #1f2937;
            text-shadow: 0 0 1px rgba(255, 255, 255, 0.5);
        }


        @keyframes popIn {
            from {
                transform: scale(0);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        #lobby-list li {
            background: white;
            padding: 10px 15px;
            margin-bottom: 5px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* --- ANIMATIONS --- */
        @keyframes deal {
            from {
                opacity: 0;
                transform: translateY(100px) scale(0.5);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .deal-anim {
            animation: deal 0.4s ease-out forwards;
        }

        @keyframes shuffleDeal {
            from {
                opacity: 0;
                transform: translateY(-50px) translateX(-50%) rotate(-15deg) scale(0.5);
            }

            to {
                opacity: 1;
                transform: translateY(0) translateX(0) rotate(0) scale(1);
            }
        }

        .status-msg {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* --- MOBILE --- */
        @media (max-width: 600px) {
            .card {
                width: 140px;
                height: 200px;
                font-size: 0.8rem;
            }

            #hand-area {
                height: 240px;
            }

            h1 {
                font-size: 1.8rem;
            }

            #ingame-player-list {
                top: auto;
                bottom: 270px;
                /* Above hand area */
                right: 10px;
                font-size: 0.75rem;
                text-align: right;
            }

        }

        /* Placeholder for ContentEditable */
        [contenteditable]:empty::before {
            content: attr(data-placeholder);
            color: #888;
            font-style: italic;
            pointer-events: none;
            display: block;
            /* For Firefox */
        }
    </style>
</head>

<body>

    <!-- SCREEN 1: MENU -->
    <div id="screen-menu" class="screen">
        <h1>CARTAS CONTRA LA<br>HUMANIDAD</h1>
        <input type="text" id="nickname" placeholder="Tu Apodo (Ej: El Bromas)" maxlength="12">
        <button class="btn" onclick="createRoom()">Crear Partida</button>
        <div style="display:flex; gap:10px;">
            <input type="text" id="room-code-input" placeholder="C√ìDIGO" style="width:120px; margin-bottom:10px;">
            <button class="btn secondary" style="width:120px;" onclick="joinRoom()">Unirse</button>
        </div>
        <button class="btn secondary" onclick="window.location.href='../../index.html'"
            style="margin-top:20px; background:transparent; color:#666; width:auto; font-size:0.9rem;">Volver al
            Arcade</button>
    </div>

    <!-- SCREEN 2: LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <h2>SALA: <span id="lobby-code"
                style="font-family:monospace; background:#e5e5e5; padding:2px 8px; border-radius:4px;">CODE</span></h2>
        <ul id="lobby-list"></ul>
        <div id="host-controls" class="hidden" style="width: 100%; max-width: 300px;">
            <div
                style="background: white; padding: 6px 10px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                <label style="color:#666; font-size:0.8rem; font-weight:bold; display:block; margin-bottom: 2px;">PUNTOS
                    PARA GANAR</label>
                <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changePoints(-1)">-</button>
                    <span id="points-display-host"
                        style="font-size: 1.2rem; font-weight: bold; min-width: 20px;">3</span>
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changePoints(1)">+</button>
                </div>
            </div>

            <div
                style="background: white; padding: 6px 10px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                <label style="color:#666; font-size:0.8rem; font-weight:bold; display:block; margin-bottom: 2px;">MODO
                    DE JUEGO</label>
                <div style="display: flex; justify-content: center; gap: 5px;">
                    <button id="btn-mode-judge" class="btn" style="flex:1; font-size:0.75rem; padding: 5px;"
                        onclick="changeGameMode('JUDGE')">Juez</button>
                    <button id="btn-mode-demo" class="btn secondary" style="flex:1; font-size:0.75rem; padding: 5px;"
                        onclick="changeGameMode('DEMOC')">Democracia</button>
                </div>
            </div>

            <div
                style="background: white; padding: 6px 10px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                <label style="color:#666; font-size:0.8rem; font-weight:bold; display:block; margin-bottom: 2px;">TIEMPO
                    POR RONDA</label>
                <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changeTimer(-10)">-</button>
                    <span id="timer-display-host"
                        style="font-size: 1.2rem; font-weight: bold; min-width: 60px;">40s</span>
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changeTimer(10)">+</button>
                </div>
                <button id="btn-timer-toggle" class="btn secondary"
                    style="width:100%; margin-top:5px; font-size:0.8rem; padding: 2px;" onclick="toggleTimerLimit()">Sin
                    L√≠mite</button>
            </div> <!-- Close Timer Panel -->

            <p style="color:#666; font-size:0.9rem;">Se recomiendan 3+ jugadores</p>
            <button class="btn" onclick="startGame()">Comenzar Juego</button>
        </div> <!-- Close Host Controls -->

        <div id="client-settings-view" class="hidden" style="margin-bottom: 20px;">
            <p style="color:#666; font-weight:bold;">Puntos para ganar: <span id="points-display-client"
                    style="font-size:1.2rem; color:black;">3</span></p>
            <p style="color:#666; font-weight:bold;">Modo: <span id="mode-display-client"
                    style="font-size:1.2rem; color:black;">Juez Cl√°sico</span></p>
            <p style="color:#666; font-weight:bold;">Tiempo: <span id="timer-setting-client"
                    style="font-size:1.2rem; color:black;">40s</span></p>
        </div>
        <p id="wait-msg">Esperando al anfitri√≥n...</p>

        <!-- Universal Create Card Button -->
        <div style="margin-top: 15px; margin-bottom: 30px; display: flex; justify-content: center;">
            <button class="btn secondary" style="width: auto; padding: 10px 20px; font-size: 0.9rem;"
                onclick="showCreateCardMenu()">
                + Crear Carta
            </button>
        </div>

        <!-- Help Button -->
        <button onclick="document.getElementById('help-modal').classList.remove('hidden')"
            style="position: absolute; bottom: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background: #2c3e50; color: white; font-size: 1.5rem; font-weight: bold; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 50; display: flex; align-items: center; justify-content: center;">
            ?
        </button>

        <!-- Help Modal -->
        <div id="help-modal" class="hidden"
            style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(2px);">
            <div
                style="background: white; padding: 25px; border-radius: 12px; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; position: relative; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);">
                <button onclick="document.getElementById('help-modal').classList.add('hidden')"
                    style="position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>

                <h2 style="margin-top: 0; color: #2c3e50; text-align: center;">C√≥mo Jugar</h2>

                <div style="margin-bottom: 20px;">
                    <h3 style="color: #2563eb; margin-bottom: 5px;">üßë‚Äç‚öñÔ∏è Modo Juez</h3>
                    <p style="font-size: 0.9rem; color: #4b5563; margin: 0;">En este modo, un solo jugador act√∫a como
                        <strong>juez</strong>.
                    </p>
                    <ul style="font-size: 0.9rem; color: #4b5563; padding-left: 20px; margin-top: 5px;">
                        <li>El juez elige la carta ganadora de la ronda.</li>
                        <li>Durante su turno, el juez no juega cartas.</li>
                    </ul>
                </div>

                <div style="margin-bottom: 20px;">
                    <h3 style="color: #e11d48; margin-bottom: 5px;">üó≥Ô∏è Modo Democracia</h3>
                    <p style="font-size: 0.9rem; color: #4b5563; margin: 0;">Todos los jugadores juegan una carta.</p>
                    <ul style="font-size: 0.9rem; color: #4b5563; padding-left: 20px; margin-top: 5px;">
                        <li>Luego, todos votan por la carta que les parezca m√°s graciosa.</li>
                        <li>La carta con m√°s votos gana la ronda.</li>
                    </ul>
                </div>

                <div>
                    <h3 style="color: #d97706; margin-bottom: 5px;">‚≠ê Sistema de estrellas</h3>
                    <ul style="list-style: none; padding: 0; font-size: 0.9rem; color: #4b5563;">
                        <li style="margin-bottom: 8px; display: flex; align-items: center;">
                            <span class="star-icon star-gold" style="transform: scale(1); margin-right: 8px;">‚òÖ</span>
                            <span>Estrella amarilla: voto normal.</span>
                        </li>
                        <li style="margin-bottom: 8px; display: flex; align-items: center;">
                            <span class="star-icon star-grey" style="transform: scale(1); margin-right: 8px;">‚òÖ</span>
                            <span>Estrella gris: Alguien se auto-voto (due√±o) y el voto no cuenta para la votaci√≥n
                                final.</span>
                        </li>
                        <li style="margin-bottom: 8px; display: flex; align-items: start;">
                            <span class="star-icon star-black"
                                style="transform: scale(1); margin-right: 8px; margin-top: 2px;">‚òÖ</span>
                            <span>
                                <strong>Estrella negra (Penalizaci√≥n):</strong><br>
                                Si votas por ti mismo m√°s de 2 veces, pierdes 1 punto y el voto no cuenta para la
                                votaci√≥n final.
                            </span>
                        </li>
                    </ul>
                </div>

                <button onclick="document.getElementById('help-modal').classList.add('hidden')" class="btn"
                    style="width: 100%; margin: 20px 0 0 0; padding: 10px;">Entendido</button>
            </div>
        </div>
    </div> <!-- Close Help Modal -->

    <!-- CREATE CARD MENU MODAL -->
    <div id="modal-create-card-menu" class="hidden"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 1001; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(4px);">
        <div
            style="background: white; padding: 30px; border-radius: 16px; width: 90%; max-width: 400px; text-align: center; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.2);">
            <h2 style="margin-top: 0; color: #1f2937; margin-bottom: 20px;">¬øQu√© carta quieres crear?</h2>

            <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 25px;">
                <!-- Black Card Option -->
                <button onclick="openCreateCardForm('black')"
                    style="flex: 1; height: 120px; border-radius: 12px; border: 2px solid #1a1a1a; background: #1a1a1a; color: white; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: transform 0.2s;">
                    <span style="font-size: 2rem; margin-bottom: 10px;">‚¨õ</span>
                    <span style="font-weight: bold; font-size: 1.1rem;">Carta Negra</span>
                </button>

                <!-- White Card Option -->
                <button onclick="openCreateCardForm('white')"
                    style="flex: 1; height: 120px; border-radius: 12px; border: 2px solid #e5e5e5; background: white; color: #1a1a1a; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.05); transition: transform 0.2s;">
                    <span style="font-size: 2rem; margin-bottom: 10px;">‚¨ú</span>
                    <span style="font-weight: bold; font-size: 1.1rem;">Carta Blanca</span>
                </button>
            </div>

            <button onclick="document.getElementById('modal-create-card-menu').classList.add('hidden')"
                style="background: transparent; border: 1px solid #999; color: #666; padding: 10px 20px; border-radius: 8px; cursor: pointer; width: 100%;">
                Cancelar
            </button>
        </div>
    </div>

    <!-- BLACK CARD CREATOR VIEW -->
    <div id="creator-view-black" class="screen hidden"
        style="background: #e5e5e5; display: flex; flex-direction: column; overflow: hidden;">
        <!-- Header -->
        <div
            style="background:black; color:white; padding:10px 15px; display:flex; justify-content:space-between; align-items:center;">
            <button onclick="leaveCreator('black')"
                style="background:transparent; border:none; color:white; font-size:1.2rem; cursor:pointer;">‚¨Ö
                Volver</button>
            <h3 style="margin:0; font-size:1rem;">Creador de Cartas Negras</h3>
            <div style="width:24px;"></div> <!-- Spacer to balance Volver -->
        </div>

        <!-- Button Guide Bar -->
        <div
            style="background:#f3f4f6; padding:5px; display:flex; justify-content:center; border-bottom:1px solid #ddd;">
            <button onclick="toggleGuide('black')"
                style="background:#e11d48; border:none; color:white; padding:5px 15px; border-radius:15px; font-size:0.8rem; cursor:pointer; display:flex; align-items:center; gap:5px; box-shadow:0 2px 4px rgba(0,0,0,0.1);">
                <span>üìñ</span> Gu√≠a para crear
            </button>
        </div>

        <!-- Workspace -->
        <div
            style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative;">

            <!-- Editor Row -->
            <div style="display:flex; align-items:center; gap:20px;">
                <!-- Left Control -->
                <button onclick="insertBlankInEditor()" class="btn secondary"
                    style="width:100px; height:auto; padding:10px; font-size:0.9rem; white-space:normal;">
                    Poner espacio [ _ ]
                </button>

                <!-- The Card Editor Wrapper -->
                <div style="position: relative; width: 250px; height: 350px;">
                    <div id="editor-card-black" contenteditable="true" class="card black"
                        style="width: 100%; height: 100%; font-size: 1.4rem; padding: 20px; box-sizing: border-box; outline: none; border: 2px dashed #444;"
                        data-placeholder="Escribe tu situaci√≥n absurda aqu√≠...">
                    </div>
                    <div class="card-logo" style="pointer-events: none; user-select: none; color: white;">
                        <span style="font-size: 1.2rem; margin-right: 5px;">‚óº</span> Cartas contra la humanidad
                    </div>
                </div>

                <!-- Right Control -->
                <button onclick="saveAndNewCard('black')" class="btn"
                    style="width:100px; height:auto; padding:10px; font-size:0.9rem; background:#2563eb;">
                    Crear otra carta ‚û°
                </button>
            </div>

            <p style="margin-top:10px; color:#666; font-size:0.8rem;">Escribe _ para borrar espacios completos.</p>
        </div>

        <!-- Bottom List -->
        <div
            style="height: 220px; background: #d4d4d4; padding: 10px; display: flex; flex-direction: column; width: 100%; max-width: 100vw; box-sizing: border-box; overflow: hidden;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <strong style="color:#333;">Mis Cartas Negras (<span id="count-black">0</span>)</strong>
                <div style="display:flex; gap:5px;">
                    <button onclick="triggerImport('black')" class="btn secondary"
                        style="font-size:0.75rem; padding:2px 8px; width:auto;">üì• Importar</button>
                    <button onclick="showExportOptions('black')" class="btn secondary"
                        style="font-size:0.75rem; padding:2px 8px; width:auto;">üì§ Exportar</button>
                    <button id="btn-del-mode-black" onclick="toggleDeleteMode('black')"
                        style="background:transparent; border:1px solid #666; color:#333; border-radius:4px; font-size:0.8rem; padding:2px 8px; cursor:pointer;">üóëÔ∏è
                        Eliminar</button>
                </div>
            </div>
            <div id="list-created-black"
                style="flex:1; display:flex; flex-direction:row; gap:10px; overflow-x:auto; overflow-y:hidden; padding-bottom:10px; align-items:center; width: 100%; min-width: 0;">
                <!-- Items go here -->
            </div>
            <input type="file" id="file-import-black" accept=".json" style="display:none;"
                onchange="handleImportFile(this, 'black')">
        </div>

        <!-- GUIDE MODAL BLACK -->
        <div id="guide-modal-black" class="hidden"
            style="position:fixed; top:0; left:0; width:100%; height:100%; z-index:2000; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; backdrop-filter:blur(3px);">
            <div
                style="background:#1a1a1a; color:white; padding:20px; border-radius:10px; max-width:500px; max-height:80vh; overflow-y:auto; border:1px solid #444;">
                <div
                    style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #444; padding-bottom:10px; margin-bottom:10px;">
                    <h3 style="margin:0;">üñ§ Gu√≠a para crear Cartas Negras</h3>
                    <button onclick="toggleGuide('black')"
                        style="background:none; border:none; color:white; font-size:1.5rem; cursor:pointer;">&times;</button>
                </div>
                <p style="font-size:0.9rem;">Las cartas negras plantean la situaci√≥n. No son el chiste completo: dejan
                    espacio para que lo complete la carta blanca.</p>

                <h4 style="color:#10b981;">‚úî Buenas pr√°cticas</h4>
                <ul style="font-size:0.9rem; padding-left:20px;">
                    <li>Deben ser una pregunta o frase incompleta.</li>
                    <li>Incluir 1 o 2 espacios en blanco (use el bot√≥n).</li>
                    <li>El espacio debe poder rellenarse con sujeto, acci√≥n o concepto.</li>
                    <li>Funcionan mejor si generan expectativa o suenan "serias" antes del remate.</li>
                </ul>

                <h4 style="color:#ef4444;">‚ùå Evita</h4>
                <ul style="font-size:0.9rem; padding-left:20px;">
                    <li>Frases completas sin espacio.</li>
                    <li>Chistes cerrados que ya son graciosos.</li>
                    <li>Mas de 2 espacios (se vuelve complicado).</li>
                </ul>

                <h4 style="color:#fbbf24;">üìù Ejemplos</h4>
                <ul style="font-size:0.9rem; padding-left:20px; font-style:italic;">
                    <li>‚ÄúLo que arruin√≥ completamente la cena fue ___.‚Äù</li>
                    <li>‚ÄúMi superpoder secreto es ___.‚Äù</li>
                </ul>

                <div style="background:#333; padding:10px; border-radius:5px; margin-top:15px;">
                    <strong>üéØ Tip general:</strong> Una buena carta negra deber√≠a hacer que casi cualquier carta blanca
                    sea graciosa.
                </div>

                <button onclick="toggleGuide('black')" class="btn"
                    style="width:100%; margin-top:20px;">Entendido</button>
            </div>
        </div>
    </div>

    <!-- WHITE CARD CREATOR VIEW -->
    <div id="creator-view-white" class="screen hidden"
        style="background: #e5e5e5; display: flex; flex-direction: column; overflow: hidden;">
        <!-- Header -->
        <div
            style="background:white; color:black; padding:10px 15px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #ccc;">
            <button onclick="leaveCreator('white')"
                style="background:transparent; border:none; color:black; font-size:1.2rem; cursor:pointer;">‚¨Ö
                Volver</button>
            <h3 style="margin:0; font-size:1rem;">Creador de Cartas Blancas</h3>
            <div style="width:24px;"></div>
        </div>

        <!-- Button Guide Bar -->
        <div
            style="background:#e5e5e5; padding:5px; display:flex; justify-content:center; border-bottom:1px solid #ccc;">
            <button onclick="toggleGuide('white')"
                style="background:#e11d48; border:none; color:white; padding:5px 15px; border-radius:15px; font-size:0.8rem; cursor:pointer; display:flex; align-items:center; gap:5px; box-shadow:0 2px 4px rgba(0,0,0,0.1);">
                <span>üìñ</span> Gu√≠a para crear
            </button>
        </div>

        <!-- Workspace -->
        <div
            style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative;">

            <!-- Editor Row -->
            <div style="display:flex; align-items:center; gap:20px;">
                <!-- White card needs no spacer button usually -->
                <div style="width:100px;"></div>

                <!-- The Card Editor Wrapper -->
                <div style="position: relative; width: 250px; height: 350px;">
                    <div id="editor-card-white" contenteditable="true" class="card white"
                        style="width: 100%; height: 100%; font-size: 1.4rem; padding: 20px; box-sizing: border-box; outline: none; border: 2px dashed #ccc; display:flex; align-items:flex-start;"
                        data-placeholder="Escribe tu remate aqu√≠...">
                    </div>
                    <div class="card-logo" style="pointer-events: none; user-select: none; color: black;">
                        <span style="font-size: 1.2rem; margin-right: 5px;">‚ñ´</span> Cartas contra la humanidad
                    </div>
                </div>

                <!-- Right Control -->
                <button onclick="saveAndNewCard('white')" class="btn"
                    style="width:100px; height:auto; padding:10px; font-size:0.9rem; background:#2563eb;">
                    Crear otra carta ‚û°
                </button>
            </div>
        </div>

        <!-- Bottom List -->
        <div
            style="height: 220px; background: #d4d4d4; padding: 10px; display: flex; flex-direction: column; width: 100%; max-width: 100vw; box-sizing: border-box; overflow: hidden;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <strong style="color:#333;">Mis Cartas Blancas (<span id="count-white">0</span>)</strong>
                <div style="display:flex; gap:5px;">
                    <button onclick="triggerImport('white')" class="btn secondary"
                        style="font-size:0.75rem; padding:2px 8px; width:auto;">üì• Importar</button>
                    <button onclick="showExportOptions('white')" class="btn secondary"
                        style="font-size:0.75rem; padding:2px 8px; width:auto;">üì§ Exportar</button>
                    <button id="btn-del-mode-white" onclick="toggleDeleteMode('white')"
                        style="background:transparent; border:1px solid #666; color:#333; border-radius:4px; font-size:0.8rem; padding:2px 8px; cursor:pointer;">üóëÔ∏è
                        Eliminar</button>
                </div>
            </div>
            <div id="list-created-white"
                style="flex:1; display:flex; flex-direction:row; gap:10px; overflow-x:auto; overflow-y:hidden; padding-bottom:10px; align-items:center; width: 100%; min-width: 0;">
                <!-- Items go here -->
            </div>
            <input type="file" id="file-import-white" accept=".json" style="display:none;"
                onchange="handleImportFile(this, 'white')">
        </div>

        <!-- GUIDE MODAL WHITE -->
        <div id="guide-modal-white" class="hidden"
            style="position:fixed; top:0; left:0; width:100%; height:100%; z-index:2000; background:rgba(255,255,255,0.9); display:flex; align-items:center; justify-content:center; backdrop-filter:blur(3px);">
            <div
                style="background:white; color:black; padding:20px; border-radius:10px; max-width:500px; max-height:80vh; overflow-y:auto; border:1px solid #ccc; box-shadow: 0 10px 25px rgba(0,0,0,0.2);">
                <div
                    style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eee; padding-bottom:10px; margin-bottom:10px;">
                    <h3 style="margin:0;">ü§ç Gu√≠a para crear Cartas Blancas</h3>
                    <button onclick="toggleGuide('white')"
                        style="background:none; border:none; color:black; font-size:1.5rem; cursor:pointer;">&times;</button>
                </div>
                <p style="font-size:0.9rem;">Las cartas blancas son el remate. Deben poder encajar en muchas situaciones
                    distintas.</p>

                <h4 style="color:#10b981;">‚úî Buenas pr√°cticas</h4>
                <ul style="font-size:0.9rem; padding-left:20px;">
                    <li>Sustantivo, acci√≥n o idea absurda.</li>
                    <li>Ambiguas y vers√°tiles.</li>
                    <li>Humor por contraste o exageraci√≥n.</li>
                </ul>

                <h4 style="color:#ef4444;">‚ùå Evita</h4>
                <ul style="font-size:0.9rem; padding-left:20px;">
                    <li>Frases demasiado largas.</li>
                    <li>Explicaciones o referencias ultra espec√≠ficas.</li>
                </ul>

                <h4 style="color:#fbbf24;">üìù Ejemplos</h4>
                <ul style="font-size:0.9rem; padding-left:20px; font-style:italic;">
                    <li>‚ÄúUn aplauso inc√≥modo.‚Äù</li>
                    <li>‚ÄúTomarlo demasiado en serio.‚Äù</li>
                </ul>

                <div style="background:#f0f0f0; padding:10px; border-radius:5px; margin-top:15px;">
                    <strong>üéØ Tip general:</strong> Una buena carta blanca deber√≠a funcionar bien con muchas cartas
                    negras.
                </div>

                <button onclick="toggleGuide('white')" class="btn"
                    style="width:100%; margin-top:20px;">Entendido</button>
            </div>
        </div>
    </div>

    </div> <!-- Close Screen Lobby -->

    <!-- SCREEN 3: GAME -->
    <div id="screen-game" class="screen hidden"
        style="background: #e5e5e5; display: flex; flex-direction: column; overflow: hidden;">
        <!-- Unified Game Header -->
        <div id="unified-game-header"
            style="flex: 0 0 auto; width: 100%; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 20; box-sizing: border-box;">
            <!-- Top Row: Stats -->
            <div
                style="display: flex; justify-content: space-between; align-items: center; padding: 8px 15px; border-bottom: 1px solid #f0f0f0;">
                <div
                    style="flex: 1; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem;">
                    <strong>T√∫:</strong> <span id="my-score" style="font-weight:bold; color:#2563eb;">0</span>
                </div>
                <div style="font-weight:bold; color:#e11d48; min-width: 50px; text-align:center; font-size: 1rem;">
                    <span id="game-timer">--</span>
                </div>
                <div
                    style="flex: 1; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem;">
                    <strong>Juez:</strong> <span id="czar-name" style="font-weight:bold;">...</span>
                </div>
            </div>
            <!-- Bottom Row: Status -->
            <div id="status-display"
                style="text-align: center; padding: 8px 10px; font-size: 0.95rem; color: #1f2937; font-weight: 600; background: #fdfdfd; width: 100%; box-sizing: border-box;">
                Estado...
            </div>
        </div>

        <!-- Player List (Floating but smaller) -->
        <div id="ingame-player-list"
            style="position: absolute; top: 100px; right: 10px; text-align: right; pointer-events: none; z-index: 15; opacity: 0.8; transform: scale(0.8); transform-origin: top right;">
        </div>

        <!-- SCROLLABLE CONTENT AREA -->
        <!-- SCROLLABLE CONTENT AREA -->
        <div
            style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 10px; padding-top: 20px; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 100%; box-sizing: border-box;">

            <!-- 1. BLACK CARD (Always Top) -->
            <div id="black-card-spot" style="margin-bottom: 15px; flex: 0 0 auto;"></div>

            <!-- 2. MY HAND & CONTROLS (Priority View) -->
            <!-- Wrapped in container to toggle visibility easily -->
            <div id="hand-container"
                style="width: 100%; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center;">
                <h3 id="hand-title" style="color:#666; font-size:0.9rem; margin-bottom:5px;">Tu Mano</h3>
                <div id="hand-scroll-area"
                    style="width: 100%; overflow-x: auto; padding: 5px; border-radius: 8px; background: rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.05); white-space: nowrap; box-sizing: border-box;">
                    <div id="hand-area" style="display: flex; gap: 8px; padding-bottom: 5px;">
                        <!-- Cards injected here -->
                    </div>
                </div>

                <!-- Helper Buttons -->
                <div id="player-controls"
                    style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <button id="btn-confirm-selection" class="btn hidden" onclick="submitSelection()"
                        style="background:#2563eb; width: auto; padding: 8px 20px;">CONFIRMAR SELECCI√ìN</button>

                    <!-- Swap UI -->
                    <button id="btn-swap-cards" class="btn secondary" onclick="enableSwapMode()"
                        style="width: auto; font-size: 0.8rem;">Cambiar 2 Cartas</button>
                    <button id="btn-cancel-swap" class="btn hidden" onclick="resetSwapUI(false)"
                        style="background:#ef4444; width: auto;">Cancelar</button>
                    <!-- Fixed ID below -->
                </div>
                <button id="btn-confirm-swap" class="btn hidden" onclick="submitSwap()"
                    style="background:#e11d48; margin-top:5px; width:auto;">CONFIRMAR CAMBIO</button>
                <p id="swap-msg" class="hidden"
                    style="color:#e11d48; font-weight:bold; font-size:0.9rem; margin-top:5px;">Selecciona 2 cartas...
                </p>
            </div>

            <!-- 3. PLAYED CARDS (Bottom) -->
            <div
                style="width: 100%; border-top: 1px solid #ddd; margin-top: 10px; padding-top: 10px; text-align: center;">
                <h3 style="color:#666; font-size:1rem; margin-bottom:10px;">Cartas en la Mesa</h3>
                <div id="played-cards-area"
                    style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; width: 100%;">
                    <!-- Submitted/Played cards go here -->
                </div>
            </div>

            <br><br>
        </div>
    </div>

    <script src="cards.js"></script>
    <script>
        /* --- GAME DATA --- */
        let whiteCards = [];
        let blackCards = [];

        function loadCards() {
            try {
                if (typeof CAH_WHITE !== 'undefined' && typeof CAH_BLACK !== 'undefined') {
                    whiteCards = [...CAH_WHITE];
                    blackCards = [...CAH_BLACK];
                    console.log(`Cargadas ${whiteCards.length} blancas y ${blackCards.length} negras.`);
                } else {
                    throw new Error("Variables CAH_WHITE/CAH_BLACK no definidas");
                }
            } catch (e) {
                console.error(e);
                alert("Error cargando cartas: Verifique cards.js");
            }
        }
        loadCards();

        /* --- STATE --- */
        let peer, myId, myName;
        let myHand = []; // Local source of truth for UI
        let isHost = false;
        let hostConn = null;
        let connections = {};
        let players = []; // {id, name, score, hand: []}
        let pointsToWin = 3;
        let gameMode = 'JUDGE'; // 'JUDGE' or 'DEMOC'
        let timerSetting = 40; // Seconds, -1 for infinite
        let currentTimer = 0;
        let timerInterval = null;

        let gameState = {
            phase: 'LOBBY', // LOBBY, SELECTION, JUDGING, SCORE, VOTING
            gameMode: 'JUDGE',
            czarIndex: 0,
            blackCard: null,
            round: 0,
            submissions: [],
            players: []
        };

        /* --- DECK MANAGEMENT HELPERS --- */
        function refillWhiteDeck() {
            let potentialCards = [...CAH_WHITE];

            // Add custom cards (Host)
            const boostFactor = 3;
            if (myCreatedCards.white.length > 0) {
                for (let i = 0; i < boostFactor; i++) {
                    potentialCards.push(...myCreatedCards.white.map(c => c.text));
                }
            }

            // Add custom cards (Clients)
            if (isHost) {
                Object.values(serverPlayerCards).forEach(playerCards => {
                    if (playerCards.white && playerCards.white.length > 0) {
                        for (let i = 0; i < boostFactor; i++) {
                            potentialCards.push(...playerCards.white.map(c => c.text));
                        }
                    }
                });
            }

            // Identify cards currently in play to avoid duplicates
            // We only care about this if the game has started (players exist)
            const cardsInUse = new Set();
            if (typeof players !== 'undefined') {
                players.forEach(p => {
                    if (p.hand && Array.isArray(p.hand)) {
                        p.hand.forEach(c => cardsInUse.add(c));
                    }
                });
            }
            if (typeof gameState !== 'undefined' && gameState.submissions) {
                gameState.submissions.forEach(s => {
                    if (s.cards && Array.isArray(s.cards)) {
                        s.cards.forEach(c => cardsInUse.add(c));
                    }
                });
            }

            // Filter
            const uniqueCards = potentialCards.filter(c => !cardsInUse.has(c));

            if (uniqueCards.length > 0) {
                whiteCards = uniqueCards;
            } else {
                console.warn("Deck exhaustion: Not enough unique cards. Allowing duplicates.");
                whiteCards = potentialCards;
            }

            whiteCards.sort(() => Math.random() - 0.5);
            console.log("White Deck Refilled. Size:", whiteCards.length);
        }

        function refilBlackDeck() {
            blackCards = [...CAH_BLACK];
            const boostFactor = 3;
            if (myCreatedCards.black.length > 0) {
                for (let i = 0; i < boostFactor; i++) {
                    blackCards.push(...myCreatedCards.black);
                }
            }

            // Add custom cards (Clients)
            if (isHost) {
                Object.values(serverPlayerCards).forEach(playerCards => {
                    if (playerCards.black && playerCards.black.length > 0) {
                        for (let i = 0; i < boostFactor; i++) {
                            blackCards.push(...playerCards.black);
                        }
                    }
                });
            }
            blackCards.sort(() => Math.random() - 0.5);
            console.log("Black Deck Refilled. Size:", blackCards.length);
        }

        function drawWhiteCards(count) {
            if (whiteCards.length < count) {
                refillWhiteDeck();
            }
            return whiteCards.splice(0, count);
        }

        /* --- NETWORK (Standard Arcade P2P) --- */
        let pendingJoinCode = null;

        // --- Custom Cards Data ---
        let myCreatedCards = { white: [], black: [] };
        // HOST ONLY: Store all created cards from everyone, organized by Player ID
        // Structure: { "PLAYER_ID": { white: [], black: [] }, ... }
        let serverPlayerCards = {};

        let deleteMode = { white: false, black: false };
        let editingIndex = { white: -1, black: -1 };

        function showCreateCardMenu() {
            document.getElementById('modal-create-card-menu').classList.remove('hidden');
        }

        function openCreateCardForm(type) {
            document.getElementById('modal-create-card-menu').classList.add('hidden');
            document.getElementById('screen-lobby').classList.add('hidden');
            document.getElementById(`creator-view-${type}`).classList.remove('hidden');

            const editor = document.getElementById(`editor-card-${type}`);
            editor.innerText = '';
            editor.focus();

            renderCreatedList(type);

            if (type === 'black') {
                setupBlackCardInputLogic(editor);
            }
        }

        function leaveCreator(type) {
            document.getElementById(`creator-view-${type}`).classList.add('hidden');
            document.getElementById('screen-lobby').classList.remove('hidden');
            editingIndex[type] = -1;
            deleteMode[type] = false;
        }

        function toggleGuide(type) {
            const el = document.getElementById(`guide-modal-${type}`);
            if (el.classList.contains('hidden')) el.classList.remove('hidden');
            else el.classList.add('hidden');
        }

        function setupBlackCardInputLogic(editor) {
            editor.onkeydown = handleBlackKeydown;
            editor.onkeypress = handleBlackKeypress;
        }

        function handleBlackKeypress(e) {
            if (e.key === '_') {
                e.preventDefault();
                alert("Usa el bot√≥n 'Poner espacio' para insertar espacios en blanco.");
            }
        }

        function handleBlackKeydown(e) {
            if (e.key === 'Backspace' || e.key === 'Delete') {
                const sel = window.getSelection();
                if (!sel.rangeCount) return;

                const node = sel.anchorNode;
                // We assume editing simple text content mostly. 
                // If text node
                if (node.nodeType === 3) {
                    const text = node.textContent;
                    const offset = sel.anchorOffset;

                    // BACKSPACE
                    if (e.key === 'Backspace' && offset > 0) {
                        const charToDelete = text[offset - 1];
                        let rangeStart = -1;
                        let rangeEnd = offset;

                        // Case A: Deleting underscore
                        if (charToDelete === '_') {
                            let start = offset - 1;
                            while (start > 0 && text[start - 1] === '_') start--;
                            let end = offset;
                            while (end < text.length && text[end] === '_') end++;
                            rangeStart = start;
                            rangeEnd = end;
                        }
                        // Case B: Deleting SPACE adjacent to underscore
                        else if (charToDelete === ' ' && offset > 1 && text[offset - 2] === '_') {
                            // Space at offset-1. Underscore at offset-2.
                            let start = offset - 2;
                            while (start > 0 && text[start - 1] === '_') start--;
                            rangeStart = start;
                            // rangeEnd is offset (includes the space)
                        }

                        if (rangeStart !== -1) {
                            e.preventDefault();
                            const range = document.createRange();
                            range.setStart(node, rangeStart);
                            range.setEnd(node, rangeEnd);
                            range.deleteContents();
                            return;
                        }
                    }

                    // DELETE
                    if (e.key === 'Delete' && offset < text.length) {
                        const charToDelete = text[offset];
                        let rangeStart = offset;
                        let rangeEnd = -1;

                        // Case A: Deleting underscore
                        if (charToDelete === '_') {
                            let start = offset;
                            while (start > 0 && text[start - 1] === '_') start--;
                            let end = offset;
                            while (end < text.length && text[end] === '_') end++;
                            rangeStart = start;
                            rangeEnd = end;
                        }
                        // Case B: Deleting SPACE adjacent to underscore NEXT
                        else if (charToDelete === ' ' && (offset + 1) < text.length && text[offset + 1] === '_') {
                            // Space at offset. Underscore at offset+1
                            let end = offset + 1;
                            while (end < text.length && text[end] === '_') end++;
                            rangeEnd = end;
                            // rangeStart is offset (includes the space)
                        }

                        if (rangeEnd !== -1) {
                            e.preventDefault();
                            const range = document.createRange();
                            range.setStart(node, rangeStart);
                            range.setEnd(node, rangeEnd);
                            range.deleteContents();
                        }
                    }
                }
            }
        }

        function insertBlankInEditor() {
            const editor = document.getElementById('editor-card-black');
            editor.focus();

            const sel = window.getSelection();
            if (!sel.rangeCount) return;

            const range = sel.getRangeAt(0);
            const node = sel.anchorNode;

            // Check context for auto-spacing
            let prefix = "";
            let suffix = " "; // Always add space after

            // Check previous char
            if (node.nodeType === 3) {
                const text = node.textContent;
                const offset = sel.anchorOffset;
                if (offset > 0 && text[offset - 1] !== ' ' && text[offset - 1] !== '\u00A0') {
                    prefix = " ";
                }
            }

            const blankText = `${prefix}_______${suffix}`;

            if (document.execCommand) {
                document.execCommand('insertText', false, blankText);
            } else {
                range.deleteContents();
                range.insertNode(document.createTextNode(blankText));
                range.collapse(false); // Move to end
            }
        }

        function saveAndNewCard(type) {
            const editor = document.getElementById(`editor-card-${type}`);
            const text = editor.innerText.trim();

            if (!text) {
                alert("La carta est√° vac√≠a.");
                return;
            }

            // Calc blanks
            let blanks = 0;
            if (type === 'black') {
                const matches = text.match(/_______/g);
                blanks = matches ? matches.length : 0;
                if (blanks === 0) blanks = 1;
            }

            const cardObj = { text: text, id: Date.now() };
            if (type === 'black') cardObj.blanks = blanks;

            if (editingIndex[type] !== -1) {
                myCreatedCards[type][editingIndex[type]] = cardObj;
                editingIndex[type] = -1;
            } else {
                myCreatedCards[type].push(cardObj);
            }

            // Centralized Sync: Send to Host
            if (!isHost && hostConn && hostConn.open) {
                hostConn.send({
                    type: 'SAVE_CARD_TO_HOST',
                    cardType: type,
                    cardData: cardObj
                });
            }
            // If Host, we already saved to myCreatedCards above. No need to duplicate to serverPlayerCards.

            editor.innerText = '';
            editor.focus();
            renderCreatedList(type);
        }

        function renderCreatedList(type) {
            const list = document.getElementById(`list-created-${type}`);
            const count = document.getElementById(`count-${type}`);
            list.innerHTML = '';

            const cards = myCreatedCards[type];
            count.innerText = cards.length;

            cards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `card ${type}`;
                div.style.minWidth = '100px';
                div.style.width = '100px';
                div.style.height = '140px';
                div.style.fontSize = '0.6rem';
                div.style.display = 'flex';
                div.style.flexDirection = 'column';
                div.style.alignItems = 'center';
                div.style.justifyContent = 'center';
                div.style.padding = '5px';
                div.style.flex = '0 0 auto';
                div.style.position = 'relative';
                div.style.cursor = 'pointer';
                div.style.overflow = 'hidden';
                div.style.wordBreak = 'break-word';
                div.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                div.style.borderRadius = '8px';

                // Card Text Content
                const textSpan = document.createElement('span');
                textSpan.innerText = card.text;
                textSpan.style.zIndex = '2';
                textSpan.style.textAlign = 'center';
                div.appendChild(textSpan);

                // Watermark Logo
                const logo = document.createElement('div');
                logo.className = 'card-logo';
                logo.style.fontSize = '0.35rem';
                logo.style.bottom = '4px';
                logo.style.left = '4px';
                logo.style.pointerEvents = 'none';
                logo.style.color = (type === 'black' ? 'white' : 'black');
                logo.innerHTML = `<span style="font-size:0.5rem; margin-right:2px;">${type === 'black' ? '‚óº' : '‚ñ´'}</span> Cartas contra la humanidad`;

                div.appendChild(logo);

                if (deleteMode[type]) {
                    div.style.border = '2px solid red';
                    div.onclick = () => {
                        if (confirm("¬øEliminar carta?")) {
                            myCreatedCards[type].splice(idx, 1);
                            renderCreatedList(type);
                        }
                    };
                } else {
                    div.onclick = () => {
                        if (document.getElementById(`editor-card-${type}`).innerText.trim() !== '') {
                            if (!confirm("¬øEditar esta carta? Se perder√° lo que escribiste si no guardaste.")) return;
                        }
                        document.getElementById(`editor-card-${type}`).innerText = card.text;
                        editingIndex[type] = idx;
                    };
                }

                list.appendChild(div);
            });
        }

        function toggleDeleteMode(type) {
            deleteMode[type] = !deleteMode[type];
            const btn = document.getElementById(`btn-del-mode-${type}`);
            if (btn) {
                btn.style.background = deleteMode[type] ? '#ef4444' : 'transparent';
                btn.style.color = deleteMode[type] ? 'white' : '#333';
            }
            renderCreatedList(type);
        }

        // --- IMPORT / EXPORT LOGIC ---
        function showExportOptions(type) {
            // New Centralized Export Logic
            if (isHost && globalCreatedCards[type].length === 0 && myCreatedCards[type].length === 0) {
                return alert("No hay cartas para exportar.");
            }
            if (!isHost && myCreatedCards[type].length === 0) {
                // Even if local is empty, might want to export global? 
                // But typically user exports what they see. 
                // Let's ask if they want to export ALL from the room.
            }

            const choice = prompt(`¬øQu√© deseas exportar?\n1. Mis Cartas Locales (Solo las que creaste aqu√≠)\n2. TODAS las cartas de la sala (De todos los jugadores)`, "2");

            if (choice === "1") {
                exportCardsJSON(type, myCreatedCards[type], "mis_cartas_locales");
            } else if (choice === "2") {
                if (isHost) {
                    // Host export ALL
                    const exportSet = [];

                    // 1. Host's Cards
                    myCreatedCards[type].forEach(c => exportSet.push({ ...c, creator: 'Host' }));

                    // 2. Clients' Cards
                    Object.keys(serverPlayerCards).forEach(pId => {
                        const pCards = serverPlayerCards[pId][type];
                        if (pCards) {
                            const pName = (players.find(p => p.id === pId) || { name: pId }).name;
                            pCards.forEach(c => exportSet.push({ ...c, creator: pName }));
                        }
                    });

                    exportCardsJSON(type, exportSet, "todas_cartas_sala");
                } else {
                    // Ask Host
                    if (hostConn && hostConn.open) {
                        hostConn.send({ type: 'REQUEST_EXPORT', cardType: type });
                        alert("Solicitud enviada al Anfitri√≥n. La descarga comenzar√° pronto...");
                    } else {
                        alert("No est√°s conectado al Anfitri√≥n.");
                    }
                }
            }
        }

        function exportCardsJSON(type, cardsSource, prefix) {
            // Clean format
            const cleanedCards = cardsSource.map(c => {
                if (type === 'black') {
                    let b = c.blanks;
                    if (!b) {
                        const matches = c.text.match(/_______/g);
                        b = matches ? matches.length : 0;
                        if (b === 0) b = 1;
                    }
                    return { text: c.text, blanks: b };
                } else {
                    return { text: c.text };
                }
            });

            const data = {
                type: (type === 'black' ? 'N' : 'B'),
                cards: cleanedCards
            };
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${prefix}_${type}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function triggerImport(type) {
            document.getElementById(`file-import-${type}`).click();
        }

        function handleImportFile(input, type) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // Validate Type
                    const expectedType = (type === 'black' ? 'N' : 'B');

                    if (data.type !== expectedType) {
                        const gotColor = (data.type === 'N') ? 'Negras' : 'Blancas';
                        const expectedColor = (type === 'black') ? 'Negras' : 'Blancas';
                        alert(`‚ùå El archivo que subiste es de cartas ${gotColor}, debe ser de cartas ${expectedColor}.`);
                        return;
                    }

                    if (Array.isArray(data.cards)) {
                        let added = 0;
                        data.cards.forEach(c => {
                            // Assign ID if missing
                            if (!c.id) c.id = Date.now() + Math.random();

                            // Add Local
                            myCreatedCards[type].push(c);
                            added++;

                            // SYNC TO HOST (if I am client)
                            if (!isHost && hostConn && hostConn.open) {
                                hostConn.send({
                                    type: 'SAVE_CARD_TO_HOST',
                                    cardType: type,
                                    cardData: c
                                });
                            }
                        });
                        alert(`‚úÖ Importadas ${added} cartas ${type === 'black' ? 'negras' : 'blancas'}.`);
                        renderCreatedList(type);
                    } else {
                        alert("Formato de archivo inv√°lido (faltan cartas).");
                    }

                } catch (err) {
                    console.error(err);
                    alert("Error leyendo el archivo JSON.");
                }
            };
            reader.readAsText(file);
            input.value = '';
        }



        /* --- NETWORK SETUP --- */
        function initPeer(customId = null) {
            // 1. Create Peer
            if (customId) {
                peer = new Peer(customId);
            } else {
                peer = new Peer(); // Auto ID for client
            }

            // 2. Event Listeners
            peer.on('open', (id) => {
                console.log('My Peer ID:', id);
                myId = id;

                // HOST LOGIC
                if (isHost) {
                    // Update my own ID in player list
                    if (players.length > 0) {
                        players[0].id = id;
                        updateLobbyUI();
                    }
                }
                // CLIENT LOGIC
                else {
                    if (pendingJoinCode) {
                        connectToHost(pendingJoinCode);
                    }
                }
            });

            peer.on('connection', (conn) => {
                // Incoming connection (Host logic mostly)
                handleConnection(conn);
            });

            peer.on('error', (err) => {
                console.error("P2P Error:", err);
                if (err.type === 'peer-unavailable') {
                    alert("No se encontr√≥ la sala. Verifica el c√≥digo.");
                    showScreen('screen-menu');
                } else if (err.type === 'unavailable-id') {
                    alert("El c√≥digo de sala ya est√° en uso. Intenta otro.");
                    showScreen('screen-menu');
                } else {
                    console.log("Error no critico:", err);
                }
            });
        }

        function handleConnection(conn) {
            // Check if already connected
            if (connections[conn.peer]) return;

            // Handle Open
            conn.on('open', () => {
                console.log("Conexi√≥n establecida con:", conn.peer);
                connections[conn.peer] = conn;

                if (isHost) {
                    // Host sends state to new player
                    conn.send({ type: 'UPDATE_LOBBY', players: players });
                } else {
                    // Client sends Hello
                    hostConn = conn; // Store ref
                    conn.send({ type: 'HELLO', name: myName });
                    onJoinSuccess(pendingJoinCode);
                }
            });

            // Handle Data
            conn.on('data', (data) => {
                handleData(data, conn.peer);
            });

            // Handle Close
            conn.on('close', () => {
                console.log("Conexi√≥n cerrada:", conn.peer);
                delete connections[conn.peer];
                if (isHost) {
                    players = players.filter(p => p.id !== conn.peer);
                    broadcast({ type: 'UPDATE_LOBBY', players: players });
                } else {
                    alert("Desconectado del Anfitri√≥n");
                    location.reload();
                }
            });

            conn.on('error', err => console.error("Conn Error:", err));
        }

        /* --- HOST LOGIC --- */
        function createRoom() {
            myName = document.getElementById('nickname').value || "Host";
            const code = Math.random().toString(36).substr(2, 4).toUpperCase();
            isHost = true;
            players = [{ id: "HOST", name: myName, score: 0, hand: [] }]; // Temp ID

            showScreen('screen-lobby');
            document.getElementById('host-controls').classList.remove('hidden');

            // Set display code immediately
            document.getElementById('lobby-code').innerText = code;

            initPeer("cah_" + code);
        }

        /* --- CLIENT LOGIC --- */
        function joinRoom() {
            myName = document.getElementById('nickname').value || "Guest";
            const code = document.getElementById('room-code-input').value.trim().toUpperCase();
            if (!code) return alert("Ingresa c√≥digo");

            isHost = false;
            pendingJoinCode = code; // Store for when open fires
            initPeer(); // No ID = Client
        }

        function connectToHost(code) {
            console.log("Conectando a:", "cah_" + code);
            const conn = peer.connect("cah_" + code);
            // We must setup connection handlers on the OUTGOING connection object too
            handleConnection(conn);
        }

        /* --- GAME LOGIC --- */
        function startGame() {
            if (players.length < 2) return alert("Se necesitan al menos 2 jugadores (ideal 3+)");

            console.log("Starting game. Players:", JSON.stringify(players));

            // Reset Game State
            gameState.round = 0;
            gameState.submissions = [];

            // Initial Refill
            refillWhiteDeck();
            refilBlackDeck();

            // Deal initial hands (7 cards)
            players.forEach(p => {
                p.hand = drawWhiteCards(10);
                if (p.id !== myId) {
                    const conn = connections[p.id];
                    if (conn && conn.open) conn.send({ type: 'UPDATE_HAND', hand: p.hand });
                } else {
                    myHand = p.hand; // Sync local variable for Host
                    updateHandUI(p.hand); // Host hand
                }
            });

            startRound();
        }

        function startRound() {
            console.log("startRound executing. Players:", players.length, "Round:", gameState.round);

            if (players.length === 0) {
                console.error("Critical: No players in startRound!");
                return;
            }

            gameState.phase = 'SELECTION';
            gameState.submissions = [];

            // Refill decks if empty (simple reload for black)
            if (blackCards.length === 0) refilBlackDeck();

            // Next Black Card
            gameState.blackCard = blackCards.pop();
            gameState.gameMode = gameMode; // Lock in mode for the round

            // Next Czar (Only for JUDGE mode)
            if (gameMode === 'JUDGE') {
                if (gameState.round === 0) {
                    gameState.czarIndex = 0;
                } else {
                    if (gameState.czarIndex >= players.length) gameState.czarIndex = -1;
                    gameState.czarIndex = gameState.round % players.length;
                }

                if (!players[gameState.czarIndex]) {
                    gameState.czarIndex = 0;
                }
                gameState.czarId = players[gameState.czarIndex].id;
            } else {
                gameState.czarIndex = -1;
                gameState.czarId = null; // No czar
            }

            const isFirstRound = (gameState.round === 0);

            // Reset Swap State
            players.forEach(p => p.hasSwapped = false);
            hasSwappedThisRound = false;
            resetSwapUI(true);

            const stateSnapshot = {
                phase: gameState.phase,
                blackCard: gameState.blackCard,
                czarId: gameState.czarId,
                round: gameState.round,
                submissions: [], // Empty for clients initially
                players: players.map(p => ({ id: p.id, name: p.name, score: p.score, hasSwapped: false }))
            };

            broadcast({ type: 'SITUATION_UPDATE', state: stateSnapshot });

            if (isFirstRound) {
                console.log("First round detected, broadcasting GAME_START");
                broadcast({ type: 'GAME_START', state: stateSnapshot });
            }

            // We must update the local round variable if it was overwritten by handleData/stateSnapshot
            gameState.round = (gameState.round || 0) + 1;

            if (isHost && timerSetting !== -1) {
                startTimerSequence();
            }
        }

        let currentStateTimer = null;
        function startTimerSequence() {
            if (currentStateTimer) clearInterval(currentStateTimer);
            let timeLeft = timerSetting;

            // Broadcast initial time
            broadcast({ type: 'SITUATION_UPDATE', state: gameState, timeLeft: timeLeft }); // Reuse situation update to sync time

            currentStateTimer = setInterval(() => {
                timeLeft--;
                // Broadcast time tick (optimize? maybe every 5s or just local countdown? 
                // Let's broadcast every second for sync primarily for now, optimization later if needed)
                // Actually, sending state every second is heavy. Let's send TIME_TICK.
                broadcast({ type: 'TIME_TICK', timeLeft: timeLeft });

                if (timeLeft <= 0) {
                    clearInterval(currentStateTimer);
                    handleTimeout();
                }
            }, 1000);
        }

        function handleTimeout() {
            console.log("Timer Expired for phase:", gameState.phase);
            if (gameState.phase === 'SELECTION') {
                // Force submit for players who haven't submitted
                const submittedIds = gameState.submissions.map(s => s.playerId);
                players.forEach(p => {
                    if (p.id === gameState.czarId && gameMode === 'JUDGE') return; // Czar safe
                    if (!submittedIds.includes(p.id)) {
                        // Auto pick random
                        const required = gameState.blackCard.blanks || 1;
                        // Clone hand to avoid mutation issues during splice loop
                        const available = [...p.hand];
                        const picks = [];
                        for (let i = 0; i < required; i++) {
                            if (available.length > 0) {
                                const ridx = Math.floor(Math.random() * available.length);
                                picks.push(available[ridx]);
                                available.splice(ridx, 1);
                            }
                        }
                        console.log(`Auto-picked for ${p.name}:`, picks);
                        handleSubmission(p.id, picks);
                    }
                });
            } else if (gameState.phase === 'JUDGING' || gameState.phase === 'VOTING') {
                // Force winner selection
                if (gameMode === 'JUDGE') {
                    // Host (Czar?) picks random if Czar didn't pick
                    // Actually handleTimeout is Host logic.
                    // If Czar hasn't picked...
                    const count = gameState.submissions.length;
                    if (count > 0) {
                        const ridx = Math.floor(Math.random() * count);
                        hostSelectWinner(ridx);
                    }
                } else {
                    // Voting: Time is up, score with current votes
                    scoreVotingRound();
                }
            }
        }



        function changePoints(delta) {
            if (!isHost) return;
            let newP = pointsToWin + delta;
            if (newP < 2) newP = 2;
            if (newP > 15) newP = 15;
            if (pointsToWin !== newP) {
                pointsToWin = newP;
                syncSettings();
            }
        }

        function changeGameMode(mode) {
            if (!isHost) return;
            if (gameMode !== mode) {
                gameMode = mode;
                syncSettings();
            }
        }

        function changeTimer(delta) {
            if (!isHost) return;
            if (timerSetting === -1) timerSetting = 40; // Restore if coming from infinite
            else {
                let newT = timerSetting + delta;
                if (newT < 20) newT = 20;
                if (newT > 120) newT = 120;
                timerSetting = newT;
            }
            syncSettings();
        }

        function toggleTimerLimit() {
            if (!isHost) return;
            if (timerSetting === -1) timerSetting = 40;
            else timerSetting = -1;
            syncSettings();
        }

        function syncSettings() {
            updateLobbySettingsUI();
            broadcast({ type: "UPDATE_SETTINGS", pointsToWin: pointsToWin, gameMode: gameMode, timerSetting: timerSetting });
        }

        function updateLobbySettingsUI() {
            document.getElementById("points-display-host").innerText = pointsToWin;
            document.getElementById("points-display-client").innerText = pointsToWin;
            const modeText = (gameMode === "JUDGE") ? "Juez Cl√°sico" : "Democracia";
            document.getElementById("mode-display-client").innerText = modeText;

            // Timer UI
            const timeStr = (timerSetting === -1) ? "‚àû" : timerSetting + "s";
            document.getElementById("timer-display-host").innerText = timeStr;
            document.getElementById("timer-setting-client").innerText = timeStr;
            const timerBtn = document.getElementById("btn-timer-toggle");
            if (timerBtn) {
                if (timerSetting === -1) {
                    timerBtn.innerText = "Activar L√≠mite";
                    timerBtn.classList.remove('secondary');
                } else {
                    timerBtn.innerText = "Sin L√≠mite";
                    timerBtn.classList.add('secondary');
                }
            }

            const btnJudge = document.getElementById("btn-mode-judge");
            const btnDemo = document.getElementById("btn-mode-demo");
            if (btnJudge && btnDemo) {
                if (gameMode === "JUDGE") {
                    btnJudge.classList.remove("secondary");
                    btnDemo.classList.add("secondary");
                } else {
                    btnJudge.classList.add("secondary");
                    btnDemo.classList.remove("secondary");
                }
            }
        }

        /* --- SWAP CARDS LOGIC --- */
        let isSwapping = false;
        let hasSwappedThisRound = false;

        function enableSwapMode() {
            if (gameState.phase !== 'SELECTION') return alert("Solo puedes cambiar cartas en tu turno.");
            if (gameState.czarId === myId) return alert("El Czar no puede cambiar cartas.");
            if (hasSwappedThisRound) return alert("Ya cambiaste cartas en esta ronda.");

            isSwapping = !isSwapping;
            selectedCards = [];
            updateHandUIHelper();

            const btn = document.getElementById('btn-swap-cards');
            if (isSwapping) {
                btn.style.background = '#e11d48'; // Red warning color
                btn.innerText = "CANCELAR CAMBIO";
                document.getElementById('status-display').innerText = "Selecciona 2 cartas para descartar...";
            } else {
                btn.style.background = 'white';
                btn.innerText = "Cambiar 2 Cartas";
                const status = document.getElementById('status-display');
                if (status) status.innerText = "Elige tus cartas m√°s graciosas.";
            }

            // Hide confirm button
            document.getElementById('btn-confirm-selection').classList.add('hidden');
        }

        function handleSwapRequest(cardTexts) {
            if (isHost) {
                processSwap(myId, cardTexts);
            } else {
                hostConn.send({ type: 'REQUEST_SWAP', cards: cardTexts });
            }
        }

        function processSwap(playerId, cardTexts) {
            const p = players.find(x => x.id === playerId);
            if (!p) return;
            if (p.hasSwapped) return;

            // Validate count
            if (cardTexts.length !== 2) {
                console.error("SWAP ERROR: Incorrect count", cardTexts.length);
                return;
            }

            console.log("SWAP: Hand BEFORE:", JSON.stringify(p.hand));
            console.log("SWAP: Targets:", JSON.stringify(cardTexts));

            // Ensure hand is array
            if (!p.hand || !Array.isArray(p.hand)) p.hand = [];

            // Remove cards
            cardTexts.forEach(submitText => {
                const cleanSubmit = submitText.trim();
                const idx = p.hand.findIndex(hCard => hCard.trim() === cleanSubmit);

                console.log(`SWAP: Looking for '${cleanSubmit}', found at ${idx}`);
                if (idx !== -1) p.hand.splice(idx, 1);
            });

            console.log("SWAP: Hand AFTER REMOVAL:", JSON.stringify(p.hand));

            // Add new ones
            // Add new ones
            const cardsNeeded = 10 - p.hand.length;
            if (cardsNeeded > 0) {
                const newCards = drawWhiteCards(cardsNeeded);
                p.hand.push(...newCards);
                console.log("SWAP: Drew new cards:", newCards);
            }

            p.hasSwapped = true;

            // Sync
            if (p.id !== myId) {
                const conn = connections[p.id];
                if (conn && conn.open) {
                    conn.send({ type: 'UPDATE_HAND', hand: p.hand });
                    conn.send({ type: 'SWAP_SUCCESS' });
                }
            } else {
                updateHandUI(p.hand);
                hasSwappedThisRound = true;
                resetSwapUI(false);
            }

            // Broadcast player state update to everyone so they see who swapped
            const safePlayers = players.map(pl => ({
                id: pl.id,
                name: pl.name,
                score: pl.score,
                hasSwapped: pl.hasSwapped
            }));
            broadcast({ type: 'PLAYER_UPDATE', players: safePlayers });
        }

        // Helper to reset UI after swap or new round
        function resetSwapUI(newRound = false) {
            isSwapping = false;
            selectedCards = [];

            const btn = document.getElementById('btn-swap-cards');
            if (!btn) return;

            if (newRound) {
                btn.classList.remove('hidden');
                btn.style.opacity = '1';
                btn.style.pointerEvents = 'auto';
                btn.innerText = "Cambiar 2 Cartas";
                btn.style.background = 'white';
                hasSwappedThisRound = false;
            } else {
                // Used
                btn.style.opacity = '0.5';
                btn.style.pointerEvents = 'none';
                btn.innerText = "Cambio Usado";
                btn.style.background = '#666';
            }

            // Also hide the confirmation button if it's visible
            const confirmBtn = document.getElementById('btn-confirm-selection');
            if (confirmBtn) confirmBtn.classList.add('hidden');
        }

        // Wrapper for UI update
        function updateHandUIHelper() {
            if (isHost) {
                const me = players.find(p => p.id === myId);
                if (me) updateHandUI(me.hand);
            } else {
                updateHandUI(myHand);
            }
        }

        function handleSubmission(playerId, cardIndices) {
            // Find player
            const p = players.find(x => x.id === playerId);
            if (!p) return;

            const selectedCards = [];

            if (!p.hand || !Array.isArray(p.hand)) p.hand = [];

            // cardIndices should be the card TEXT sent back
            cardIndices.forEach(submitText => {
                // Robust lookup: Normalize strings
                const cleanSubmit = submitText.trim();
                const idx = p.hand.findIndex(hCard => hCard.trim() === cleanSubmit);

                if (idx !== -1) {
                    selectedCards.push(p.hand[idx]);
                    p.hand.splice(idx, 1);
                } else {
                    console.error(`CRITICAL: Host logic mismatch. Player ${p.name} tried to play '${submitText}' but hand has:`, JSON.stringify(p.hand));
                    // Check for partial matches or encoding issues
                    // For now, we skip invalid cards to maintain integrity, 
                    // trusting that the improved matching handles whitespace issues.
                }
            });

            // Refill Hand to 10
            const cardsToDraw = 10 - p.hand.length;
            if (cardsToDraw > 0) {
                const drawn = drawWhiteCards(cardsToDraw);
                p.hand.push(...drawn);
            }



            // Sync Hand to player
            if (p.id !== myId) {
                const conn = connections[p.id];
                if (conn && conn.open) conn.send({ type: 'UPDATE_HAND', hand: p.hand });
            } else {
                updateHandUI(p.hand);
            }

            gameState.submissions.push({ playerId, cards: selectedCards, playerName: p.name });

            // Update UI to show "Player X submitted" (masked)
            const submissionCount = gameState.submissions.length;
            let expected = players.length;
            if (gameMode === 'JUDGE') expected = players.length - 1; // Czar doesn't play

            // Broadcast progress - MASKED to clients only
            const safeSubs = gameState.submissions.map(s => ({ playerId: s.playerId, status: 'HIDDEN' }));

            // IMPORTANT: Exclude local update (host) to prevent overwriting the 'Truth' with masked data
            broadcast({
                type: 'SITUATION_UPDATE',
                state: {
                    ...gameState,
                    submissions: safeSubs // Masked
                }
            }, true);

            // Manually update Host UI
            updateTableUI();

            if (submissionCount >= expected) {
                // All in! Switch to phase
                if (gameMode === 'JUDGE') {
                    startJudging();
                } else {
                    startVoting();
                }
            }
        }

        function startJudging() {
            gameState.phase = 'JUDGING';
            // Shuffle submissions
            gameState.submissions.sort(() => Math.random() - 0.5);

            // Broadcast fully revealed submissions
            broadcast({
                type: 'SITUATION_UPDATE',
                state: gameState
            });

            if (isHost && timerSetting !== -1) startTimerSequence();
        }

        function startVoting() {
            gameState.phase = 'VOTING';
            // Shuffle submissions
            gameState.submissions.forEach(s => s.votes = []); // Init votes
            gameState.submissions.sort(() => Math.random() - 0.5);

            // Broadcast fully revealed submissions
            broadcast({
                type: 'SITUATION_UPDATE',
                state: gameState
            });

            if (isHost && timerSetting !== -1) startTimerSequence();
        }

        function hostSelectWinner(submissionIndex) {
            const winnerSub = gameState.submissions[submissionIndex];
            const p = players.find(x => x.id === winnerSub.playerId);
            if (p) p.score++;

            gameState.phase = 'SCORE';

            // Sync GameState players to ensure consistency
            gameState.players = players;

            // Broadcast Updates
            broadcast({ type: 'PLAYER_UPDATE', players: players }); // Explicitly sync scores
            broadcast({
                type: 'SITUATION_UPDATE',
                state: {
                    ...gameState,
                    winnerName: p ? p.name : 'Desconocido', // Safely access name
                    winningCards: winnerSub.cards,
                    winningSubmissionIndex: submissionIndex
                }
            });
            checkGameEnd(p);
        }

        function handleVote(voterId, subIndex) {
            // Find who is voting
            // Allow self-votes (but they count as 0 later)
            const targetSub = gameState.submissions[subIndex];
            if (!targetSub) return;

            // Self-Vote Penalty Logic (Host Side)
            if (targetSub.playerId === voterId) {
                const voter = players.find(p => p.id === voterId);
                if (voter) {
                    voter.selfVoteCount = (voter.selfVoteCount || 0) + 1;
                    console.log(`Player ${voter.name} self-voted! Count: ${voter.selfVoteCount}`);

                    if (voter.selfVoteCount >= 3) {
                        voter.score--;
                        console.log(`Penalty applied to ${voter.name}. New Score: ${voter.score}`);
                        // Broadcast score update immediately
                        broadcast({ type: 'PLAYER_UPDATE', players: players });
                    }
                }
            }

            // Check if already voted? (Scan all submissions for this voterId in votes array)
            let alreadyVoted = false;
            gameState.submissions.forEach(s => {
                if (s.votes && s.votes.includes(voterId)) alreadyVoted = true;
            });
            if (alreadyVoted) return;

            // Record vote
            if (!targetSub.votes) targetSub.votes = [];
            targetSub.votes.push(voterId);

            console.log(`Vote recorded from ${voterId} for sub ${subIndex}`);

            // Check if all players have voted
            // Count total votes
            let totalVotes = 0;
            gameState.submissions.forEach(s => {
                if (s.votes) totalVotes += s.votes.length;
            });

            // Need votes from everyone? Or everyone except... no everyone votes in Democracy usually?
            // "y una vez votan todos sale el ganador"
            if (totalVotes >= players.length) {
                scoreVotingRound();
            }
        }

        function scoreVotingRound() {
            // Tally votes
            let maxVotes = -1;
            let winners = []; // Indices

            gameState.submissions.forEach((sub, idx) => {
                // Calculate valid votes (exclude self-votes)
                let validVotes = 0;
                if (sub.votes) {
                    sub.votes.forEach(voterId => {
                        if (voterId !== sub.playerId) validVotes++;
                    });
                }

                if (validVotes > maxVotes) {
                    maxVotes = validVotes;
                    winners = [idx];
                } else if (validVotes === maxVotes) {
                    winners.push(idx);
                }
            });

            // Assign points
            if (maxVotes > 0) {
                // Winner(s)
                // Remove automatic point increment for all "winners" array in first pass
                // winners.forEach(...) -> Removed. 
                // We handle point assignment in single winner logic below.

                // Winners check
                if (winners.length > 1) {
                    // TIE
                    gameState.winningSubmissionIndex = -1; // No single winner highlight
                    gameState.winnerName = "¬°EMPATE! Nadie gana puntos";
                    // No points added
                    gameState.phase = 'SCORE';

                    gameState.players = players; // SYNC

                    broadcast({ type: 'PLAYER_UPDATE', players: players });
                    broadcast({ type: 'SITUATION_UPDATE', state: gameState });

                    // Delay next round
                    setTimeout(() => startRound(), 5000);

                } else {
                    // Single Winner
                    gameState.winningSubmissionIndex = winners[0]; // Highlight first winner
                    const wSub = gameState.submissions[winners[0]];
                    const wPlayer = players.find(p => p.id === wSub.playerId);
                    gameState.winnerName = wPlayer ? wPlayer.name : "Nadie";
                    if (wPlayer) wPlayer.score++; // Point awarded to single winner

                    gameState.phase = 'SCORE';

                    gameState.players = players; // SYNC

                    broadcast({ type: 'PLAYER_UPDATE', players: players });
                    broadcast({ type: 'SITUATION_UPDATE', state: gameState });

                    if (wPlayer) checkGameEnd(wPlayer);
                }
            } else {
                gameState.winnerName = "Nadie (0 votos)";
                gameState.phase = 'SCORE';
                broadcast({ type: 'PLAYER_UPDATE', players: players });
                broadcast({
                    type: 'SITUATION_UPDATE',
                    state: gameState
                });

                // No score update, just wait
                setTimeout(() => startRound(), 5000);
            }
        }

        let gameStartTime = 0;

        function checkGameEnd(p) {
            // Check for Game Winner
            if (p.score >= pointsToWin) {
                // Game Over
                setTimeout(() => {
                    const durationMs = Date.now() - gameStartTime;
                    showGameOverScreen(p, durationMs);
                    // Broadcast to clients WITH final players list
                    broadcast({ type: 'GAME_OVER', winner: p, duration: durationMs, players: players });
                }, 1000);
            } else {
                // Wait then next round
                setTimeout(() => {
                    startRound();
                }, 5000);
            }
        }

        function showGameOverScreen(winner, durationMsOverride = null) {
            // Calculate Stats
            const durationMs = durationMsOverride || (Date.now() - gameStartTime);
            const minutes = Math.floor(durationMs / 60000);
            const seconds = Math.floor((durationMs % 60000) / 1000);

            // Conditional Title
            const titleEl = document.querySelector('#screen-game-over h1');
            if (winner.id === myId) {
                titleEl.innerHTML = 'üèÜ ¬°VICTORIA! üèÜ';
                titleEl.style.color = '#fbbf24';
            } else {
                titleEl.innerHTML = 'FIN DEL JUEGO';
                titleEl.style.color = 'white';
            }

            document.getElementById('go-winner-name').innerText = winner.name + " GAN√ì";

            // Leaderboard Generation
            // Ensure players list is up to date (it should be as we broadcast updates)
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);

            let tableHtml = `
            <div style="margin-bottom: 15px; font-size: 1.1rem; opacity: 0.8">
               ‚è±Ô∏è ${minutes}m ${seconds}s  ‚Ä¢  üîÑ ${gameState.round} Rondas
            </div>
            <table style="width: 100%; border-collapse: collapse; text-align: left; font-size: 1rem;">
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.3);">
                    <th style="padding: 8px;">#</th>
                    <th style="padding: 8px;">Jugador</th>
                    <th style="padding: 8px; text-align: right;">Puntos</th>
                </tr>
            `;

            sortedPlayers.forEach((p, index) => {
                const isWinner = p.id === winner.id;
                const isMe = p.id === myId;

                let rowBg = '';
                if (isMe) rowBg = 'background: rgba(255,255,255,0.15);';
                else if (isWinner) rowBg = 'background: rgba(251, 191, 36, 0.1);';

                const nameStyle = isWinner ? 'color: #fbbf24; font-weight: 800;' : (isMe ? 'font-weight: bold;' : '');
                const icon = isWinner ? 'üëë ' : '';
                const meTag = isMe ? ' <span style="font-size:0.8em; opacity:0.7">(T√∫)</span>' : '';

                tableHtml += `
                <tr style="${rowBg}">
                    <td style="padding: 8px; opacity: 0.7;">${index + 1}</td>
                    <td style="padding: 8px; ${nameStyle}">${icon}${p.name}${meTag}</td>
                    <td style="padding: 8px; text-align: right; font-weight: bold;">${p.score}</td>
                </tr>
                `;
            });
            tableHtml += '</table>';

            document.getElementById('go-stats').innerHTML = tableHtml;

            showScreen('screen-game-over');
        }

        function onJoinSuccess(code) {
            showScreen('screen-lobby');
            document.getElementById('lobby-code').innerText = code;
            document.getElementById('host-controls').classList.add('hidden');
            document.getElementById('client-settings-view').classList.remove('hidden');
        }

        let lastRoundId = -1;
        let myVotedIndex = -1; // Local state for voting

        function broadcast(msg, excludeLocal = false) {
            console.log("Broadcasting:", msg.type, "ExcludeLocal:", excludeLocal);
            Object.values(connections).forEach(c => {
                if (c && c.open) c.send(msg);
            });

            if (!excludeLocal) {
                try {
                    handleData(msg, 'HOST'); // Handle locally
                } catch (e) {
                    console.error("Local handleData failed:", e);
                }
            }
        }

        function handleData(data, senderId) {
            console.log("handleData received:", data.type, "from", senderId);
            try {
                switch (data.type) {
                    case 'HELLO':
                        if (isHost) {
                            // Check if exists
                            const existing = players.find(p => p.id === senderId);
                            if (!existing) {
                                players.push({ id: senderId, name: data.name, score: 0, hand: [] });
                                updateLobbyUI();
                                broadcast({ type: 'UPDATE_LOBBY', players: players });

                                // Sync settings to the new player personally
                                const conn = connections[senderId];
                                if (conn && conn.open) {
                                    conn.send({ type: 'UPDATE_SETTINGS', pointsToWin: pointsToWin, gameMode: gameMode, timerSetting: timerSetting });
                                }
                            }
                        }
                        break;
                    case 'UPDATE_LOBBY':
                        players = data.players;
                        updateLobbyUI();
                        break;
                    case 'UPDATE_SETTINGS':
                        pointsToWin = data.pointsToWin;
                        if (data.gameMode) gameMode = data.gameMode;
                        if (data.timerSetting !== undefined) {
                            timerSetting = data.timerSetting;
                        }
                        updateLobbySettingsUI();
                        break;
                    case 'GAME_START':
                        console.log("Processing GAME_START...");
                        gameState = data.state;
                        startGameUI();
                        break;
                    case 'UPDATE_HAND':
                        myHand = data.hand;
                        updateHandUI(myHand);
                        break;
                    case 'SITUATION_UPDATE':
                        console.log("Processing SITUATION_UPDATE...");

                        // Detect New Round
                        if (data.state.round !== lastRoundId) {
                            console.log("New Round Detected:", data.state.round);
                            lastRoundId = data.state.round;
                            // Reset local round state
                            hasSwappedThisRound = false;
                            resetSwapUI(true);
                            selectedCards = [];
                            myVotedIndex = -1; // Reset vote
                            // Removing 'selected' class from visual cards is handled by updateHandUI if hand updates, 
                            // but if hand doesn't update (no cards played?), we should clear selection visually.
                            document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
                            document.getElementById('btn-confirm-selection').classList.add('hidden');
                        }

                        gameState = data.state;
                        updateTableUI();
                        if (data.timeLeft !== undefined) updateTimerUI(data.timeLeft);
                        break;
                    case 'PLAYER_UPDATE':
                        // HOST PROTECTION: Host is the source of truth. 
                        // Never overwrite master list with networked (potentially sanitized) copies.
                        if (!isHost) {
                            players = data.players;
                            if (gameState) gameState.players = data.players;
                            updateTableUI();
                        }
                        break;
                    case 'GAME_OVER':
                        // Client receives end game
                        // Ensure we have final stats
                        if (data.players) {
                            players = data.players;
                        }
                        showGameOverScreen(data.winner, data.duration);
                        break;
                    case 'SUBMIT_CARDS': // Host receives
                        if (isHost) handleSubmission(senderId, data.cards);
                        break;
                    case 'SELECT_WINNER': // Host receives from Czar
                        if (isHost && gameState.phase === 'JUDGING' && senderId === gameState.czarId) {
                            hostSelectWinner(data.submissionIndex);
                        }
                        break;
                    case 'REQUEST_SWAP':
                        if (isHost) processSwap(senderId, data.cards);
                        break;
                    case 'SUBMIT_VOTE':
                        if (isHost) handleVote(senderId, data.submissionIndex);
                        break;
                    case 'SWAP_SUCCESS':
                        // Reset my UI
                        hasSwappedThisRound = true;
                        resetSwapUI(false);
                        break;
                    case 'TIME_TICK':
                        updateTimerUI(data.timeLeft);
                        break;
                    case 'SAVE_CARD_TO_HOST':
                        if (isHost) {
                            const cType = data.cardType;
                            const cData = data.cardData; // { text:..., id:... }

                            // Initialize storage for this player if needed
                            if (!serverPlayerCards[senderId]) {
                                serverPlayerCards[senderId] = { white: [], black: [] };
                            }

                            // Save
                            serverPlayerCards[senderId][cType].push(cData);
                            console.log(`Host saved ${cType} card from ${senderId} into isolated storage.`);

                            // Visual Feedback (optional, maybe a small dot on "Menu" or nothing)
                            // User wanted distinct separation, so we do NOT add to myCreatedCards.
                        }
                        break;
                    case 'REQUEST_EXPORT':
                        if (isHost) {
                            const reqType = data.cardType;
                            console.log(`Export requested for ${reqType} by ${senderId}`);

                            // Aggregate ALL
                            const exportSource = [];

                            // 1. Host's
                            myCreatedCards[reqType].forEach(c => exportSource.push(c));

                            // 2. Clients'
                            Object.values(serverPlayerCards).forEach(pc => {
                                if (pc[reqType]) {
                                    pc[reqType].forEach(c => exportSource.push(c));
                                }
                            });

                            // Send back
                            const cleaned = exportSource.map(c => {
                                if (reqType === 'black') {
                                    return { text: c.text, blanks: (c.blanks || 1) };
                                } else {
                                    return { text: c.text };
                                }
                            });

                            const exportPayload = {
                                type: (reqType === 'black' ? 'N' : 'B'),
                                cards: cleaned
                            };

                            const conn = connections[senderId];
                            if (conn && conn.open) {
                                conn.send({ type: 'EXPORT_DATA', payload: exportPayload, finalType: reqType });
                            }
                        }
                        break;
                    case 'EXPORT_DATA':
                        // Trigger Download
                        const pData = data.payload;
                        const jsonStr = JSON.stringify(pData, null, 2);
                        const blob = new Blob([jsonStr], { type: "application/json" });
                        const url = URL.createObjectURL(blob);

                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `SALA_EXPORT_${data.finalType}_${Date.now()}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        break;
                }
            } catch (e) {
                console.error("Error inside handleData switch:", e);
            }
        }

        /* --- UI HELPERS --- */
        function showScreen(id) {
            console.log("Switching to screen:", id);
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            const screen = document.getElementById(id);
            if (screen) screen.classList.remove('hidden');
            else console.error("Screen not found:", id);
        }

        function updateLobbyUI() {
            const list = document.getElementById('lobby-list');
            list.innerHTML = players.map(p => `<li>${p.name} <span>${p.score} pts</span></li>`).join('');
        }

        function startGameUI() {
            console.log("startGameUI called");
            gameStartTime = Date.now(); // Track start time
            showScreen('screen-game');
            updateTableUI();
        }

        function updateHandUI(hand) {
            const area = document.getElementById('hand-area');
            area.innerHTML = '';
            hand.forEach((text, i) => {
                const c = createCard('white', text);
                c.onclick = () => toggleSelectCard(c, text);
                area.appendChild(c);
            });
        }

        let selectedCards = []; // Local selection
        function toggleSelectCard(cardElem, text) {
            // Special mode: SWAPPING
            if (isSwapping) {
                // UI Block check: If waiting for server?
                // Visual feedback only. 

                if (cardElem.classList.contains('selected')) {
                    cardElem.classList.remove('selected');
                    selectedCards = selectedCards.filter(t => t !== text);
                } else {
                    if (selectedCards.length < 2) {
                        cardElem.classList.add('selected');
                        selectedCards.push(text);
                    } else {
                        alert("Solo puedes cambiar 2 cartas.");
                    }
                }

                // Show confirm swap button
                const btn = document.getElementById('btn-confirm-selection');
                if (selectedCards.length === 2) {
                    btn.innerText = "CONFIRMAR CAMBIO";
                    btn.classList.remove('hidden');
                    btn.style.background = '#e11d48';
                    btn.onclick = () => {
                        if (confirm("¬øCambiar estas 2 cartas? perder√°s tu turno de cambio esta ronda.")) {
                            handleSwapRequest(selectedCards);
                        }
                    };
                } else {
                    btn.classList.add('hidden');
                }
                return;
            }

            // Normal Play Mode
            if (gameState.phase !== 'SELECTION') return;
            if (gameState.czarId === myId) return alert("Eres el Czar, no juegas cartas, solo juzgas.");

            const required = gameState.blackCard.blanks || 1;

            if (cardElem.classList.contains('selected')) {
                cardElem.classList.remove('selected');
                selectedCards = selectedCards.filter(t => t !== text);
            } else {
                if (selectedCards.length < required) {
                    cardElem.classList.add('selected');
                    selectedCards.push(text);
                } else {
                    // Replace first? or strict limit?
                    // Let's strict limit, user must deselect
                    alert(`Solo elige ${required} carta(s).`);
                }
            }

            // Show confirm button if full
            const btn = document.getElementById('btn-confirm-selection');
            if (selectedCards.length === required) {
                btn.innerText = "CONFIRMAR SELECCI√ìN";
                btn.style.background = '#2563eb';
                btn.classList.remove('hidden');
                btn.onclick = () => submitSelection();
            } else {
                btn.classList.add('hidden');
            }
        }

        function submitSelection() {
            if (isHost) handleSubmission(myId, selectedCards); // Host local play
            else hostConn.send({ type: 'SUBMIT_CARDS', cards: selectedCards });

            // Clear local selection UI
            selectedCards = [];
            document.getElementById('btn-confirm-selection').classList.add('hidden');

            // Only hide hand for clients who are waiting for network response
            if (!isHost) {
                document.getElementById('hand-area').innerHTML = '<h3 style="margin:auto; color:#666;">Cartas Enviadas. Esperando...</h3>';
            }
        }

        // Memoized star delays
        let starDelayCache = { round: -1, phase: '', voteCount: -1, map: new Map() };

        function getStarDelays() {
            // Cache invalidation conditions
            const currentVoteCount = countTotalVotes();
            if (starDelayCache.round === gameState.round &&
                starDelayCache.phase === gameState.phase &&
                starDelayCache.voteCount === currentVoteCount) {
                return starDelayCache.map;
            }

            // Compute
            const delayMap = new Map();

            // Find max depth (max number of votes any card has)
            let maxDepth = 0;
            if (gameState.submissions) {
                gameState.submissions.forEach(sub => {
                    if (sub.votes && sub.votes.length > maxDepth) maxDepth = sub.votes.length;
                });
            }

            // Assign delays based on Waves
            // Wave N: All stars at index N appear together.
            // Self-votes appear AFTER all possible normal waves.
            const waveDuration = 0.6; // Seconds between waves
            const selfVoteOffset = (maxDepth * waveDuration) + 0.5;

            if (gameState.submissions) {
                gameState.submissions.forEach((sub, sIdx) => {
                    if (sub.votes) {
                        // We want self votes to be visually last? 
                        // The DOM order is determined by sub.votes array order.
                        // But we can just delay the animation heavily.

                        let selfCountInThisCard = 0;

                        sub.votes.forEach((vId, vIdx) => {
                            const isSelf = (vId === sub.playerId);
                            let delay = 0;

                            if (!isSelf) {
                                // Wave based on index
                                delay = vIdx * waveDuration;
                                // Add slight organic jitter
                                delay += (Math.random() * 0.2);
                            } else {
                                // Self vote: Push to end
                                delay = selfVoteOffset + (selfCountInThisCard * 0.5);
                                selfCountInThisCard++;
                            }

                            delayMap.set(`${sIdx}-${vIdx}`, delay);
                        });
                    }
                });
            }

            starDelayCache = {
                round: gameState.round,
                phase: gameState.phase,
                voteCount: currentVoteCount,
                map: delayMap
            };
            return delayMap;
        }

        function countTotalVotes() {
            let c = 0;
            if (gameState.submissions) gameState.submissions.forEach(s => { if (s.votes) c += s.votes.length; });
            return c;
        }

        function createCard(type, text) {
            const div = document.createElement('div');
            div.className = `card ${type} deal-anim`;
            // Wrap text in container
            const textHTML = text.replace(/_+/g, '_______');
            div.innerHTML = `<div class="card-text-content">${textHTML}</div><div class="card-logo">Cartas Contra la Humanidad</div>`;
            return div;
        }

        function updateTableUI() {
            // Update Player List
            const listContainer = document.getElementById('ingame-player-list');
            if (listContainer && gameState.players) {
                listContainer.innerHTML = gameState.players.map(p => {
                    const isCzar = (p.id === gameState.czarId);
                    const swapped = p.hasSwapped ? '<span style="color:#e11d48; margin-left:5px;">(Cambi√≥)</span>' : '';

                    // Check if they submitted
                    const hasSubmitted = gameState.submissions && gameState.submissions.some(s => s.playerId === p.id);
                    const ready = (hasSubmitted && !isCzar) ? '<span style="color:#10b981; margin-left:5px;">(Listo)</span>' : '';

                    const isMe = (p.id === myId) ? ' (T√∫)' : '';
                    return `<div style="margin-bottom:5px; background: rgba(255,255,255,0.8); padding: 4px 10px; border-radius: 15px; font-size: 0.85rem; display:inline-block;">
                        ${isCzar ? 'üëë ' : ''}<strong>${p.name}</strong>${isMe}: ${p.score} pts ${swapped} ${ready}
                    </div><br>`;
                }).join('');
            }
            // Update Czar Info
            if (gameMode === 'DEMOC') {
                document.getElementById('czar-name').innerText = "Todos";
            } else {
                const czarPlayer = gameState.players.find(p => p.id === gameState.czarId);
                document.getElementById('czar-name').innerText = czarPlayer ? czarPlayer.name : "???";
            }

            // Update My Score
            const me = gameState.players.find(p => p.id === myId);
            if (me) document.getElementById('my-score').innerText = me.score;

            // Status Msg
            const status = document.getElementById('status-display');
            if (gameState.phase === 'SELECTION') {
                if (gameMode === 'DEMOC') {
                    status.innerText = "¬°DEMOCRACIA! Elige tus cartas m√°s graciosas.";
                } else {
                    status.innerText = (gameState.czarId === myId) ? "Eres el JUEZ. Espera a que los plebeyos elijan." : "Elige tus cartas m√°s graciosas.";
                }
                // Show Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'block';

                // Hand Title Hint
                const hTitle = document.getElementById('hand-title');
                if (hTitle) {
                    if (gameState.czarId === myId) {
                        hTitle.innerText = "Tu Mano (Esperando a que elijan...)";
                    } else {
                        const count = (gameState.blackCard && gameState.blackCard.blanks) ? gameState.blackCard.blanks : 1;
                        hTitle.innerText = `Tu Mano (Elige ${count} de cartas)`;
                    }
                }
            } else if (gameState.phase === 'JUDGING') {
                status.innerText = (gameState.czarId === myId) ? "¬°JUZGA! Elige la ganadora." : "El Juez est√° eligiendo...";
                // Hide Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'none';
            } else if (gameState.phase === 'SCORE') {
                status.innerText = `¬°${gameState.winnerName} gana la ronda!`;
                // Hide Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'none';
            } else if (gameState.phase === 'VOTING') {
                status.innerText = "¬°DEMOCRACIA! Vota por la mejor carta.";
                // Hide Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'none';
            }

            // Black Card
            const bcSpot = document.getElementById('black-card-spot');
            bcSpot.innerHTML = '';
            if (gameState.blackCard) bcSpot.appendChild(createCard('black', gameState.blackCard.text));

            // Played Cards
            const pcArea = document.getElementById('played-cards-area');
            pcArea.innerHTML = '';

            if (gameState.phase === 'SELECTION') {
                // Show face down cards for each submission
                gameState.submissions.forEach(sub => {
                    // Create dummy back cards
                    const group = document.createElement('div');
                    group.style.display = 'flex';
                    group.style.gap = '5px';
                    // We don't know how many cards if masked? Well, blackCard.blanks
                    const count = gameState.blackCard.blanks || 1;
                    for (let i = 0; i < count; i++) {
                        const c = createCard('white', 'Cartas Contra la Humanidad');
                        c.style.background = '#1a1a1a'; // Dark back
                        c.style.color = 'white';
                        c.innerHTML = '<div style="font-size:2rem; margin:auto;">?</div>';
                        group.appendChild(c);
                    }
                    pcArea.appendChild(group);
                });
            } else if (gameState.phase === 'JUDGING' || gameState.phase === 'SCORE' || gameState.phase === 'VOTING') {
                // Show real cards
                gameState.submissions.forEach((sub, idx) => {
                    const group = document.createElement('div');
                    group.style.display = 'flex';
                    group.style.gap = '5px';

                    // Add shuffle animation if entering Judging/Voting
                    if (gameState.phase === 'JUDGING' || gameState.phase === 'VOTING') {
                        group.style.animation = 'shuffleDeal 0.6s ease-out backwards';
                        group.style.animationDelay = (idx * 0.15) + 's';
                    }

                    // If SCORING, highlight winner AFTER stars
                    if (gameState.phase === 'SCORE' && idx === gameState.winningSubmissionIndex) {
                        group.style.border = '2px solid transparent'; // Start invisible
                        group.style.borderRadius = '10px';
                        group.style.padding = '5px';
                        group.style.background = 'transparent'; // Start invisible

                        // Calculate delay based on total votes
                        // We know delay is index * 0.5s. 
                        const totalVotes = countTotalVotes();
                        const delaySeconds = (totalVotes * 0.5) + 0.5; // Wait for all stars + 0.5s buffer

                        group.style.animation = `winnerGlow 0.8s ease-out forwards ${delaySeconds}s`;
                    }

                    // VOTING: Highlight my choice in blue
                    if (gameState.phase === 'VOTING' && idx === myVotedIndex) {
                        group.style.border = '3px solid #3b82f6';
                        group.style.borderRadius = '10px';
                        group.style.padding = '5px';
                        group.style.boxShadow = '0 0 10px rgba(59, 130, 246, 0.5)';
                    }

                    // Create a wrapper for cards to separate them from stars
                    const cardWrapper = document.createElement('div');
                    cardWrapper.style.display = 'flex';
                    cardWrapper.style.gap = '5px';
                    group.style.flexDirection = 'column'; // Allow stars below
                    group.style.alignItems = 'center';
                    group.appendChild(cardWrapper);

                    sub.cards.forEach(text => {
                        const c = createCard('white', text);
                        // If I am Czar and Judging, allow click
                        if (gameState.phase === 'JUDGING' && myId === gameState.czarId) {
                            c.style.cursor = 'pointer';
                            // Add hover effect
                            c.onmouseenter = () => c.style.transform = 'scale(1.05)';
                            c.onmouseleave = () => c.style.transform = 'scale(1)';

                            c.onclick = () => {
                                if (confirm("¬øElegir esta como ganadora?")) {
                                    if (isHost) {
                                        hostSelectWinner(idx);
                                    } else {
                                        hostConn.send({ type: 'SELECT_WINNER', submissionIndex: idx });
                                    }
                                }
                            };
                        }

                        // VOTING Phase Logic
                        if (gameState.phase === 'VOTING') {
                            // Enable click ONLY if I haven't voted yet
                            if (myVotedIndex === -1) {
                                c.style.cursor = 'pointer';
                                c.onmouseenter = () => c.style.transform = 'scale(1.05)';
                                c.onmouseleave = () => c.style.transform = 'scale(1)';

                                c.onclick = () => {
                                    const isMyCard = (myId === sub.playerId);
                                    const warning = isMyCard
                                        ? "¬øVotar por ti mismo? (No contara el voto, y si lo haces mucho te restar√° puntos)"
                                        : "¬øVotar por esta carta? No podr√°s cambiar tu voto.";
                                    if (confirm(warning)) {
                                        myVotedIndex = idx; // Lock locally
                                        updateTableUI(); // Re-render to show blue

                                        // Send vote
                                        if (isHost) handleVote(myId, idx);
                                        else hostConn.send({ type: 'SUBMIT_VOTE', submissionIndex: idx });
                                    }
                                };
                            } else {
                                // Disabled state
                                c.style.opacity = '0.9';
                                c.style.cursor = 'default';
                            }
                        }

                        cardWrapper.appendChild(c);
                    });

                    // Append Stars if applicable
                    if ((gameState.phase === 'SCORE' || gameState.phase === 'JUDGING') && sub.votes && sub.votes.length > 0) {
                        const starDelays = getStarDelays();
                        const starRow = document.createElement('div');
                        starRow.className = 'star-container';
                        sub.votes.forEach((vId, vIdx) => {
                            const s = document.createElement('span');
                            const isSelf = (vId === sub.playerId);
                            let starClass = 'star-gold';

                            if (isSelf) {
                                starClass = 'star-grey';
                                const voter = players.find(p => p.id === vId);
                                if (voter && (voter.selfVoteCount || 0) >= 3) {
                                    starClass = 'star-black';
                                }
                            }

                            s.className = `star-icon ${starClass}`;
                            s.innerHTML = '‚òÖ';

                            // Use calculated global delay
                            const dVal = starDelays ? starDelays.get(`${idx}-${vIdx}`) : undefined;
                            const delay = (dVal !== undefined) ? dVal : (vIdx * 0.2);
                            s.style.animationDelay = delay + 's';

                            starRow.appendChild(s);
                        });
                        group.appendChild(starRow);
                    }

                    pcArea.appendChild(group);
                });
            }
        }
        function updateTimerUI(seconds) {
            const el = document.getElementById('game-timer');
            if (seconds === -1 || seconds === undefined) el.innerText = "";
            else el.innerText = "‚è±Ô∏è " + seconds + "s";

            if (seconds <= 10) el.style.color = 'red';
            else el.style.color = '#e11d48';
        }
    </script>

    <!-- GAME OVER SCREEN -->
    <div id="screen-game-over" class="screen hidden"
        style="background: linear-gradient(135deg, #111, #222); color:white; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;">

        <h1
            style="font-size: 3rem; margin-bottom: 10px; color: #fbbf24; text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);">
            üèÜ ¬°VICTORIA! üèÜ
        </h1>

        <h2 id="go-winner-name" style="font-size: 2.5rem; margin: 20px 0; font-weight: 900;">NOMBRE GAN√ì</h2>

        <div id="go-stats"
            style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 30px; min-width: 300px;">
            <!-- Stats inserted by JS -->
        </div>

        <div style="display:flex; gap:20px; flex-direction: column;">
            <button onclick="location.reload()" class="btn"
                style="background: #2563eb; width: 250px; font-size: 1.1rem; padding: 15px;">
                üîÑ Volver al Lobby
            </button>
            <button onclick="window.location.href='https://omarsaez.github.io/ArcadeDeJuegos/'" class="btn secondary"
                style="width: 250px; font-size: 1.1rem; padding: 15px; border: 2px solid #666;">
                üïπÔ∏è Volver al Arcade
            </button>
        </div>
    </div>
</body>

</html>