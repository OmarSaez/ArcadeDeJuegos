<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cartas Contra la Humanidad</title>
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        :root {
            --bg-color: #f5f5f5;
            --text-color: #1a1a1a;
            --card-white: #ffffff;
            --card-black: #1a1a1a;
            --accent: #2c3e50;
            --border-radius: 12px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        body {
            font-family: 'Inter', Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- SCREEN MANAGEMENT --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-color);
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-weight: 900;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-align: center;
            letter-spacing: -2px;
        }

        /* --- UI ELEMENTS --- */
        .btn {
            background: var(--card-black);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            width: 250px;
            margin: 10px;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            background: #000;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.secondary {
            background: white;
            color: black;
            border: 2px solid black;
        }

        input {
            padding: 15px;
            font-size: 1.1rem;
            border: 2px solid #ccc;
            border-radius: 8px;
            width: 250px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
        }

        /* --- CARDS --- */
        .card {
            width: 180px;
            height: 250px;
            border-radius: var(--border-radius);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            /* Push logo to bottom */
            font-weight: 700;
            font-size: 0.9rem;
            line-height: 1.3;
            position: relative;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, z-index 0.2s;
            cursor: pointer;
            margin: 5px;
            flex-shrink: 0;
            overflow: hidden;
            /* Clip overflow */
            white-space: normal;
        }

        .card-text-content {
            flex: 1;
            overflow-y: auto;
            /* Scroll if absolutely necessary */
            margin-bottom: 20px;
            /* Space above logo */
            /* Hide scrollbar visually but keep functionality */
            scrollbar-width: thin;
        }

        .card.black {
            background: var(--card-black);
            color: white;
        }

        .card.white {
            background: var(--card-white);
            color: black;
            border: 1px solid #e5e5e5;
        }

        .card.white:hover {
            transform: translateY(-20px) rotate(2deg);
            z-index: 100;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .card.selected {
            border: 4px solid #3b82f6;
            transform: translateY(-30px);
        }

        .card-logo {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 0.7rem;
            font-weight: 900;
            opacity: 0.8;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .card-logo::before {
            content: '‚ñ´';
            /* Placeholder icon */
            font-size: 1.2rem;
        }

        .card.black .card-logo::before {
            content: '‚óº';
        }

        /* --- GAME LAYOUT --- */
        #game-layout {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background: #d1d5db;
        }

        #table-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        #black-card-spot {
            margin-bottom: 20px;
        }

        #played-cards-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            min-height: 260px;
            /* Space for cards */
        }

        #hand-area {
            height: 300px;
            background: #f3f4f6;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 10px 20px;
            overflow-x: auto;
            border-top: 1px solid #e5e5e5;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* --- INFO BAR --- */
        #info-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            box-shadow: var(--shadow);
            z-index: 50;
        }

        #czar-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #1a1a1a;
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            box-shadow: var(--shadow);
        }

        /* --- LOBBY LIST --- */
        #lobby-list {
            list-style: none;
            padding: 0;
            width: 300px;
            margin-bottom: 20px;
        }

        /* --- STARS --- */
        .star-container {
            display: flex;
            justify-content: center;
            margin-top: 5px;
            flex-wrap: wrap;
            gap: 2px;
        }

        .star-icon {
            font-size: 1.2rem;
            display: inline-block;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;
            margin-right: 2px;
            transform: scale(0);
            /* Start Invisible */
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .star-gold {
            color: #fbbf24;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }

        .star-grey {
            color: #9ca3af;
        }

        .star-black {
            color: #1f2937;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
        }

        @keyframes winnerGlow {
            0% {
                border-color: transparent;
                background-color: transparent;
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                border-color: gold;
                background-color: rgba(255, 215, 0, 0.2);
                transform: scale(1);
            }
        }

        .star-black {
            color: #1f2937;
            text-shadow: 0 0 1px rgba(255, 255, 255, 0.5);
        }

        color: #9ca3af;
        }

        @keyframes popIn {
            from {
                transform: scale(0);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        #lobby-list li {
            background: white;
            padding: 10px 15px;
            margin-bottom: 5px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* --- ANIMATIONS --- */
        @keyframes deal {
            from {
                opacity: 0;
                transform: translateY(100px) scale(0.5);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .deal-anim {
            animation: deal 0.4s ease-out forwards;
        }

        @keyframes shuffleDeal {
            from {
                opacity: 0;
                transform: translateY(-50px) translateX(-50%) rotate(-15deg) scale(0.5);
            }

            to {
                opacity: 1;
                transform: translateY(0) translateX(0) rotate(0) scale(1);
            }
        }

        .status-msg {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* --- MOBILE --- */
        @media (max-width: 600px) {
            .card {
                width: 140px;
                height: 200px;
                font-size: 0.8rem;
            }

            #hand-area {
                height: 240px;
            }

            h1 {
                font-size: 1.8rem;
            }

            #ingame-player-list {
                top: auto;
                bottom: 270px;
                /* Above hand area */
                right: 10px;
                font-size: 0.75rem;
                text-align: right;
            }
        }
    </style>
</head>

<body>

    <!-- SCREEN 1: MENU -->
    <div id="screen-menu" class="screen">
        <h1>CARTAS CONTRA LA<br>HUMANIDAD</h1>
        <input type="text" id="nickname" placeholder="Tu Apodo (Ej: El Bromas)" maxlength="12">
        <button class="btn" onclick="createRoom()">Crear Partida</button>
        <div style="display:flex; gap:10px;">
            <input type="text" id="room-code-input" placeholder="C√ìDIGO" style="width:120px; margin-bottom:10px;">
            <button class="btn secondary" style="width:120px;" onclick="joinRoom()">Unirse</button>
        </div>
        <button class="btn secondary" onclick="window.location.href='../../index.html'"
            style="margin-top:20px; background:transparent; color:#666; width:auto; font-size:0.9rem;">Volver al
            Arcade</button>
    </div>

    <!-- SCREEN 2: LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <h2>SALA: <span id="lobby-code"
                style="font-family:monospace; background:#e5e5e5; padding:2px 8px; border-radius:4px;">CODE</span></h2>
        <ul id="lobby-list"></ul>
        <div id="host-controls" class="hidden" style="width: 100%; max-width: 300px;">
            <div
                style="background: white; padding: 6px 10px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                <label style="color:#666; font-size:0.8rem; font-weight:bold; display:block; margin-bottom: 2px;">PUNTOS
                    PARA GANAR</label>
                <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changePoints(-1)">-</button>
                    <span id="points-display-host"
                        style="font-size: 1.2rem; font-weight: bold; min-width: 20px;">3</span>
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changePoints(1)">+</button>
                </div>
            </div>

            <div
                style="background: white; padding: 6px 10px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                <label style="color:#666; font-size:0.8rem; font-weight:bold; display:block; margin-bottom: 2px;">MODO
                    DE JUEGO</label>
                <div style="display: flex; justify-content: center; gap: 5px;">
                    <button id="btn-mode-judge" class="btn" style="flex:1; font-size:0.75rem; padding: 5px;"
                        onclick="changeGameMode('JUDGE')">Juez</button>
                    <button id="btn-mode-demo" class="btn secondary" style="flex:1; font-size:0.75rem; padding: 5px;"
                        onclick="changeGameMode('DEMOC')">Democracia</button>
                </div>
            </div>

            <div
                style="background: white; padding: 6px 10px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                <label style="color:#666; font-size:0.8rem; font-weight:bold; display:block; margin-bottom: 2px;">TIEMPO
                    POR RONDA</label>
                <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changeTimer(-10)">-</button>
                    <span id="timer-display-host"
                        style="font-size: 1.2rem; font-weight: bold; min-width: 60px;">40s</span>
                    <button class="btn secondary" style="width: 30px; height: 30px; padding:0; font-size:1rem;"
                        onclick="changeTimer(10)">+</button>
                </div>
                <button id="btn-timer-toggle" class="btn secondary"
                    style="width:100%; margin-top:5px; font-size:0.8rem; padding: 2px;" onclick="toggleTimerLimit()">Sin
                    L√≠mite</button>
            </div> <!-- Close Timer Panel -->

            <p style="color:#666; font-size:0.9rem;">Se recomiendan 3+ jugadores</p>
            <button class="btn" onclick="startGame()">Comenzar Juego</button>
        </div> <!-- Close Host Controls -->

        <div id="client-settings-view" class="hidden" style="margin-bottom: 20px;">
            <p style="color:#666; font-weight:bold;">Puntos para ganar: <span id="points-display-client"
                    style="font-size:1.2rem; color:black;">3</span></p>
            <p style="color:#666; font-weight:bold;">Modo: <span id="mode-display-client"
                    style="font-size:1.2rem; color:black;">Juez Cl√°sico</span></p>
            <p style="color:#666; font-weight:bold;">Tiempo: <span id="timer-setting-client"
                    style="font-size:1.2rem; color:black;">40s</span></p>
        </div>
        <p id="wait-msg">Esperando al anfitri√≥n...</p>

        <!-- Help Button -->
        <button onclick="document.getElementById('help-modal').classList.remove('hidden')"
            style="position: absolute; bottom: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background: #2c3e50; color: white; font-size: 1.5rem; font-weight: bold; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 50; display: flex; align-items: center; justify-content: center;">
            ?
        </button>

        <!-- Help Modal -->
        <div id="help-modal" class="hidden"
            style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(2px);">
            <div
                style="background: white; padding: 25px; border-radius: 12px; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; position: relative; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);">
                <button onclick="document.getElementById('help-modal').classList.add('hidden')"
                    style="position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>

                <h2 style="margin-top: 0; color: #2c3e50; text-align: center;">C√≥mo Jugar</h2>

                <div style="margin-bottom: 20px;">
                    <h3 style="color: #2563eb; margin-bottom: 5px;">üßë‚Äç‚öñÔ∏è Modo Juez</h3>
                    <p style="font-size: 0.9rem; color: #4b5563; margin: 0;">En este modo, un solo jugador act√∫a como
                        <strong>juez</strong>.
                    </p>
                    <ul style="font-size: 0.9rem; color: #4b5563; padding-left: 20px; margin-top: 5px;">
                        <li>El juez elige la carta ganadora de la ronda.</li>
                        <li>Durante su turno, el juez no juega cartas.</li>
                    </ul>
                </div>

                <div style="margin-bottom: 20px;">
                    <h3 style="color: #e11d48; margin-bottom: 5px;">üó≥Ô∏è Modo Democracia</h3>
                    <p style="font-size: 0.9rem; color: #4b5563; margin: 0;">Todos los jugadores juegan una carta.</p>
                    <ul style="font-size: 0.9rem; color: #4b5563; padding-left: 20px; margin-top: 5px;">
                        <li>Luego, todos votan por la carta que les parezca m√°s graciosa.</li>
                        <li>La carta con m√°s votos gana la ronda.</li>
                    </ul>
                </div>

                <div>
                    <h3 style="color: #d97706; margin-bottom: 5px;">‚≠ê Sistema de estrellas</h3>
                    <ul style="list-style: none; padding: 0; font-size: 0.9rem; color: #4b5563;">
                        <li style="margin-bottom: 8px; display: flex; align-items: center;">
                            <span class="star-icon star-gold" style="transform: scale(1); margin-right: 8px;">‚òÖ</span>
                            <span>Estrella amarilla: voto normal.</span>
                        </li>
                        <li style="margin-bottom: 8px; display: flex; align-items: center;">
                            <span class="star-icon star-grey" style="transform: scale(1); margin-right: 8px;">‚òÖ</span>
                            <span>Estrella gris: Alguien se auto-voto (due√±o) y el voto no cuenta para la votaci√≥n
                                final.</span>
                        </li>
                        <li style="margin-bottom: 8px; display: flex; align-items: start;">
                            <span class="star-icon star-black"
                                style="transform: scale(1); margin-right: 8px; margin-top: 2px;">‚òÖ</span>
                            <span>
                                <strong>Estrella negra (Penalizaci√≥n):</strong><br>
                                Si votas por ti mismo m√°s de 2 veces, pierdes 1 punto y el voto no cuenta para la
                                votaci√≥n final.
                            </span>
                        </li>
                    </ul>
                </div>

                <button onclick="document.getElementById('help-modal').classList.add('hidden')" class="btn"
                    style="width: 100%; margin: 20px 0 0 0; padding: 10px;">Entendido</button>
            </div>
        </div>
    </div> <!-- Close Screen Lobby -->

    <!-- SCREEN 3: GAME -->
    <div id="screen-game" class="screen hidden"
        style="background: #e5e5e5; display: flex; flex-direction: column; overflow: hidden;">
        <!-- Unified Game Header -->
        <div id="unified-game-header"
            style="flex: 0 0 auto; width: 100%; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 20; box-sizing: border-box;">
            <!-- Top Row: Stats -->
            <div
                style="display: flex; justify-content: space-between; align-items: center; padding: 8px 15px; border-bottom: 1px solid #f0f0f0;">
                <div
                    style="flex: 1; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem;">
                    <strong>T√∫:</strong> <span id="my-score" style="font-weight:bold; color:#2563eb;">0</span>
                </div>
                <div style="font-weight:bold; color:#e11d48; min-width: 50px; text-align:center; font-size: 1rem;">
                    <span id="game-timer">--</span>
                </div>
                <div
                    style="flex: 1; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem;">
                    <strong>Juez:</strong> <span id="czar-name" style="font-weight:bold;">...</span>
                </div>
            </div>
            <!-- Bottom Row: Status -->
            <div id="status-display"
                style="text-align: center; padding: 8px 10px; font-size: 0.95rem; color: #1f2937; font-weight: 600; background: #fdfdfd; width: 100%; box-sizing: border-box;">
                Estado...
            </div>
        </div>

        <!-- Player List (Floating but smaller) -->
        <div id="ingame-player-list"
            style="position: absolute; top: 100px; right: 10px; text-align: right; pointer-events: none; z-index: 15; opacity: 0.8; transform: scale(0.8); transform-origin: top right;">
        </div>

        <!-- SCROLLABLE CONTENT AREA -->
        <!-- SCROLLABLE CONTENT AREA -->
        <div
            style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 10px; padding-top: 20px; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 100%; box-sizing: border-box;">

            <!-- 1. BLACK CARD (Always Top) -->
            <div id="black-card-spot" style="margin-bottom: 15px; flex: 0 0 auto;"></div>

            <!-- 2. MY HAND & CONTROLS (Priority View) -->
            <!-- Wrapped in container to toggle visibility easily -->
            <div id="hand-container"
                style="width: 100%; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center;">
                <h3 id="hand-title" style="color:#666; font-size:0.9rem; margin-bottom:5px;">Tu Mano</h3>
                <div id="hand-scroll-area"
                    style="width: 100%; overflow-x: auto; padding: 5px; border-radius: 8px; background: rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.05); white-space: nowrap; box-sizing: border-box;">
                    <div id="hand-area" style="display: flex; gap: 8px; padding-bottom: 5px;">
                        <!-- Cards injected here -->
                    </div>
                </div>

                <!-- Helper Buttons -->
                <div id="player-controls"
                    style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <button id="btn-confirm-selection" class="btn hidden" onclick="submitSelection()"
                        style="background:#2563eb; width: auto; padding: 8px 20px;">CONFIRMAR SELECCI√ìN</button>

                    <!-- Swap UI -->
                    <button id="btn-swap-cards" class="btn secondary" onclick="enableSwapMode()"
                        style="width: auto; font-size: 0.8rem;">Cambiar 2 Cartas</button>
                    <button id="btn-cancel-swap" class="btn hidden" onclick="resetSwapUI(false)"
                        style="background:#ef4444; width: auto;">Cancelar</button>
                    <!-- Fixed ID below -->
                </div>
                <button id="btn-confirm-swap" class="btn hidden" onclick="submitSwap()"
                    style="background:#e11d48; margin-top:5px; width:auto;">CONFIRMAR CAMBIO</button>
                <p id="swap-msg" class="hidden"
                    style="color:#e11d48; font-weight:bold; font-size:0.9rem; margin-top:5px;">Selecciona 2 cartas...
                </p>
            </div>

            <!-- 3. PLAYED CARDS (Bottom) -->
            <div
                style="width: 100%; border-top: 1px solid #ddd; margin-top: 10px; padding-top: 10px; text-align: center;">
                <h3 style="color:#666; font-size:1rem; margin-bottom:10px;">Cartas en la Mesa</h3>
                <div id="played-cards-area"
                    style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; width: 100%;">
                    <!-- Submitted/Played cards go here -->
                </div>
            </div>

            <br><br>
        </div>
    </div>

    <script src="cards.js"></script>
    <script>
        /* --- GAME DATA --- */
        let whiteCards = [];
        let blackCards = [];

        function loadCards() {
            try {
                if (typeof CAH_WHITE !== 'undefined' && typeof CAH_BLACK !== 'undefined') {
                    whiteCards = [...CAH_WHITE];
                    blackCards = [...CAH_BLACK];
                    console.log(`Cargadas ${whiteCards.length} blancas y ${blackCards.length} negras.`);
                } else {
                    throw new Error("Variables CAH_WHITE/CAH_BLACK no definidas");
                }
            } catch (e) {
                console.error(e);
                alert("Error cargando cartas: Verifique cards.js");
            }
        }
        loadCards();

        /* --- STATE --- */
        let peer, myId, myName;
        let myHand = []; // Local source of truth for UI
        let isHost = false;
        let hostConn = null;
        let connections = {};
        let players = []; // {id, name, score, hand: []}
        let pointsToWin = 3;
        let gameMode = 'JUDGE'; // 'JUDGE' or 'DEMOC'
        let timerSetting = 40; // Seconds, -1 for infinite
        let currentTimer = 0;
        let timerInterval = null;

        let gameState = {
            phase: 'LOBBY', // LOBBY, SELECTION, JUDGING, SCORE, VOTING
            gameMode: 'JUDGE',
            czarIndex: 0,
            blackCard: null,
            submissions: [], // {playerId, cards: [], votes: []}
            round: 0
        };

        /* --- NETWORK (Standard Arcade P2P) --- */
        let pendingJoinCode = null;

        function initPeer(customId = null) {
            // 1. Create Peer
            if (customId) {
                peer = new Peer(customId);
            } else {
                peer = new Peer(); // Auto ID for client
            }

            // 2. Event Listeners
            peer.on('open', (id) => {
                console.log('My Peer ID:', id);
                myId = id;

                // HOST LOGIC
                if (isHost) {
                    // Update my own ID in player list
                    if (players.length > 0) {
                        players[0].id = id;
                        updateLobbyUI();
                    }
                }
                // CLIENT LOGIC
                else {
                    if (pendingJoinCode) {
                        connectToHost(pendingJoinCode);
                    }
                }
            });

            peer.on('connection', (conn) => {
                // Incoming connection (Host logic mostly)
                handleConnection(conn);
            });

            peer.on('error', (err) => {
                console.error("P2P Error:", err);
                if (err.type === 'peer-unavailable') {
                    alert("No se encontr√≥ la sala. Verifica el c√≥digo.");
                    showScreen('screen-menu');
                } else if (err.type === 'unavailable-id') {
                    alert("El c√≥digo de sala ya est√° en uso. Intenta otro.");
                    showScreen('screen-menu');
                } else {
                    console.log("Error no critico:", err);
                }
            });
        }

        function handleConnection(conn) {
            // Check if already connected
            if (connections[conn.peer]) return;

            // Handle Open
            conn.on('open', () => {
                console.log("Conexi√≥n establecida con:", conn.peer);
                connections[conn.peer] = conn;

                if (isHost) {
                    // Host sends state to new player
                    conn.send({ type: 'UPDATE_LOBBY', players: players });
                } else {
                    // Client sends Hello
                    hostConn = conn; // Store ref
                    conn.send({ type: 'HELLO', name: myName });
                    onJoinSuccess(pendingJoinCode);
                }
            });

            // Handle Data
            conn.on('data', (data) => {
                handleData(data, conn.peer);
            });

            // Handle Close
            conn.on('close', () => {
                console.log("Conexi√≥n cerrada:", conn.peer);
                delete connections[conn.peer];
                if (isHost) {
                    players = players.filter(p => p.id !== conn.peer);
                    broadcast({ type: 'UPDATE_LOBBY', players: players });
                } else {
                    alert("Desconectado del Anfitri√≥n");
                    location.reload();
                }
            });

            conn.on('error', err => console.error("Conn Error:", err));
        }

        /* --- HOST LOGIC --- */
        function createRoom() {
            myName = document.getElementById('nickname').value || "Host";
            const code = Math.random().toString(36).substr(2, 4).toUpperCase();
            isHost = true;
            players = [{ id: "HOST", name: myName, score: 0, hand: [] }]; // Temp ID

            showScreen('screen-lobby');
            document.getElementById('host-controls').classList.remove('hidden');

            // Set display code immediately
            document.getElementById('lobby-code').innerText = code;

            initPeer("cah_" + code);
        }

        /* --- CLIENT LOGIC --- */
        function joinRoom() {
            myName = document.getElementById('nickname').value || "Guest";
            const code = document.getElementById('room-code-input').value.trim().toUpperCase();
            if (!code) return alert("Ingresa c√≥digo");

            isHost = false;
            pendingJoinCode = code; // Store for when open fires
            initPeer(); // No ID = Client
        }

        function connectToHost(code) {
            console.log("Conectando a:", "cah_" + code);
            const conn = peer.connect("cah_" + code);
            // We must setup connection handlers on the OUTGOING connection object too
            handleConnection(conn);
        }

        /* --- GAME LOGIC --- */
        function startGame() {
            if (players.length < 2) return alert("Se necesitan al menos 2 jugadores (ideal 3+)");

            console.log("Starting game. Players:", JSON.stringify(players));

            // Reset Game State
            gameState.round = 0;
            gameState.submissions = [];

            // Shuffle Decks
            whiteCards.sort(() => Math.random() - 0.5);
            blackCards.sort(() => Math.random() - 0.5);

            // Deal initial hands (7 cards)
            players.forEach(p => {
                p.hand = whiteCards.splice(0, 10);
                if (p.id !== myId) {
                    const conn = connections[p.id];
                    if (conn && conn.open) conn.send({ type: 'UPDATE_HAND', hand: p.hand });
                } else {
                    myHand = p.hand; // Sync local variable for Host
                    updateHandUI(p.hand); // Host hand
                }
            });

            startRound();
        }

        function startRound() {
            console.log("startRound executing. Players:", players.length, "Round:", gameState.round);

            if (players.length === 0) {
                console.error("Critical: No players in startRound!");
                return;
            }

            gameState.phase = 'SELECTION';
            gameState.submissions = [];

            // Refill decks if empty (simple reload)
            if (blackCards.length === 0) blackCards = [...CAH_BLACK].sort(() => Math.random() - 0.5);

            // Next Black Card
            gameState.blackCard = blackCards.pop();
            gameState.gameMode = gameMode; // Lock in mode for the round

            // Next Czar (Only for JUDGE mode)
            if (gameMode === 'JUDGE') {
                if (gameState.round === 0) {
                    gameState.czarIndex = 0;
                } else {
                    if (gameState.czarIndex >= players.length) gameState.czarIndex = -1;
                    gameState.czarIndex = gameState.round % players.length;
                }

                if (!players[gameState.czarIndex]) {
                    gameState.czarIndex = 0;
                }
                gameState.czarId = players[gameState.czarIndex].id;
            } else {
                gameState.czarIndex = -1;
                gameState.czarId = null; // No czar
            }

            const isFirstRound = (gameState.round === 0);

            // Reset Swap State
            players.forEach(p => p.hasSwapped = false);
            hasSwappedThisRound = false;
            resetSwapUI(true);

            const stateSnapshot = {
                phase: gameState.phase,
                blackCard: gameState.blackCard,
                czarId: gameState.czarId,
                round: gameState.round,
                submissions: [], // Empty for clients initially
                players: players.map(p => ({ id: p.id, name: p.name, score: p.score, hasSwapped: false }))
            };

            broadcast({ type: 'SITUATION_UPDATE', state: stateSnapshot });

            if (isFirstRound) {
                console.log("First round detected, broadcasting GAME_START");
                broadcast({ type: 'GAME_START', state: stateSnapshot });
            }

            // We must update the local round variable if it was overwritten by handleData/stateSnapshot
            gameState.round = (gameState.round || 0) + 1;

            if (isHost && timerSetting !== -1) {
                startTimerSequence();
            }
        }

        let currentStateTimer = null;
        function startTimerSequence() {
            if (currentStateTimer) clearInterval(currentStateTimer);
            let timeLeft = timerSetting;

            // Broadcast initial time
            broadcast({ type: 'SITUATION_UPDATE', state: gameState, timeLeft: timeLeft }); // Reuse situation update to sync time

            currentStateTimer = setInterval(() => {
                timeLeft--;
                // Broadcast time tick (optimize? maybe every 5s or just local countdown? 
                // Let's broadcast every second for sync primarily for now, optimization later if needed)
                // Actually, sending state every second is heavy. Let's send TIME_TICK.
                broadcast({ type: 'TIME_TICK', timeLeft: timeLeft });

                if (timeLeft <= 0) {
                    clearInterval(currentStateTimer);
                    handleTimeout();
                }
            }, 1000);
        }

        function handleTimeout() {
            console.log("Timer Expired for phase:", gameState.phase);
            if (gameState.phase === 'SELECTION') {
                // Force submit for players who haven't submitted
                const submittedIds = gameState.submissions.map(s => s.playerId);
                players.forEach(p => {
                    if (p.id === gameState.czarId && gameMode === 'JUDGE') return; // Czar safe
                    if (!submittedIds.includes(p.id)) {
                        // Auto pick random
                        const required = gameState.blackCard.blanks || 1;
                        // Clone hand to avoid mutation issues during splice loop
                        const available = [...p.hand];
                        const picks = [];
                        for (let i = 0; i < required; i++) {
                            if (available.length > 0) {
                                const ridx = Math.floor(Math.random() * available.length);
                                picks.push(available[ridx]);
                                available.splice(ridx, 1);
                            }
                        }
                        console.log(`Auto-picked for ${p.name}:`, picks);
                        handleSubmission(p.id, picks);
                    }
                });
            } else if (gameState.phase === 'JUDGING' || gameState.phase === 'VOTING') {
                // Force winner selection
                if (gameMode === 'JUDGE') {
                    // Host (Czar?) picks random if Czar didn't pick
                    // Actually handleTimeout is Host logic.
                    // If Czar hasn't picked...
                    const count = gameState.submissions.length;
                    if (count > 0) {
                        const ridx = Math.floor(Math.random() * count);
                        hostSelectWinner(ridx);
                    }
                } else {
                    // Voting: Time is up, score with current votes
                    scoreVotingRound();
                }
            }
        }



        function changePoints(delta) {
            if (!isHost) return;
            let newP = pointsToWin + delta;
            if (newP < 2) newP = 2;
            if (newP > 15) newP = 15;
            if (pointsToWin !== newP) {
                pointsToWin = newP;
                syncSettings();
            }
        }

        function changeGameMode(mode) {
            if (!isHost) return;
            if (gameMode !== mode) {
                gameMode = mode;
                syncSettings();
            }
        }

        function changeTimer(delta) {
            if (!isHost) return;
            if (timerSetting === -1) timerSetting = 40; // Restore if coming from infinite
            else {
                let newT = timerSetting + delta;
                if (newT < 20) newT = 20;
                if (newT > 120) newT = 120;
                timerSetting = newT;
            }
            syncSettings();
        }

        function toggleTimerLimit() {
            if (!isHost) return;
            if (timerSetting === -1) timerSetting = 40;
            else timerSetting = -1;
            syncSettings();
        }

        function syncSettings() {
            updateLobbySettingsUI();
            broadcast({ type: "UPDATE_SETTINGS", pointsToWin: pointsToWin, gameMode: gameMode, timerSetting: timerSetting });
        }

        function updateLobbySettingsUI() {
            document.getElementById("points-display-host").innerText = pointsToWin;
            document.getElementById("points-display-client").innerText = pointsToWin;
            const modeText = (gameMode === "JUDGE") ? "Juez Cl√°sico" : "Democracia";
            document.getElementById("mode-display-client").innerText = modeText;

            // Timer UI
            const timeStr = (timerSetting === -1) ? "‚àû" : timerSetting + "s";
            document.getElementById("timer-display-host").innerText = timeStr;
            document.getElementById("timer-setting-client").innerText = timeStr;
            const timerBtn = document.getElementById("btn-timer-toggle");
            if (timerBtn) {
                if (timerSetting === -1) {
                    timerBtn.innerText = "Activar L√≠mite";
                    timerBtn.classList.remove('secondary');
                } else {
                    timerBtn.innerText = "Sin L√≠mite";
                    timerBtn.classList.add('secondary');
                }
            }

            const btnJudge = document.getElementById("btn-mode-judge");
            const btnDemo = document.getElementById("btn-mode-demo");
            if (btnJudge && btnDemo) {
                if (gameMode === "JUDGE") {
                    btnJudge.classList.remove("secondary");
                    btnDemo.classList.add("secondary");
                } else {
                    btnJudge.classList.add("secondary");
                    btnDemo.classList.remove("secondary");
                }
            }
        }

        /* --- SWAP CARDS LOGIC --- */
        let isSwapping = false;
        let hasSwappedThisRound = false;

        function enableSwapMode() {
            if (gameState.phase !== 'SELECTION') return alert("Solo puedes cambiar cartas en tu turno.");
            if (gameState.czarId === myId) return alert("El Czar no puede cambiar cartas.");
            if (hasSwappedThisRound) return alert("Ya cambiaste cartas en esta ronda.");

            isSwapping = !isSwapping;
            selectedCards = [];
            updateHandUIHelper();

            const btn = document.getElementById('btn-swap-cards');
            if (isSwapping) {
                btn.style.background = '#e11d48'; // Red warning color
                btn.innerText = "CANCELAR CAMBIO";
                document.getElementById('status-display').innerText = "Selecciona 2 cartas para descartar...";
            } else {
                btn.style.background = 'white';
                btn.innerText = "Cambiar 2 Cartas";
                const status = document.getElementById('status-display');
                if (status) status.innerText = "Elige tus cartas m√°s graciosas.";
            }

            // Hide confirm button
            document.getElementById('btn-confirm-selection').classList.add('hidden');
        }

        function handleSwapRequest(cardTexts) {
            if (isHost) {
                processSwap(myId, cardTexts);
            } else {
                hostConn.send({ type: 'REQUEST_SWAP', cards: cardTexts });
            }
        }

        function processSwap(playerId, cardTexts) {
            const p = players.find(x => x.id === playerId);
            if (!p) return;
            if (p.hasSwapped) return;

            // Validate count
            if (cardTexts.length !== 2) {
                console.error("SWAP ERROR: Incorrect count", cardTexts.length);
                return;
            }

            console.log("SWAP: Hand BEFORE:", JSON.stringify(p.hand));
            console.log("SWAP: Targets:", JSON.stringify(cardTexts));

            // Remove cards
            cardTexts.forEach(text => {
                const idx = p.hand.indexOf(text);
                console.log(`SWAP: Looking for '${text}', found at ${idx}`);
                if (idx !== -1) p.hand.splice(idx, 1);
            });

            console.log("SWAP: Hand AFTER REMOVAL:", JSON.stringify(p.hand));

            // Add new ones
            while (p.hand.length < 10 && whiteCards.length > 0) {
                const newCard = whiteCards.pop();
                p.hand.push(newCard);
                console.log("SWAP: Drew new card:", newCard);
            }

            p.hasSwapped = true;

            // Sync
            if (p.id !== myId) {
                const conn = connections[p.id];
                if (conn && conn.open) {
                    conn.send({ type: 'UPDATE_HAND', hand: p.hand });
                    conn.send({ type: 'SWAP_SUCCESS' });
                }
            } else {
                updateHandUI(p.hand);
                hasSwappedThisRound = true;
                resetSwapUI(false);
            }

            // Broadcast player state update to everyone so they see who swapped
            const safePlayers = players.map(pl => ({
                id: pl.id,
                name: pl.name,
                score: pl.score,
                hasSwapped: pl.hasSwapped
            }));
            broadcast({ type: 'PLAYER_UPDATE', players: safePlayers });
        }

        // Helper to reset UI after swap or new round
        function resetSwapUI(newRound = false) {
            isSwapping = false;
            selectedCards = [];

            const btn = document.getElementById('btn-swap-cards');
            if (!btn) return;

            if (newRound) {
                btn.classList.remove('hidden');
                btn.style.opacity = '1';
                btn.style.pointerEvents = 'auto';
                btn.innerText = "Cambiar 2 Cartas";
                btn.style.background = 'white';
                hasSwappedThisRound = false;
            } else {
                // Used
                btn.style.opacity = '0.5';
                btn.style.pointerEvents = 'none';
                btn.innerText = "Cambio Usado";
                btn.style.background = '#666';
            }

            // Also hide the confirmation button if it's visible
            const confirmBtn = document.getElementById('btn-confirm-selection');
            if (confirmBtn) confirmBtn.classList.add('hidden');
        }

        // Wrapper for UI update
        function updateHandUIHelper() {
            if (isHost) {
                const me = players.find(p => p.id === myId);
                if (me) updateHandUI(me.hand);
            } else {
                updateHandUI(myHand);
            }
        }

        function handleSubmission(playerId, cardIndices) {
            // Find player
            const p = players.find(x => x.id === playerId);
            if (!p) return;

            const selectedCards = [];

            // cardIndices should be the card TEXT sent back
            cardIndices.forEach(cardText => {
                const idx = p.hand.indexOf(cardText);
                if (idx !== -1) {
                    selectedCards.push(p.hand[idx]);
                    p.hand.splice(idx, 1);
                }
            });

            // Replenish hand
            while (p.hand.length < 10 && whiteCards.length > 0) {
                p.hand.push(whiteCards.pop());
            }

            // Sync Hand to player
            if (p.id !== myId) {
                const conn = connections[p.id];
                if (conn && conn.open) conn.send({ type: 'UPDATE_HAND', hand: p.hand });
            } else {
                updateHandUI(p.hand);
            }

            gameState.submissions.push({ playerId, cards: selectedCards, playerName: p.name });

            // Update UI to show "Player X submitted" (masked)
            const submissionCount = gameState.submissions.length;
            let expected = players.length;
            if (gameMode === 'JUDGE') expected = players.length - 1; // Czar doesn't play

            // Broadcast progress - MASKED to clients only
            const safeSubs = gameState.submissions.map(s => ({ playerId: s.playerId, status: 'HIDDEN' }));

            // IMPORTANT: Exclude local update (host) to prevent overwriting the 'Truth' with masked data
            broadcast({
                type: 'SITUATION_UPDATE',
                state: {
                    ...gameState,
                    submissions: safeSubs // Masked
                }
            }, true);

            // Manually update Host UI
            updateTableUI();

            if (submissionCount >= expected) {
                // All in! Switch to phase
                if (gameMode === 'JUDGE') {
                    startJudging();
                } else {
                    startVoting();
                }
            }
        }

        function startJudging() {
            gameState.phase = 'JUDGING';
            // Shuffle submissions
            gameState.submissions.sort(() => Math.random() - 0.5);

            // Broadcast fully revealed submissions
            broadcast({
                type: 'SITUATION_UPDATE',
                state: gameState
            });

            if (isHost && timerSetting !== -1) startTimerSequence();
        }

        function startVoting() {
            gameState.phase = 'VOTING';
            // Shuffle submissions
            gameState.submissions.forEach(s => s.votes = []); // Init votes
            gameState.submissions.sort(() => Math.random() - 0.5);

            // Broadcast fully revealed submissions
            broadcast({
                type: 'SITUATION_UPDATE',
                state: gameState
            });

            if (isHost && timerSetting !== -1) startTimerSequence();
        }

        function hostSelectWinner(submissionIndex) {
            const winnerSub = gameState.submissions[submissionIndex];
            const p = players.find(x => x.id === winnerSub.playerId);
            if (p) p.score++;

            gameState.phase = 'SCORE';
            // Broadcast Winner
            broadcast({
                type: 'SITUATION_UPDATE',
                state: {
                    ...gameState,
                    winnerName: p.name,
                    winningCards: winnerSub.cards,
                    winningSubmissionIndex: submissionIndex
                }
            });

            checkGameEnd(p);
        }

        function handleVote(voterId, subIndex) {
            // Find who is voting
            // Allow self-votes (but they count as 0 later)
            const targetSub = gameState.submissions[subIndex];
            if (!targetSub) return;

            // Self-Vote Penalty Logic (Host Side)
            if (targetSub.playerId === voterId) {
                const voter = players.find(p => p.id === voterId);
                if (voter) {
                    voter.selfVoteCount = (voter.selfVoteCount || 0) + 1;
                    console.log(`Player ${voter.name} self-voted! Count: ${voter.selfVoteCount}`);

                    if (voter.selfVoteCount >= 3) {
                        voter.score--;
                        console.log(`Penalty applied to ${voter.name}. New Score: ${voter.score}`);
                        // Broadcast score update immediately
                        broadcast({ type: 'PLAYER_UPDATE', players: players });
                    }
                }
            }

            // Check if already voted? (Scan all submissions for this voterId in votes array)
            let alreadyVoted = false;
            gameState.submissions.forEach(s => {
                if (s.votes && s.votes.includes(voterId)) alreadyVoted = true;
            });
            if (alreadyVoted) return;

            // Record vote
            if (!targetSub.votes) targetSub.votes = [];
            targetSub.votes.push(voterId);

            console.log(`Vote recorded from ${voterId} for sub ${subIndex}`);

            // Check if all players have voted
            // Count total votes
            let totalVotes = 0;
            gameState.submissions.forEach(s => {
                if (s.votes) totalVotes += s.votes.length;
            });

            // Need votes from everyone? Or everyone except... no everyone votes in Democracy usually?
            // "y una vez votan todos sale el ganador"
            if (totalVotes >= players.length) {
                scoreVotingRound();
            }
        }

        function scoreVotingRound() {
            // Tally votes
            let maxVotes = -1;
            let winners = []; // Indices

            gameState.submissions.forEach((sub, idx) => {
                // Calculate valid votes (exclude self-votes)
                let validVotes = 0;
                if (sub.votes) {
                    sub.votes.forEach(voterId => {
                        if (voterId !== sub.playerId) validVotes++;
                    });
                }

                if (validVotes > maxVotes) {
                    maxVotes = validVotes;
                    winners = [idx];
                } else if (validVotes === maxVotes) {
                    winners.push(idx);
                }
            });

            // Assign points
            if (maxVotes > 0) {
                // Winner(s)
                winners.forEach(wIdx => {
                    const sub = gameState.submissions[wIdx];
                    const p = players.find(x => x.id === sub.playerId);
                    // Democracy mode winning point
                    if (p) p.score++;

                    // Note: original game might give point to everyone who voted for winner?
                    // Simplifying to just winner gets point.
                });

                gameState.winningSubmissionIndex = winners[0]; // Highlight first winner
                const wSub = gameState.submissions[winners[0]];
                const wPlayer = players.find(p => p.id === wSub.playerId);
                gameState.winnerName = wPlayer ? wPlayer.name : "Nadie";

                gameState.phase = 'SCORE';
                broadcast({ type: 'PLAYER_UPDATE', players: players });
                broadcast({
                    type: 'SITUATION_UPDATE',
                    state: gameState
                });

                checkGameEnd(wPlayer); // Check if they reached winning score
            } else {
                gameState.winnerName = "Nadie (0 votos)";
                gameState.phase = 'SCORE';
                broadcast({ type: 'PLAYER_UPDATE', players: players });
                broadcast({
                    type: 'SITUATION_UPDATE',
                    state: gameState
                });

                // No score update, just wait
                setTimeout(() => startRound(), 5000);
            }
        }

        function checkGameEnd(p) {
            // Check for Game Winner
            if (p.score >= pointsToWin) {
                // Game Over
                setTimeout(() => {
                    alert(`¬°JUEGO TERMINADO! ${p.name} ha ganado la partida con ${p.score} puntos.`);
                    location.reload(); // Simple reset for now
                }, 1000);
            } else {
                // Wait then next round
                setTimeout(() => {
                    startRound();
                }, 5000);
            }
        }

        function onJoinSuccess(code) {
            showScreen('screen-lobby');
            document.getElementById('lobby-code').innerText = code;
            document.getElementById('host-controls').classList.add('hidden');
            document.getElementById('client-settings-view').classList.remove('hidden');
        }

        let lastRoundId = -1;
        let myVotedIndex = -1; // Local state for voting

        function broadcast(msg, excludeLocal = false) {
            console.log("Broadcasting:", msg.type, "ExcludeLocal:", excludeLocal);
            Object.values(connections).forEach(c => {
                if (c && c.open) c.send(msg);
            });

            if (!excludeLocal) {
                try {
                    handleData(msg, 'HOST'); // Handle locally
                } catch (e) {
                    console.error("Local handleData failed:", e);
                }
            }
        }

        function handleData(data, senderId) {
            console.log("handleData received:", data.type, "from", senderId);
            try {
                switch (data.type) {
                    case 'HELLO':
                        if (isHost) {
                            // Check if exists
                            const existing = players.find(p => p.id === senderId);
                            if (!existing) {
                                players.push({ id: senderId, name: data.name, score: 0, hand: [] });
                                updateLobbyUI();
                                broadcast({ type: 'UPDATE_LOBBY', players: players });

                                // Sync settings to the new player personally
                                const conn = connections[senderId];
                                if (conn && conn.open) {
                                    conn.send({ type: 'UPDATE_SETTINGS', pointsToWin: pointsToWin, gameMode: gameMode, timerSetting: timerSetting });
                                }
                            }
                        }
                        break;
                    case 'UPDATE_LOBBY':
                        players = data.players;
                        updateLobbyUI();
                        break;
                    case 'UPDATE_SETTINGS':
                        pointsToWin = data.pointsToWin;
                        if (data.gameMode) gameMode = data.gameMode;
                        if (data.timerSetting !== undefined) {
                            timerSetting = data.timerSetting;
                        }
                        updateLobbySettingsUI();
                        break;
                    case 'GAME_START':
                        console.log("Processing GAME_START...");
                        gameState = data.state;
                        startGameUI();
                        break;
                    case 'UPDATE_HAND':
                        myHand = data.hand;
                        updateHandUI(myHand);
                        break;
                    case 'SITUATION_UPDATE':
                        console.log("Processing SITUATION_UPDATE...");

                        // Detect New Round
                        if (data.state.round !== lastRoundId) {
                            console.log("New Round Detected:", data.state.round);
                            lastRoundId = data.state.round;
                            // Reset local round state
                            hasSwappedThisRound = false;
                            resetSwapUI(true);
                            selectedCards = [];
                            myVotedIndex = -1; // Reset vote
                            // Removing 'selected' class from visual cards is handled by updateHandUI if hand updates, 
                            // but if hand doesn't update (no cards played?), we should clear selection visually.
                            document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
                            document.getElementById('btn-confirm-selection').classList.add('hidden');
                        }

                        gameState = data.state;
                        updateTableUI();
                        if (data.timeLeft !== undefined) updateTimerUI(data.timeLeft);
                        break;
                    case 'PLAYER_UPDATE':
                        // Sync both global players list and gameState players
                        players = data.players;
                        if (gameState) gameState.players = data.players;
                        updateTableUI();
                        break;
                    case 'SUBMIT_CARDS': // Host receives
                        if (isHost) handleSubmission(senderId, data.cards);
                        break;
                    case 'SELECT_WINNER': // Host receives from Czar
                        if (isHost && gameState.phase === 'JUDGING' && senderId === gameState.czarId) {
                            hostSelectWinner(data.submissionIndex);
                        }
                        break;
                    case 'REQUEST_SWAP':
                        if (isHost) processSwap(senderId, data.cards);
                        break;
                    case 'SUBMIT_VOTE':
                        if (isHost) handleVote(senderId, data.submissionIndex);
                        break;
                    case 'SWAP_SUCCESS':
                        // Reset my UI
                        hasSwappedThisRound = true;
                        resetSwapUI(false);
                        break;
                    case 'TIME_TICK':
                        updateTimerUI(data.timeLeft);
                        break;
                }
            } catch (e) {
                console.error("Error inside handleData switch:", e);
            }
        }

        /* --- UI HELPERS --- */
        function showScreen(id) {
            console.log("Switching to screen:", id);
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            const screen = document.getElementById(id);
            if (screen) screen.classList.remove('hidden');
            else console.error("Screen not found:", id);
        }

        function updateLobbyUI() {
            const list = document.getElementById('lobby-list');
            list.innerHTML = players.map(p => `<li>${p.name} <span>${p.score} pts</span></li>`).join('');
        }

        function startGameUI() {
            console.log("startGameUI called");
            showScreen('screen-game');
            updateTableUI();
        }

        function updateHandUI(hand) {
            const area = document.getElementById('hand-area');
            area.innerHTML = '';
            hand.forEach((text, i) => {
                const c = createCard('white', text);
                c.onclick = () => toggleSelectCard(c, text);
                area.appendChild(c);
            });
        }

        let selectedCards = []; // Local selection
        function toggleSelectCard(cardElem, text) {
            // Special mode: SWAPPING
            if (isSwapping) {
                if (cardElem.classList.contains('selected')) {
                    cardElem.classList.remove('selected');
                    selectedCards = selectedCards.filter(t => t !== text);
                } else {
                    if (selectedCards.length < 2) {
                        cardElem.classList.add('selected');
                        selectedCards.push(text);
                    } else {
                        alert("Solo puedes cambiar 2 cartas.");
                    }
                }

                // Show confirm swap button
                const btn = document.getElementById('btn-confirm-selection');
                if (selectedCards.length === 2) {
                    btn.innerText = "CONFIRMAR CAMBIO";
                    btn.classList.remove('hidden');
                    btn.style.background = '#e11d48';
                    btn.onclick = () => {
                        if (confirm("¬øCambiar estas 2 cartas? perder√°s tu turno de cambio esta ronda.")) {
                            handleSwapRequest(selectedCards);
                        }
                    };
                } else {
                    btn.classList.add('hidden');
                }
                return;
            }

            // Normal Play Mode
            if (gameState.phase !== 'SELECTION') return;
            if (gameState.czarId === myId) return alert("Eres el Czar, no juegas cartas, solo juzgas.");

            const required = gameState.blackCard.blanks || 1;

            if (cardElem.classList.contains('selected')) {
                cardElem.classList.remove('selected');
                selectedCards = selectedCards.filter(t => t !== text);
            } else {
                if (selectedCards.length < required) {
                    cardElem.classList.add('selected');
                    selectedCards.push(text);
                } else {
                    // Replace first? or strict limit?
                    // Let's strict limit, user must deselect
                    alert(`Solo elige ${required} carta(s).`);
                }
            }

            // Show confirm button if full
            const btn = document.getElementById('btn-confirm-selection');
            if (selectedCards.length === required) {
                btn.innerText = "CONFIRMAR SELECCI√ìN";
                btn.style.background = '#2563eb';
                btn.classList.remove('hidden');
                btn.onclick = () => submitSelection();
            } else {
                btn.classList.add('hidden');
            }
        }

        function submitSelection() {
            if (isHost) handleSubmission(myId, selectedCards); // Host local play
            else hostConn.send({ type: 'SUBMIT_CARDS', cards: selectedCards });

            // Clear local selection UI
            selectedCards = [];
            document.getElementById('btn-confirm-selection').classList.add('hidden');

            // Only hide hand for clients who are waiting for network response
            if (!isHost) {
                document.getElementById('hand-area').innerHTML = '<h3 style="margin:auto; color:#666;">Cartas Enviadas. Esperando...</h3>';
            }
        }

        // Memoized star delays
        let starDelayCache = { round: -1, phase: '', voteCount: -1, map: new Map() };

        function getStarDelays() {
            // Cache invalidation conditions
            const currentVoteCount = countTotalVotes();
            if (starDelayCache.round === gameState.round &&
                starDelayCache.phase === gameState.phase &&
                starDelayCache.voteCount === currentVoteCount) {
                return starDelayCache.map;
            }

            // Compute
            const delayMap = new Map();

            // Find max depth (max number of votes any card has)
            let maxDepth = 0;
            if (gameState.submissions) {
                gameState.submissions.forEach(sub => {
                    if (sub.votes && sub.votes.length > maxDepth) maxDepth = sub.votes.length;
                });
            }

            // Assign delays based on Waves
            // Wave N: All stars at index N appear together.
            // Self-votes appear AFTER all possible normal waves.
            const waveDuration = 0.6; // Seconds between waves
            const selfVoteOffset = (maxDepth * waveDuration) + 0.5;

            if (gameState.submissions) {
                gameState.submissions.forEach((sub, sIdx) => {
                    if (sub.votes) {
                        // We want self votes to be visually last? 
                        // The DOM order is determined by sub.votes array order.
                        // But we can just delay the animation heavily.

                        let selfCountInThisCard = 0;

                        sub.votes.forEach((vId, vIdx) => {
                            const isSelf = (vId === sub.playerId);
                            let delay = 0;

                            if (!isSelf) {
                                // Wave based on index
                                delay = vIdx * waveDuration;
                                // Add slight organic jitter
                                delay += (Math.random() * 0.2);
                            } else {
                                // Self vote: Push to end
                                delay = selfVoteOffset + (selfCountInThisCard * 0.5);
                                selfCountInThisCard++;
                            }

                            delayMap.set(`${sIdx}-${vIdx}`, delay);
                        });
                    }
                });
            }

            starDelayCache = {
                round: gameState.round,
                phase: gameState.phase,
                voteCount: currentVoteCount,
                map: delayMap
            };
            return delayMap;
        }

        function countTotalVotes() {
            let c = 0;
            if (gameState.submissions) gameState.submissions.forEach(s => { if (s.votes) c += s.votes.length; });
            return c;
        }

        function createCard(type, text) {
            const div = document.createElement('div');
            div.className = `card ${type} deal-anim`;
            // Wrap text in container
            const textHTML = text.replace(/_+/g, '_______');
            div.innerHTML = `<div class="card-text-content">${textHTML}</div><div class="card-logo">Cartas Contra la Humanidad</div>`;
            return div;
        }

        function updateTableUI() {
            // Update Player List
            const listContainer = document.getElementById('ingame-player-list');
            if (listContainer && gameState.players) {
                listContainer.innerHTML = gameState.players.map(p => {
                    const isCzar = (p.id === gameState.czarId);
                    const swapped = p.hasSwapped ? '<span style="color:#e11d48; margin-left:5px;">(Cambi√≥)</span>' : '';

                    // Check if they submitted
                    const hasSubmitted = gameState.submissions && gameState.submissions.some(s => s.playerId === p.id);
                    const ready = (hasSubmitted && !isCzar) ? '<span style="color:#10b981; margin-left:5px;">(Listo)</span>' : '';

                    const isMe = (p.id === myId) ? ' (T√∫)' : '';
                    return `<div style="margin-bottom:5px; background: rgba(255,255,255,0.8); padding: 4px 10px; border-radius: 15px; font-size: 0.85rem; display:inline-block;">
                        ${isCzar ? 'üëë ' : ''}<strong>${p.name}</strong>${isMe}: ${p.score} pts ${swapped} ${ready}
                    </div><br>`;
                }).join('');
            }
            // Update Czar Info
            if (gameMode === 'DEMOC') {
                document.getElementById('czar-name').innerText = "Todos";
            } else {
                const czarPlayer = gameState.players.find(p => p.id === gameState.czarId);
                document.getElementById('czar-name').innerText = czarPlayer ? czarPlayer.name : "???";
            }

            // Update My Score
            const me = gameState.players.find(p => p.id === myId);
            if (me) document.getElementById('my-score').innerText = me.score;

            // Status Msg
            const status = document.getElementById('status-display');
            if (gameState.phase === 'SELECTION') {
                if (gameMode === 'DEMOC') {
                    status.innerText = "¬°DEMOCRACIA! Elige tus cartas m√°s graciosas.";
                } else {
                    status.innerText = (gameState.czarId === myId) ? "Eres el JUEZ. Espera a que los plebeyos elijan." : "Elige tus cartas m√°s graciosas.";
                }
                // Show Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'block';

                // Hand Title Hint
                const hTitle = document.getElementById('hand-title');
                if (hTitle) {
                    if (gameState.czarId === myId) {
                        hTitle.innerText = "Tu Mano (Esperando a que elijan...)";
                    } else {
                        const count = (gameState.blackCard && gameState.blackCard.blanks) ? gameState.blackCard.blanks : 1;
                        hTitle.innerText = `Tu Mano (Elige ${count} de cartas)`;
                    }
                }
            } else if (gameState.phase === 'JUDGING') {
                status.innerText = (gameState.czarId === myId) ? "¬°JUZGA! Elige la ganadora." : "El Juez est√° eligiendo...";
                // Hide Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'none';
            } else if (gameState.phase === 'SCORE') {
                status.innerText = `¬°${gameState.winnerName} gana la ronda!`;
                // Hide Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'none';
            } else if (gameState.phase === 'VOTING') {
                status.innerText = "¬°DEMOCRACIA! Vota por la mejor carta.";
                // Hide Hand
                const hc = document.getElementById('hand-container');
                if (hc) hc.style.display = 'none';
            }

            // Black Card
            const bcSpot = document.getElementById('black-card-spot');
            bcSpot.innerHTML = '';
            if (gameState.blackCard) bcSpot.appendChild(createCard('black', gameState.blackCard.text));

            // Played Cards
            const pcArea = document.getElementById('played-cards-area');
            pcArea.innerHTML = '';

            if (gameState.phase === 'SELECTION') {
                // Show face down cards for each submission
                gameState.submissions.forEach(sub => {
                    // Create dummy back cards
                    const group = document.createElement('div');
                    group.style.display = 'flex';
                    group.style.gap = '5px';
                    // We don't know how many cards if masked? Well, blackCard.blanks
                    const count = gameState.blackCard.blanks || 1;
                    for (let i = 0; i < count; i++) {
                        const c = createCard('white', 'Cartas Contra la Humanidad');
                        c.style.background = '#1a1a1a'; // Dark back
                        c.style.color = 'white';
                        c.innerHTML = '<div style="font-size:2rem; margin:auto;">?</div>';
                        group.appendChild(c);
                    }
                    pcArea.appendChild(group);
                });
            } else if (gameState.phase === 'JUDGING' || gameState.phase === 'SCORE' || gameState.phase === 'VOTING') {
                // Show real cards
                gameState.submissions.forEach((sub, idx) => {
                    const group = document.createElement('div');
                    group.style.display = 'flex';
                    group.style.gap = '5px';

                    // Add shuffle animation if entering Judging/Voting
                    if (gameState.phase === 'JUDGING' || gameState.phase === 'VOTING') {
                        group.style.animation = 'shuffleDeal 0.6s ease-out backwards';
                        group.style.animationDelay = (idx * 0.15) + 's';
                    }

                    // If SCORING, highlight winner AFTER stars
                    if (gameState.phase === 'SCORE' && idx === gameState.winningSubmissionIndex) {
                        group.style.border = '2px solid transparent'; // Start invisible
                        group.style.borderRadius = '10px';
                        group.style.padding = '5px';
                        group.style.background = 'transparent'; // Start invisible

                        // Calculate delay based on total votes
                        // We know delay is index * 0.5s. 
                        const totalVotes = countTotalVotes();
                        const delaySeconds = (totalVotes * 0.5) + 0.5; // Wait for all stars + 0.5s buffer

                        group.style.animation = `winnerGlow 0.8s ease-out forwards ${delaySeconds}s`;
                    }

                    // VOTING: Highlight my choice in blue
                    if (gameState.phase === 'VOTING' && idx === myVotedIndex) {
                        group.style.border = '3px solid #3b82f6';
                        group.style.borderRadius = '10px';
                        group.style.padding = '5px';
                        group.style.boxShadow = '0 0 10px rgba(59, 130, 246, 0.5)';
                    }

                    // Create a wrapper for cards to separate them from stars
                    const cardWrapper = document.createElement('div');
                    cardWrapper.style.display = 'flex';
                    cardWrapper.style.gap = '5px';
                    group.style.flexDirection = 'column'; // Allow stars below
                    group.style.alignItems = 'center';
                    group.appendChild(cardWrapper);

                    sub.cards.forEach(text => {
                        const c = createCard('white', text);
                        // If I am Czar and Judging, allow click
                        if (gameState.phase === 'JUDGING' && myId === gameState.czarId) {
                            c.style.cursor = 'pointer';
                            // Add hover effect
                            c.onmouseenter = () => c.style.transform = 'scale(1.05)';
                            c.onmouseleave = () => c.style.transform = 'scale(1)';

                            c.onclick = () => {
                                if (confirm("¬øElegir esta como ganadora?")) {
                                    if (isHost) {
                                        hostSelectWinner(idx);
                                    } else {
                                        hostConn.send({ type: 'SELECT_WINNER', submissionIndex: idx });
                                    }
                                }
                            };
                        }

                        // VOTING Phase Logic
                        if (gameState.phase === 'VOTING') {
                            // Enable click ONLY if I haven't voted yet
                            if (myVotedIndex === -1) {
                                c.style.cursor = 'pointer';
                                c.onmouseenter = () => c.style.transform = 'scale(1.05)';
                                c.onmouseleave = () => c.style.transform = 'scale(1)';

                                c.onclick = () => {
                                    const isMyCard = (myId === sub.playerId);
                                    const warning = isMyCard
                                        ? "¬øVotar por ti mismo? (No contara el voto, y si lo haces mucho te restar√° puntos)"
                                        : "¬øVotar por esta carta? No podr√°s cambiar tu voto.";
                                    if (confirm(warning)) {
                                        myVotedIndex = idx; // Lock locally
                                        updateTableUI(); // Re-render to show blue

                                        // Send vote
                                        if (isHost) handleVote(myId, idx);
                                        else hostConn.send({ type: 'SUBMIT_VOTE', submissionIndex: idx });
                                    }
                                };
                            } else {
                                // Disabled state
                                c.style.opacity = '0.9';
                                c.style.cursor = 'default';
                            }
                        }

                        cardWrapper.appendChild(c);
                    });

                    // Append Stars if applicable
                    if ((gameState.phase === 'SCORE' || gameState.phase === 'JUDGING') && sub.votes && sub.votes.length > 0) {
                        const starDelays = getStarDelays();
                        const starRow = document.createElement('div');
                        starRow.className = 'star-container';
                        sub.votes.forEach((vId, vIdx) => {
                            const s = document.createElement('span');
                            const isSelf = (vId === sub.playerId);
                            let starClass = 'star-gold';

                            if (isSelf) {
                                starClass = 'star-grey';
                                const voter = players.find(p => p.id === vId);
                                if (voter && (voter.selfVoteCount || 0) >= 3) {
                                    starClass = 'star-black';
                                }
                            }

                            s.className = `star-icon ${starClass}`;
                            s.innerHTML = '‚òÖ';

                            // Use calculated global delay
                            const dVal = starDelays ? starDelays.get(`${idx}-${vIdx}`) : undefined;
                            const delay = (dVal !== undefined) ? dVal : (vIdx * 0.2);
                            s.style.animationDelay = delay + 's';

                            starRow.appendChild(s);
                        });
                        group.appendChild(starRow);
                    }

                    pcArea.appendChild(group);
                });
            }
        }
        function updateTimerUI(seconds) {
            const el = document.getElementById('game-timer');
            if (seconds === -1 || seconds === undefined) el.innerText = "";
            else el.innerText = "‚è±Ô∏è " + seconds + "s";

            if (seconds <= 10) el.style.color = 'red';
            else el.style.color = '#e11d48';
        }
    </script>
</body>

</html>