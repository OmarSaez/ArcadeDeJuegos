<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Batalla Naval - P2P</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script>
        /**
         * Minified by jsDelivr using Terser v5.37.0.
         * Original file: /npm/canvas-confetti@1.6.0/dist/confetti.browser.js
         *
         * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
         */
        !function (t, e) { !function t(e, n, a, i) { var o = !!(e.Worker && e.Blob && e.Promise && e.OffscreenCanvas && e.OffscreenCanvasRenderingContext2D && e.HTMLCanvasElement && e.HTMLCanvasElement.prototype.transferControlToOffscreen && e.URL && e.URL.createObjectURL); function r() { } function l(t) { var a = n.exports.Promise, i = void 0 !== a ? a : e.Promise; return "function" == typeof i ? new i(t) : (t(r, r), null) } var c, s, u, h, f, d, m, g, b, v = (u = Math.floor(1e3 / 60), h = {}, f = 0, "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame ? (c = function (t) { var e = Math.random(); return h[e] = requestAnimationFrame((function n(a) { f === a || f + u - 1 < a ? (f = a, delete h[e], t()) : h[e] = requestAnimationFrame(n) })), e }, s = function (t) { h[t] && cancelAnimationFrame(h[t]) }) : (c = function (t) { return setTimeout(t, u) }, s = function (t) { return clearTimeout(t) }), { frame: c, cancel: s }), M = (g = {}, function () { if (d) return d; if (!a && o) { var e = ["var CONFETTI, SIZE = {}, module = {};", "(" + t.toString() + ")(this, module, true, SIZE);", "onmessage = function(msg) {", "  if (msg.data.options) {", "    CONFETTI(msg.data.options).then(function () {", "      if (msg.data.callback) {", "        postMessage({ callback: msg.data.callback });", "      }", "    });", "  } else if (msg.data.reset) {", "    CONFETTI && CONFETTI.reset();", "  } else if (msg.data.resize) {", "    SIZE.width = msg.data.resize.width;", "    SIZE.height = msg.data.resize.height;", "  } else if (msg.data.canvas) {", "    SIZE.width = msg.data.canvas.width;", "    SIZE.height = msg.data.canvas.height;", "    CONFETTI = module.exports.create(msg.data.canvas);", "  }", "}"].join("\n"); try { d = new Worker(URL.createObjectURL(new Blob([e]))) } catch (t) { return void 0 !== typeof console && "function" == typeof console.warn && console.warn("üéä Could not load worker", t), null } !function (t) { function e(e, n) { t.postMessage({ options: e || {}, callback: n }) } t.init = function (e) { var n = e.transferControlToOffscreen(); t.postMessage({ canvas: n }, [n]) }, t.fire = function (n, a, i) { if (m) return e(n, null), m; var o = Math.random().toString(36).slice(2); return m = l((function (a) { function r(e) { e.data.callback === o && (delete g[o], t.removeEventListener("message", r), m = null, i(), a()) } t.addEventListener("message", r), e(n, o), g[o] = r.bind(null, { data: { callback: o } }) })) }, t.reset = function () { for (var e in t.postMessage({ reset: !0 }), g) g[e](), delete g[e] } }(d) } return d }), p = { particleCount: 50, angle: 90, spread: 45, startVelocity: 45, decay: .9, gravity: 1, drift: 0, ticks: 200, x: .5, y: .5, shapes: ["square", "circle"], zIndex: 100, colors: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"], disableForReducedMotion: !1, scalar: 1 }; function y(t, e, n) { return function (t, e) { return e ? e(t) : t }(t && null != t[e] ? t[e] : p[e], n) } function w(t) { return t < 0 ? 0 : Math.floor(t) } function x(t) { return parseInt(t, 16) } function C(t) { return t.map(T) } function T(t) { var e = String(t).replace(/[^0-9a-f]/gi, ""); return e.length < 6 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), { r: x(e.substring(0, 2)), g: x(e.substring(2, 4)), b: x(e.substring(4, 6)) } } function I(t) { t.width = document.documentElement.clientWidth, t.height = document.documentElement.clientHeight } function k(t) { var e = t.getBoundingClientRect(); t.width = e.width, t.height = e.height } function E(t, e, n, o, r) { var c, s, u = e.slice(), h = t.getContext("2d"), f = l((function (e) { function l() { c = s = null, h.clearRect(0, 0, o.width, o.height), r(), e() } c = v.frame((function e() { !a || o.width === i.width && o.height === i.height || (o.width = t.width = i.width, o.height = t.height = i.height), o.width || o.height || (n(t), o.width = t.width, o.height = t.height), h.clearRect(0, 0, o.width, o.height), u = u.filter((function (t) { return function (t, e) { e.x += Math.cos(e.angle2D) * e.velocity + e.drift, e.y += Math.sin(e.angle2D) * e.velocity + e.gravity, e.wobble += e.wobbleSpeed, e.velocity *= e.decay, e.tiltAngle += .1, e.tiltSin = Math.sin(e.tiltAngle), e.tiltCos = Math.cos(e.tiltAngle), e.random = Math.random() + 2, e.wobbleX = e.x + 10 * e.scalar * Math.cos(e.wobble), e.wobbleY = e.y + 10 * e.scalar * Math.sin(e.wobble); var n = e.tick++ / e.totalTicks, a = e.x + e.random * e.tiltCos, i = e.y + e.random * e.tiltSin, o = e.wobbleX + e.random * e.tiltCos, r = e.wobbleY + e.random * e.tiltSin; if (t.fillStyle = "rgba(" + e.color.r + ", " + e.color.g + ", " + e.color.b + ", " + (1 - n) + ")", t.beginPath(), "circle" === e.shape) t.ellipse ? t.ellipse(e.x, e.y, Math.abs(o - a) * e.ovalScalar, Math.abs(r - i) * e.ovalScalar, Math.PI / 10 * e.wobble, 0, 2 * Math.PI) : function (t, e, n, a, i, o, r, l, c) { t.save(), t.translate(e, n), t.rotate(o), t.scale(a, i), t.arc(0, 0, 1, r, l, c), t.restore() }(t, e.x, e.y, Math.abs(o - a) * e.ovalScalar, Math.abs(r - i) * e.ovalScalar, Math.PI / 10 * e.wobble, 0, 2 * Math.PI); else if ("star" === e.shape) for (var l = Math.PI / 2 * 3, c = 4 * e.scalar, s = 8 * e.scalar, u = e.x, h = e.y, f = 5, d = Math.PI / f; f--;)u = e.x + Math.cos(l) * s, h = e.y + Math.sin(l) * s, t.lineTo(u, h), l += d, u = e.x + Math.cos(l) * c, h = e.y + Math.sin(l) * c, t.lineTo(u, h), l += d; else t.moveTo(Math.floor(e.x), Math.floor(e.y)), t.lineTo(Math.floor(e.wobbleX), Math.floor(i)), t.lineTo(Math.floor(o), Math.floor(r)), t.lineTo(Math.floor(a), Math.floor(e.wobbleY)); return t.closePath(), t.fill(), e.tick < e.totalTicks }(h, t) })), u.length ? c = v.frame(e) : l() })), s = l })); return { addFettis: function (t) { return u = u.concat(t), f }, canvas: t, promise: f, reset: function () { c && v.cancel(c), s && s() } } } function S(t, n) { var a, i = !t, r = !!y(n || {}, "resize"), c = y(n, "disableForReducedMotion", Boolean), s = o && !!y(n || {}, "useWorker") ? M() : null, u = i ? I : k, h = !(!t || !s) && !!t.__confetti_initialized, f = "function" == typeof matchMedia && matchMedia("(prefers-reduced-motion)").matches; function d(e, n, i) { for (var o, r, l, c, s, h = y(e, "particleCount", w), f = y(e, "angle", Number), d = y(e, "spread", Number), m = y(e, "startVelocity", Number), g = y(e, "decay", Number), b = y(e, "gravity", Number), v = y(e, "drift", Number), M = y(e, "colors", C), p = y(e, "ticks", Number), x = y(e, "shapes"), T = y(e, "scalar"), I = function (t) { var e = y(t, "origin", Object); return e.x = y(e, "x", Number), e.y = y(e, "y", Number), e }(e), k = h, S = [], F = t.width * I.x, N = t.height * I.y; k--;)S.push((o = { x: F, y: N, angle: f, spread: d, startVelocity: m, color: M[k % M.length], shape: x[(c = 0, s = x.length, Math.floor(Math.random() * (s - c)) + c)], ticks: p, decay: g, gravity: b, drift: v, scalar: T }, r = void 0, l = void 0, r = o.angle * (Math.PI / 180), l = o.spread * (Math.PI / 180), { x: o.x, y: o.y, wobble: 10 * Math.random(), wobbleSpeed: Math.min(.11, .1 * Math.random() + .05), velocity: .5 * o.startVelocity + Math.random() * o.startVelocity, angle2D: -r + (.5 * l - Math.random() * l), tiltAngle: (.5 * Math.random() + .25) * Math.PI, color: o.color, shape: o.shape, tick: 0, totalTicks: o.ticks, decay: o.decay, drift: o.drift, random: Math.random() + 2, tiltSin: 0, tiltCos: 0, wobbleX: 0, wobbleY: 0, gravity: 3 * o.gravity, ovalScalar: .6, scalar: o.scalar })); return a ? a.addFettis(S) : (a = E(t, S, u, n, i)).promise } function m(n) { var o = c || y(n, "disableForReducedMotion", Boolean), m = y(n, "zIndex", Number); if (o && f) return l((function (t) { t() })); i && a ? t = a.canvas : i && !t && (t = function (t) { var e = document.createElement("canvas"); return e.style.position = "fixed", e.style.top = "0px", e.style.left = "0px", e.style.pointerEvents = "none", e.style.zIndex = t, e }(m), document.body.appendChild(t)), r && !h && u(t); var g = { width: t.width, height: t.height }; function b() { if (s) { var e = { getBoundingClientRect: function () { if (!i) return t.getBoundingClientRect() } }; return u(e), void s.postMessage({ resize: { width: e.width, height: e.height } }) } g.width = g.height = null } function v() { a = null, r && e.removeEventListener("resize", b), i && t && (document.body.removeChild(t), t = null, h = !1) } return s && !h && s.init(t), h = !0, s && (t.__confetti_initialized = !0), r && e.addEventListener("resize", b, !1), s ? s.fire(n, g, v) : d(n, g, v) } return m.reset = function () { s && s.reset(), a && a.reset() }, m } function F() { return b || (b = S(null, { useWorker: !0, resize: !0 })), b } n.exports = function () { return F().apply(this, arguments) }, n.exports.reset = function () { F().reset() }, n.exports.create = S }(function () { return void 0 !== t ? t : "undefined" != typeof self ? self : this || {} }(), e, !1), t.confetti = e.exports }(window, {});
        //# sourceMappingURL=/sm/6de00f2697a1683b235e589897df757a94e6809643432a9e3ad259420752442d.map
    </script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --sea-color: #0f172a;
            --grid-line: rgba(56, 189, 248, 0.2);
            --ship-color: #475569;
            --ship-border: #94a3b8;
            --ship-selected: #3b82f6;
            --hit: #ef4444;
            --miss: #1e293b;
            --radar-green: #22c55e;
            --bg-dark: #020617;
        }

        body {
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Roboto Mono', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            /* Allow scroll by default, block only on game area */
        }

        /* Prevent scroll interfering with Drag & Drop */
        .board-wrapper,
        .ship-visual,
        .inventory-item,
        #setup-area {
            touch-action: none !important;
        }

        h1,
        h2,
        h3 {
            font-family: 'Black Ops One', cursive;
            color: var(--radar-green);
            text-transform: uppercase;
            margin: 0;
            text-shadow: 0 0 10px rgba(34, 197, 94, 0.4);
        }

        /* --- LAYOUT UTILS --- */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 3px;
            /* Reduced from 20px for mobile */
            box-sizing: border-box;
            overflow-y: auto;
        }

        /* Add more padding on desktop */
        @media (min-width: 600px) {
            .screen {
                padding: 20px;
            }
        }

        .hidden {
            display: none !important;
        }

        .btn {
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid var(--radar-green);
            color: var(--radar-green);
            padding: 10px 20px;
            font-family: 'Black Ops One', cursive;
            font-size: 1rem;
            margin: 5px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.1);
            border-radius: 4px;
        }

        .btn:active {
            background: rgba(34, 197, 94, 0.2);
        }

        .btn.secondary {
            border-color: #64748b;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .btn.small {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        input {
            background: #1e293b;
            border: 1px solid #475569;
            color: white;
            padding: 8px;
            font-size: 1rem;
            text-align: center;
            font-family: 'Roboto Mono';
            border-radius: 4px;
        }

        /* --- CONFIG SCREEN --- */
        .config-panel {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #334155;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .ship-config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            background: #0f172a;
            padding: 5px 10px;
            border-radius: 4px;
        }

        /* --- GAME LAYOUT UPDATED --- */
        .game-layout {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Center everything vertically */
            width: 100%;
            height: 100%;
            max-width: 600px;
            /* Limit width for cleaner look */
            padding: 10px;
            box-sizing: border-box;
            gap: 15px;
            /* Spacing between blocks */
        }

        /* Responsive Layout: Keep vertical stack even on desktop, just cleaner */
        @media (min-width: 800px) {
            .game-layout {
                max-width: 800px;
                padding-top: 20px;
            }
        }

        /* Board Sections */
        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        /* --- ENEMY STATUS (HORIZONTAL SCROLL) --- */
        #enemy-fleet-panel {
            width: 100%;
            height: auto;
            min-height: 60px;
            background: #1e293b;
            border: 1px solid #334155;
            padding: 10px;

            /* Horizontal Scroll Logic */
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 10px;
            align-items: center;
            justify-content: flex-start;
            /* Items start from left */

            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--radar-green) #1e293b;
        }

        .enemy-ship-entry {
            background: #0f172a;
            padding: 5px 10px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.9;
            border: 1px solid #334155;
            flex-shrink: 0;
            /* Don't shrink items */
            min-width: 60px;
        }

        .board-wrapper {
            position: relative;
            background: #1e293b;
            /* Board base color */
            border: 2px solid #64748b;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            /* Remove transform logic that might mess up coord calc */
            margin: 0 auto;
            /* Explicitly auto for centering */
        }

        /* FIX: Align setup board to top */
        #setup-board {
            margin: 0 !important;
        }

        .grid-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            /* Ensure grid is above base but below ships */
            /* High contrast grid by default */
            background-image:
                linear-gradient(to right, rgba(255, 255, 255, 0.2) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
        }

        .cell {
            border: 1px solid var(--grid-line);
        }

        /* Markers Layer (Hits/Misses) */
        .marker-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .marker {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
        }

        .marker.miss {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40%;
            height: 40%;
            top: 30%;
            left: 30%;
        }

        .marker.hit::after {
            content: 'üî•';
            font-size: 1.5rem;
            filter: drop-shadow(0 0 5px orange);
        }

        /* Ship Layer */
        .ship-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ship-visual {
            position: absolute;
            background: var(--ship-color);
            border: 2px solid var(--ship-border);
            box-sizing: border-box;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            pointer-events: all;
            /* Internal grid for ship blocks to look good */
            background-image: linear-gradient(90deg, transparent 50%, rgba(0, 0, 0, 0.2) 50%);
        }

        .ship-visual.selected {
            border-color: var(--ship-selected);
            box-shadow: 0 0 10px var(--ship-selected);
            z-index: 10;
        }

        .ship-visual.dragging {
            opacity: 0.8;
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 20px 30px rgba(0, 0, 0, 0.5);
        }

        .ship-visual.vertical {
            flex-direction: column;
            background-image: linear-gradient(0deg, transparent 50%, rgba(0, 0, 0, 0.2) 50%);
        }

        /* --- INVENTORY (SETUP) --- */
        #inventory-container {
            width: 100%;
            height: 120px;
            background: #1e293b;
            border-top: 2px solid var(--radar-green);
            /* REMOVED: position: fixed; bottom: 0; left: 0; */
            margin-top: 20px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            padding: 10px;
            /* gap: 15px; */
            /* Gap irrelevant if absolute, but keeps initial items spaced */
            overflow-x: auto;
            z-index: 50;
            position: relative;
            /* Allow absolute positioning inside */
        }

        .inventory-item {
            flex-shrink: 0;
            background: #334155;
            border: 1px dashed #94a3b8;
            padding: 5px;
            cursor: grab;
            margin-right: 20px;
        }

        /* --- ENEMY STATUS (GAME) --- */
        #enemy-fleet-panel {
            width: 100%;
            max-width: 400px;
            /* Mobile */
            height: 150px;
            background: #1e293b;
            border: 1px solid #334155;
            margin-top: 10px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            /* Row wrap for mobile */
            gap: 10px;
        }

        @media (min-width: 800px) {
            #enemy-fleet-panel {
                width: 100%;
                /* Full width */
                max-width: 500px;
                /* Match board width */
                height: auto;
                min-height: 60px;
                flex-direction: row;
                /* Horizontal */
                justify-content: flex-start;
                /* Start from left */
                overflow-x: auto;
                /* Scrollable */
                overflow-y: hidden;
                margin-top: 5px;
                padding-bottom: 5px;
                /* Space for scrollbar */
                gap: 10px;
            }
        }

        .enemy-ship-entry {
            background: #0f172a;
            padding: 5px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            /* Keep shape block layout */
            align-items: center;
            opacity: 0.8;
            border: 1px solid #334155;
            flex: 0 0 auto;
            /* Don't shrink */
        }

        .enemy-ship-entry.sunk {
            border-color: #ef4444;
            /* RED Border */
            background: rgba(239, 68, 68, 0.2);
            /* Red tint */
            box-shadow: 0 0 10px #ef4444;
            opacity: 1;
        }

        .ship-shape-display {
            display: flex;
            gap: 2px;
            margin-top: 2px;
        }

        .ship-block {
            width: 10px;
            /* Slightly smaller for compact list */
            height: 10px;
            background: #94a3b8;
            border-radius: 2px;
        }

        .enemy-ship-entry.sunk .ship-block {
            background: #ef4444;
            /* Red blocks */
        }

        /* Markers */
        .marker {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            /* Big Emojis */
            pointer-events: none !important;
            z-index: 20;
            text-shadow: 0 0 5px black;
        }

        #chat-btn,
        #quick-chat-overlay,
        .chat-option {
            pointer-events: auto !important;
        }

        .marker.miss::after {
            content: 'üåä';
            font-size: 20px;
            opacity: 0.7;
        }

        .marker.hit::after {
            content: 'üí•';
        }

        .marker.sunk-fire {
            animation: burn 0.5s infinite alternate;
            color: #ef4444;
            /* Force red/orange color if text */
            text-shadow: 0 0 5px #ef4444, 0 0 10px #fbbf24;
        }

        @keyframes burn {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.2);
            }
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            60% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .shake-element {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }



        .marker.hit-anim {
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .marker.miss-anim {
            animation: popIn 0.4s ease forwards;
        }

        /* --- CUSTOM SHIP EDITOR --- */
        .editor-grid {
            display: grid;
            grid-template-columns: repeat(6, 40px);
            grid-template-rows: repeat(6, 40px);
            gap: 2px;
            background: #0f172a;
            padding: 10px;
            border: 2px solid #334155;
            border-radius: 8px;
            margin: 20px auto;
        }

        .editor-cell {
            width: 40px;
            height: 40px;
            background: #1e293b;
            border: 1px solid #334155;
            cursor: pointer;
            transition: all 0.2s;
        }

        .editor-cell.active {
            background: #3b82f6;
            /* Blue for selected */
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            border-color: #60a5fa;
        }

        /* Update Ship Visuals to be specialized Grids */
        .ship-matrix-container {
            display: grid;
            gap: 1px;
            touch-action: none;
            /* Crucial for drag */
            position: relative;
        }

        .matrix-cell {
            width: 100%;
            height: 100%;
            background-color: #94a3b8;
            border: 1px solid #475569;
            box-sizing: border-box;
        }

        .ship-visual {
            /* Now just a wrapper for the matrix */
            background: transparent;
            display: inline-block;
        }

        .ship-visual.dragging .matrix-cell {
            background-color: #3b82f6;
            opacity: 0.8;
            box-shadow: 0 0 15px #3b82f6;
        }

        .ship-visual.error .matrix-cell {
            background-color: #ef4444 !important;
        }

        /* --- DYNAMIC TURN LAYOUT --- */
        .game-layout.defending #section-fleet {
            order: -1;
            /* Move My Fleet to Top */
        }

        /* Optional: Move Radar to bottom explicitly to be safe */
        .game-layout.defending #section-radar {
            order: 1;
        }

        /* --- SWAP ANIMATION --- */
        .board-section {
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 1;
            transform: scale(1);
        }

        .game-layout.anim-swap .board-section {
            opacity: 0;
            transform: scale(0.95);
        }

        /* --- LAST MOVE HIGHLIGHT --- */
        .marker.last-move {
            border: 2px solid #fbbf24;
            box-shadow: 0 0 15px #fbbf24;
            z-index: 30;
        }

        /* --- CHAT UI --- */
        #chat-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #22c55e;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #quick-chat-overlay {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 200px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .chat-option {
            background: #0f172a;
            color: #94a3b8;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: background 0.2s;
        }

        .chat-option:hover {
            background: #334155;
            color: white;
        }

        #chat-toast {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #22c55e;
            padding: 15px 25px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: bold;
            border: 2px solid #22c55e;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }

        #chat-toast.show {
            opacity: 1;
            transform: translateX(-50%) scale(1.1);
        }
    </style>
</head>

<body>

    <!-- SCREEN: MENU -->
    <div id="screen-menu" class="screen">
        <h1>BATALLA NAVAL</h1>
        <p style="color:#64748b; font-size:0.9rem; margin-bottom:30px;">Comandante de Flota P2P</p>
        <button class="btn" onclick="toConfig()">Crear Flota</button>
        <button class="btn" onclick="toJoin()">Unirse</button>
        <button class="btn secondary" onclick="window.location.href='https://omarsaez.github.io/ArcadeDeJuegos/'"
            style="margin-top:20px;">Volver al Arcade</button>
    </div>

    <!-- SCREEN: CONFIG HOST -->
    <div id="screen-config" class="screen hidden">
        <h2>CONFIGURAR BATALLA</h2>
        <div class="config-panel">
            <h3 style="margin-top:10px; font-size:1rem;">Terreno</h3>
            <div style="display:flex; justify-content:center; align-items:center; gap:10px; margin:10px 0;">
                <button class="btn secondary small" onclick="changeGridSize(-1)">-</button>
                <span id="cfg-grid-size" style="font-size:1.5rem; font-weight:bold;">10</span>
                <span>x</span>
                <span id="cfg-grid-size-2" style="font-size:1.5rem; font-weight:bold;">10</span>
                <button class="btn secondary small" onclick="changeGridSize(1)">+</button>
            </div>

            <h3 style="margin-top:20px; font-size:1rem;">Flota</h3>
            <div id="fleet-config-list" style="max-height: 250px; overflow-y: auto;">
                <!-- Dynamically filled -->
            </div>

            <!-- Standard Quick Add -->
            <div style="margin-top:10px; border-top:1px solid #334155; padding-top:10px;">
                <label style="font-size:0.8rem; color:#94a3b8;">A√±adir Est√°ndar:</label>
                <div style="display:flex; gap:5px; margin-top:5px; flex-wrap:wrap;">
                    <button class="btn small secondary" onclick="addStandardShip(1)">1Ô∏è‚É£</button>
                    <button class="btn small secondary" onclick="addStandardShip(2)">2Ô∏è‚É£</button>
                    <button class="btn small secondary" onclick="addStandardShip(3)">3Ô∏è‚É£</button>
                    <button class="btn small secondary" onclick="addStandardShip(4)">4Ô∏è‚É£</button>
                    <button class="btn small secondary" onclick="addStandardShip(5)">5Ô∏è‚É£</button>
                </div>
            </div>

            <!-- Custom Creator -->
            <div style="margin-top:10px;">
                <button class="btn small style-accent" style="width:100%;" onclick="openShipCreator()">üõ†Ô∏è Dise√±ar
                    Especial</button>
            </div>
        </div>
        <div style="margin-top:20px;">
            <button class="btn" onclick="startHost()">üì° Iniciar Sala</button>
            <button class="btn secondary" onclick="location.reload()">Cancelar</button>
        </div>
    </div>

    <!-- SCREEN: SHIP CREATOR MODAL -->
    <div id="screen-creator" class="screen hidden" style="background: rgba(0,0,0,0.95); z-index: 5000;">
        <h2>DISE√ëADOR DE NAV√çOS</h2>
        <p style="font-size:0.9rem; color:#94a3b8; max-width:400px; text-align:center;">
            Dibuja tu barco en la cuadr√≠cula de 6x6.<br>Las piezas deben estar conectadas.
        </p>

        <div id="creator-grid" class="editor-grid">
            <!-- 36 Cells generated by JS -->
        </div>

        <div style="display:flex; gap:10px;">
            <button class="btn secondary" onclick="clearCreatorGrid()">Limpiar</button>
            <button class="btn" onclick="saveCustomShip()">Guardar Dise√±o</button>
        </div>
        <button class="btn secondary" style="margin-top:20px;" onclick="closeShipCreator()">Cancelar</button>
    </div>

    <!-- SCREEN: JOIN -->
    <div id="screen-join" class="screen hidden">
        <h2>UNIRSE</h2>
        <input type="text" id="join-code" placeholder="C√ìDIGO DE SALA" style="margin:20px 0; text-transform:uppercase;">
        <button class="btn" onclick="connectToHost()">Conectar</button>
        <button class="btn secondary" onclick="location.reload()">Atr√°s</button>
    </div>

    <!-- SCREEN: LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <p>C√ìDIGO DE SALA:</p>
        <h1 id="lobby-code" style="font-size:3rem; margin:10px 0; user-select:text;">...</h1>
        <p class="animate-pulse">Esperando conexi√≥n del rival...</p>
        <button class="btn secondary" onclick="location.reload()">Cancelar</button>
    </div>

    <!-- SCREEN: SETUP (PLACEMENT) -->
    <div id="screen-setup" class="screen hidden" style="justify-content: flex-start; padding: 0;">
        <div
            style="width:100%; background:#1e293b; padding:5px 10px; display:flex; justify-content:space-between; align-items:center; z-index:200;">
            <span style="font-size:1rem; margin-left:7px;">Coloca tus barcos en el mapa</span>
            <div>
                <button id="btn-rotate" class="btn secondary" disabled onclick="rotateSelected()"
                    style="font-size: 1.1rem; padding: 8px 16px;">üîÑ ROTAR</button>
                <button id="btn-ready" class="btn hidden" onclick="finalizeSetup()"
                    style="font-size: 1.1rem; padding: 8px 16px;">‚úÖ LISTO</button>
            </div>
        </div>

        <div id="setup-area"
            style="flex:1; width:100%; position:relative; overflow:hidden; display:flex; flex-direction:column; justify-content:flex-start; align-items:center; padding-top: 20px; background:#0f172a;">
            <div id="setup-board" class="board-wrapper">
                <div class="grid-layer" id="setup-grid"></div>
                <div class="ship-layer" id="setup-ships"></div>
            </div>

            <div id="inventory-container">
                <!-- Draggable originals go here -->
            </div>
        </div>
    </div>

    <!-- SCREEN: WAIT -->
    <div id="screen-wait" class="screen hidden">
        <h2>FLOTA LISTA</h2>
        <p class="animate-pulse">Esperando a que el rival termine de posicionar...</p>
    </div>

    <!-- SCREEN: GAME -->
    <div id="screen-game" class="screen hidden" style="justify-content: flex-start;">
        <div class="control-bar">
            <div>
                <span id="turn-badge"
                    style="background:#22c55e; color:black; padding:2px 6px; border-radius:4px; font-weight:bold; display:none;">TU
                    TURNO</span>
                <span id="turn-timer"
                    style="color:#ffffff; font-weight:bold; margin-left:5px; display:none; transition: all 0.2s ease;">30s</span>
                <span id="wait-badge" style="color:#94a3b8; font-size:0.9rem;">Esperando...</span>
            </div>
            <div style="font-size:0.8rem;">
                <span id="game-info"></span>
            </div>
        </div>

        <div class="game-layout">
            <!-- ENEMY MAP (RADAR) -->
            <div id="section-radar" class="board-section">
                <span style="margin-bottom:5px; color:#ef4444; font-weight:bold;">RADAR (ENEMIGO)</span>
                <div id="enemy-board" class="board-wrapper">
                    <div class="grid-layer" id="enemy-grid"></div>
                    <div class="marker-layer" id="enemy-markers"></div>
                </div>
            </div>

            <!-- ENEMY STATUS (MIDDLE - SCROLLABLE) -->
            <div id="enemy-fleet-panel">
                <!-- List of enemy ships -->
            </div>

            <!-- MY MAP (BOTTOM) -->
            <div id="section-fleet" class="board-section" style="opacity:0.9;">
                <span style="margin-bottom:5px; color:#3b82f6; font-weight:bold;">MI FLOTA</span>
                <div id="my-board" class="board-wrapper" style="pointer-events:none;">
                    <div class="grid-layer" id="my-grid"></div>
                    <div class="ship-layer" id="my-final-ships"></div>
                    <div class="marker-layer" id="my-markers"></div>
                </div>
            </div>
        </div>

        <!-- CHAT ELEMENTS -->
        <button id="chat-btn" onclick="toggleChat()">üí¨</button>

        <div id="quick-chat-overlay" class="hidden">
            <div class="chat-option" onclick="sendChat('¬°Buena Jugada! üòé')">¬°Buena Jugada! üòé</div>
            <div class="chat-option" onclick="sendChat('¬°Buena Partida! ÔøΩ')">¬°Buena Partida! ÔøΩ</div>
            <div class="chat-option" onclick="sendChat('¬°Qu√© suerte! üçÄ')">¬°Qu√© suerte! üçÄ</div>
            <div class="chat-option" onclick="sendChat('¬°Jaja! üòÇ')">¬°Jaja! üòÇ</div>
            <div class="chat-option" onclick="sendChat('¬øViste esa jugada? üî•')">¬øViste esa jugada? üî•</div>
            <div class="chat-option" onclick="sendChat('¬°Mira y aprende! üéì')">¬°Mira y aprende! üéì</div>
            <div class="chat-option" onclick="sendChat('¬°No la viste venir! üëª')">¬°No la viste venir! üëª</div>
            <div class="chat-option" onclick="sendChat('üíÄüíÄüíÄ')">üíÄüíÄüíÄ</div>
        </div>

        <div id="chat-toast">MENSAJE</div>

    </div>
    </div>

    <!-- SCREEN: RESULT -->
    <div id="screen-result" class="screen hidden" style="z-index: 2000; background: rgba(15, 23, 42, 0.95);">
        <h1 id="result-title" style="font-size: 4rem; margin-bottom: 20px;">VICTORIA</h1>
        <div class="stats-grid"
            style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; text-align: center; margin-bottom: 30px;">
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                <h3 style="margin:0; font-size: 1rem; color: #94a3b8;">Precisi√≥n</h3>
                <span id="stat-accuracy"
                    style="font-size: 2rem; font-weight: bold; color: var(--radar-green);">0%</span>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                <h3 style="margin:0; font-size: 1rem; color: #94a3b8;">Hundidos</h3>
                <span id="stat-sunk" style="font-size: 2rem; font-weight: bold; color: #ef4444;">0/0</span>
            </div>
        </div>
        <div style="color: #cbd5e1; margin-bottom: 20px;">
            <p>Disparos Totales: <span id="stat-shots">0</span></p>
            <p>Aciertos: <span id="stat-hits">0</span></p>
        </div>
        <div style="margin-top:20px;">
            <button class="btn" onclick="location.reload()">Jugar de Nuevo</button>
            <button class="btn secondary" onclick="window.location.href='../../index.html'">Volver al Arcade</button>
        </div>
    </div>

    <script>
        // --- DATA & STATE ---
        let gridSize = 10;
        // NEW CONFIG: each item has a 'matrix' (2D array of 0/1) instead of just Size
        let fleetConfig = [
            { matrix: [[1], [1], [1], [1], [1]], count: 1 }, // 5 Size Linear
            { matrix: [[1], [1], [1], [1]], count: 1 },    // 4 Size
            { matrix: [[1], [1], [1]], count: 2 },         // 3 Size
            { matrix: [[1], [1]], count: 2 }              // 2 Size
        ];

        let peer, conn, isHost = false;
        let myShips = []; // {id, matrix, x, y, hits:Set("x,y")}
        let enemyShipsList = []; // {id, matrix, sunk:false}
        let placedShips = [];
        let isSetupReady = false;
        let myTurn = false;
        let inputLocked = false;
        let selectedShipRef = null;
        let turnTimerInterval = null;
        let timeLeft = 30;

        // Stats
        let myStats = { shots: 0, hits: 0, sunk: 0 };
        let enemyStats = { shots: 0, hits: 0, sunk: 0 };

        let creatorMatrix = Array(6).fill(0).map(() => Array(6).fill(0));

        const TILE_SIZE_BASE = 35;
        let tileSize = TILE_SIZE_BASE;

        // --- NAVIGATION ---
        function show(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }
        function toConfig() { show('screen-config'); renderFleetConfig(); }
        function toJoin() { show('screen-join'); }

        // --- SHIP CREATOR LOGIC ---
        function openShipCreator() {
            document.getElementById('screen-creator').classList.remove('hidden');
            clearCreatorGrid();
        }

        function closeShipCreator() {
            document.getElementById('screen-creator').classList.add('hidden');
        }

        function clearCreatorGrid() {
            creatorMatrix = Array(6).fill(0).map(() => Array(6).fill(0));
            renderCreatorGrid();
        }

        function renderCreatorGrid() {
            const grid = document.getElementById('creator-grid');
            grid.innerHTML = '';
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    const cell = document.createElement('div');
                    cell.className = `editor-cell ${creatorMatrix[r][c] ? 'active' : ''}`;
                    cell.onclick = () => toggleCreatorCell(r, c);
                    grid.appendChild(cell);
                }
            }
        }

        function toggleCreatorCell(r, c) {
            creatorMatrix[r][c] = creatorMatrix[r][c] ? 0 : 1;
            renderCreatorGrid();
        }

        function saveCustomShip() {
            let minR = 6, maxR = -1, minC = 6, maxC = -1;
            let count = 0;
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    if (creatorMatrix[r][c]) {
                        count++;
                        if (r < minR) minR = r; if (r > maxR) maxR = r;
                        if (c < minC) minC = c; if (c > maxC) maxC = c;
                    }
                }
            }

            if (count === 0) { alert("!Debes dibujar algo!"); return; }

            const cropped = [];
            for (let r = minR; r <= maxR; r++) {
                const row = [];
                for (let c = minC; c <= maxC; c++) {
                    row.push(creatorMatrix[r][c]);
                }
                cropped.push(row);
            }

            if (!checkConnectivity(cropped, count)) {
                alert("El barco debe ser una pieza solida (todo conectado).");
                return;
            }

            fleetConfig.push({ matrix: cropped, count: 1 });
            renderFleetConfig();
            closeShipCreator();
        }

        function checkConnectivity(matrix, targetCount) {
            const R = matrix.length;
            const C = matrix[0].length;
            const visited = Array(R).fill(0).map(() => Array(C).fill(false));
            let startNode = null;

            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    if (matrix[r][c] === 1) { startNode = { r, c }; break; }
                }
                if (startNode) break;
            }

            let q = [startNode];
            visited[startNode.r][startNode.c] = true;
            let found = 0;

            while (q.length > 0) {
                const { r, c } = q.shift();
                found++;
                [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => {
                    const nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && matrix[nr][nc] === 1) {
                        visited[nr][nc] = true;
                        q.push({ r: nr, c: nc });
                    }
                });
            }
            return found === targetCount;
        }

        function changeGridSize(delta) {
            gridSize += delta;
            if (gridSize < 7) gridSize = 7;
            if (gridSize > 20) gridSize = 20;
            document.getElementById('cfg-grid-size').innerText = gridSize;
            document.getElementById('cfg-grid-size-2').innerText = gridSize;
        }

        // --- CONFIG UI RENDERING ---
        function renderFleetConfig() {
            const container = document.getElementById('fleet-config-list');
            container.innerHTML = '';

            fleetConfig.forEach((cfg, index) => {
                const row = document.createElement('div');
                row.className = 'config-row';
                row.style.background = '#1e293b';
                row.style.padding = '8px';
                row.style.marginBottom = '8px';
                row.style.borderRadius = '6px';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.justifyContent = 'space-between';

                // Matrix Visual
                // If matrix is missing (legacy data), fallback or skip
                if (!cfg.matrix) return;

                const visual = generateMatrixVisual(cfg.matrix, 15);

                const leftCol = document.createElement('div');
                leftCol.style.display = 'flex';
                leftCol.style.alignItems = 'center';
                leftCol.appendChild(visual);

                // Add size count label
                let blockCount = 0;
                cfg.matrix.forEach(r => r.forEach(c => blockCount += c));
                const sizeBadge = document.createElement('span');
                sizeBadge.innerText = `${blockCount} blq`;
                sizeBadge.style.fontSize = '10px';
                sizeBadge.style.color = '#64748b';
                sizeBadge.style.marginLeft = '8px';
                leftCol.appendChild(sizeBadge);

                // Controls
                const controls = document.createElement('div');
                controls.style.display = 'flex';
                controls.style.alignItems = 'center';
                controls.style.gap = '10px';
                controls.innerHTML = `
                    <button class="btn secondary small" onclick="updateShipCount(${index}, -1)">-</button>
                    <span style="font-weight:bold; min-width:20px; text-align:center;">${cfg.count}</span>
                    <button class="btn secondary small" onclick="updateShipCount(${index}, 1)">+</button>
                    <button class="btn danger small" onclick="removeShipType(${index})">üóëÔ∏è</button>
                `;

                row.appendChild(leftCol);
                row.appendChild(controls);
                container.appendChild(row);
            });

            // Re-inject the "Add Buttons" area at the bottom of the list or outside?
            // Let's modify the HTML structure instead of injecting buttons here.
        }

        function generateMatrixVisual(matrix, blockSize = 20) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const wrapper = document.createElement('div');
            wrapper.style.display = 'grid';
            wrapper.style.gridTemplateColumns = `repeat(${cols}, ${blockSize}px)`;
            wrapper.style.gridTemplateRows = `repeat(${rows}, ${blockSize}px)`;
            wrapper.style.gap = '1px';

            // Limit max visual size to prevent UI overflow for big ships
            // wrapper.style.maxHeight = '60px'; 
            // wrapper.style.overflow = 'hidden';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    if (matrix[r][c] === 1) {
                        cell.style.background = '#94a3b8';
                        cell.style.border = '1px solid #475569';
                        cell.style.width = '100%';
                        cell.style.height = '100%';
                    }
                    wrapper.appendChild(cell);
                }
            }
            return wrapper;
        }

        // --- ADD STANDARD SHIPS ---
        function addStandardShip(size) {
            // Create linear matrix
            const matrix = [];
            for (let i = 0; i < size; i++) matrix.push([1]); // Vertical stack by default (or horizontal [[1,1,1]])?
            // Let's make them horizontal [[1,1,1...]] as it looks better in list
            const horizMatrix = [Array(size).fill(1)];

            // Check if already exists exactly
            // Simple JSON stringify compare for now
            const json = JSON.stringify(horizMatrix);
            const existingIdx = fleetConfig.findIndex(c => JSON.stringify(c.matrix) === json);

            if (existingIdx >= 0) {
                fleetConfig[existingIdx].count++;
            } else {
                fleetConfig.push({ matrix: horizMatrix, count: 1 });
            }
            renderFleetConfig();
        }

        function updateShipCount(idx, delta) {
            fleetConfig[idx].count += delta;
            if (fleetConfig[idx].count < 1) fleetConfig[idx].count = 0; // Allow 0, user can delete
            renderFleetConfig();
        }

        function removeShipType(idx) {
            fleetConfig.splice(idx, 1);
            renderFleetConfig();
        }
        // --- END CONFIG ---
        function addShipConfig() {
            const s = parseInt(document.getElementById('new-ship-size').value);
            // Check if exists
            const ex = fleetConfig.find(c => c.size === s);
            if (ex) ex.count++;
            else fleetConfig.push({ size: s, count: 1 });
            fleetConfig.sort((a, b) => b.size - a.size);
            renderConfigList();
        }

        // --- P2P CONNECTION ---
        // --- P2P CONNECTION (Dual Protocol) ---


        function initPeer() {
            const shortId = Math.random().toString(36).substring(2, 6).toUpperCase();
            peer = new Peer(shortId);

            peer.on('open', (id) => {
                console.log("Peer Open:", id);
                isHost = true;
                show('screen-lobby');
                document.getElementById('lobby-code').innerText = id;
            });

            peer.on('connection', (c) => {
                handleConnection(c);
            });

            peer.on('error', (err) => {
                console.error("Peer Error:", err);
                alert("Error P2P: " + err);
            });
        }

        function joinGame() {
            const code = document.getElementById('join-code').value.toUpperCase();
            if (!code) return;
            isHost = false;

            peer = new Peer();
            peer.on('open', () => {
                const c = peer.connect(code);
                handleConnection(c);
            });
            peer.on('error', (err) => alert("Error P2P: " + err));
        }

        function handleConnection(c) {
            conn = c;

            conn.on('open', () => {
                console.log("Conectado con:", conn.peer);
                if (isHost) {
                    // Send Config
                    conn.send({ type: 'INIT', gridSize, fleetConfig });
                    beginSetup();
                }
            });

            conn.on('data', data => {
                switch (data.type) {
                    case 'INIT':
                        gridSize = data.gridSize;
                        fleetConfig = data.fleetConfig;
                        beginSetup();
                        break;
                    case 'READY_FLEET':
                        enemyShipsList = data.fleet;
                        checkStartGame();
                        break;
                    case 'SHOT':
                        handleReceiveShot(data.x, data.y);
                        break;
                    case 'SHOT_RESULT':
                        handleShotResult(data.x, data.y, data.hit, data.sunkId, data.sunkCoords);
                        break;
                        // Handle Remote Game Over?
                        // Or just standard interactions.
                        break;
                    case 'CHAT':
                        showChatMessage(data.msg);
                        break;
                }
            });

            conn.on('close', () => alert("Rival desconectado"));
            conn.on('error', (err) => console.error("Conn Error:", err));
        }

        // Bridges for HTML calling
        function startHost() { initPeer(); }
        function connectToHost() { joinGame(); }

        // --- SETUP PHASE (PLACEMENT) ---
        function beginSetup() {
            show('screen-setup');

            // Ensure Grid Size is standard if not set
            if (!gridSize || gridSize < 7) gridSize = 10;

            const area = document.getElementById('setup-area');
            // Calculate Max Width considering Screen Padding (10px * 2 = 20px) + Safety (5px)
            const marginSafety = 25;
            const maxW = Math.min(window.innerWidth - marginSafety, 500);
            const maxH = (window.innerHeight - 180) * 0.95;
            const limit = Math.min(maxW, maxH);

            // Calculate Tile Size
            tileSize = Math.floor(limit / gridSize);

            const board = document.getElementById('setup-board');
            const totalSize = tileSize * gridSize;

            board.style.width = `${totalSize}px`;
            board.style.height = `${totalSize}px`;
            board.style.flex = "0 0 auto";

            const grid = document.getElementById('setup-grid');
            // FIX: Explicitly set background size string with 'px'
            grid.style.backgroundSize = `${tileSize}px ${tileSize}px`;
            grid.style.backgroundImage = `
                linear-gradient(to right, #334155 1px, transparent 1px),
                linear-gradient(to bottom, #334155 1px, transparent 1px)
            `;
            // Add Border to whole grid
            grid.style.borderTop = '1px solid #334155';
            grid.style.borderLeft = '1px solid #334155';
            grid.style.borderRight = '1px solid #334155';
            grid.style.borderBottom = '1px solid #334155';

            placedShips = [];
            while (board.querySelector('.ship-visual')) board.querySelector('.ship-visual').remove();

            const inv = document.getElementById('inventory-container');
            inv.innerHTML = '';

            let shipIdCounter = 0;
            let currentX = 10; // Start padding
            fleetConfig.forEach(cfg => {
                for (let i = 0; i < cfg.count; i++) {
                    // Deep copy matrix
                    const m = JSON.parse(JSON.stringify(cfg.matrix));
                    const widthPx = m[0].length * 35; // Approx width (30px size + margin) 

                    createInteractableShip(inv, m, `ship_${shipIdCounter++}`, currentX);
                    currentX += widthPx + 20; // Add width + spacing
                }
            });
            checkSetupReady();
        }

        function createInteractableShip(container, matrix, id, startX) {
            const el = document.createElement('div');
            el.className = 'ship-visual';
            el.dataset.id = id;
            el.matrix = matrix;

            updateShipVisual(el, matrix, 30);

            el.dataset.location = 'inventory';

            // Initial Absolute Position
            el.style.position = 'absolute';
            el.style.left = `${startX}px`;
            el.style.top = '10px'; // Centered-ish vertically or top aligned with padding
            el.style.zIndex = '10';

            container.appendChild(el);

            setupDrag(el);
            el.addEventListener('pointerdown', (e) => selectShip(e, el));
        }

        function updateShipVisual(el, matrix, sizePx) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            el.innerHTML = '';
            el.style.display = 'grid';
            el.style.gridTemplateColumns = `repeat(${cols}, ${sizePx}px)`;
            el.style.gridTemplateRows = `repeat(${rows}, ${sizePx}px)`;
            el.style.width = `${cols * sizePx}px`;
            el.style.height = `${rows * sizePx}px`;
            el.style.gap = '0px';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    if (matrix[r][c] === 1) {
                        // Visible block
                    } else {
                        cell.style.opacity = '0';
                        cell.style.border = 'none';
                        cell.style.background = 'none';
                    }
                    el.appendChild(cell);
                }
            }
        }

        function rotateSelected() {
            if (!selectedShipRef) return;
            const el = selectedShipRef;

            // Transpose + Reverse Row (Rotate 90deg)
            const oldM = el.matrix;
            const R = oldM.length, C = oldM[0].length;
            const newM = Array(C).fill(0).map(() => Array(R).fill(0));

            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    newM[c][R - 1 - r] = oldM[r][c];
                }
            }

            // Logic based on location
            if (el.dataset.location === 'board') {
                const gx = parseInt(el.dataset.gx);
                const gy = parseInt(el.dataset.gy);

                if (validatePlacementMatrix(gx, gy, newM, el.dataset.id)) {
                    el.matrix = newM;
                    updateShipVisual(el, newM, tileSize);
                    placeShipOnBoard(el, gx, gy, newM, el.dataset.id);
                } else {
                    el.classList.add('error');
                    setTimeout(() => el.classList.remove('error'), 200);
                }
            } else {
                // Inventory Rotation
                el.matrix = newM;
                updateShipVisual(el, newM, 30); // 30 is inventory size
            }
        }

        // --- DRAG & DROP (MATRIX SUPPORT) ---
        let dragEl = null;
        let originData = null;

        function selectShip(e, el) {
            if (selectedShipRef) selectedShipRef.classList.remove('selected');
            selectedShipRef = el;
            el.classList.add('selected');
            document.getElementById('btn-rotate').disabled = false; // Always allow rotate
        }

        function setupDrag(el) {
            el.addEventListener('pointerdown', startDrag);
        }

        function startDrag(e) {
            dragEl = this;
            if (dragEl.dataset.locked === 'true') return;
            selectShip(e, dragEl);

            const rect = dragEl.getBoundingClientRect();

            // Calculate relative offset ratio to preserve grab point across resize
            const ratioX = (e.clientX - rect.left) / rect.width;
            const ratioY = (e.clientY - rect.top) / rect.height;

            originData = {
                parent: dragEl.parentElement,
                location: dragEl.dataset.location,
                shipObj: dragEl.dataset.location === 'board' ?
                    placedShips.find(s => s.id === dragEl.dataset.id) : null,
                originalWidth: rect.width, // Backup for inventory restoration
                ratioX: ratioX,
                ratioY: ratioY
            };

            // Force resize to Board TileSize immediately for accurate visual
            updateShipVisual(dragEl, dragEl.matrix, tileSize);

            // Re-calc offset based on NEW size
            const newW = dragEl.scrollWidth; // or clientWidth
            const newH = dragEl.scrollHeight;

            const realOffsetX = newW * ratioX;
            const realOffsetY = newH * ratioY;

            originData.offsetX = realOffsetX;
            originData.offsetY = realOffsetY;

            dragEl.style.position = 'fixed';
            dragEl.style.zIndex = 1000;
            dragEl.style.left = (e.clientX - realOffsetX) + 'px';
            dragEl.style.top = (e.clientY - realOffsetY) + 'px';
            document.body.appendChild(dragEl);

            dragEl.setPointerCapture(e.pointerId);
            dragEl.classList.add('dragging');
            dragEl.addEventListener('pointermove', moveDrag);
            dragEl.addEventListener('pointerup', endDrag);
        }

        function moveDrag(e) {
            if (!dragEl) return;
            e.preventDefault();
            dragEl.style.left = (e.clientX - originData.offsetX) + 'px';
            dragEl.style.top = (e.clientY - originData.offsetY) + 'px';
        }

        function endDrag(e) {
            if (!dragEl) return;
            dragEl.classList.remove('dragging');
            dragEl.removeEventListener('pointermove', moveDrag);
            dragEl.removeEventListener('pointerup', endDrag);
            dragEl.releasePointerCapture(e.pointerId);

            const rect = dragEl.getBoundingClientRect();
            const board = document.getElementById('setup-board');
            const bRect = board.getBoundingClientRect();

            // Check center point or just strict overlap? 
            // Let's use Top-Left + minimal tolerance
            // Ideally we want to map the Top-Left of the ship to grid

            // Calculate tentative grid pos
            const gx = Math.round((rect.left - bRect.left) / tileSize);
            const gy = Math.round((rect.top - bRect.top) / tileSize);

            if (rect.left + 10 > bRect.left && rect.right - 10 < bRect.right &&
                rect.top + 10 > bRect.top && rect.bottom - 10 < bRect.bottom) {

                // It is largely inside the board area
                if (validatePlacementMatrix(gx, gy, dragEl.matrix, dragEl.dataset.id)) {
                    placeShipOnBoard(dragEl, gx, gy, dragEl.matrix, dragEl.dataset.id);
                    return;
                }
            }

            // Check Drop on Inventory
            const inv = document.getElementById('inventory-container');
            const iRect = inv.getBoundingClientRect();
            if (rect.right > iRect.left && rect.left < iRect.right &&
                rect.bottom > iRect.top && rect.top < iRect.bottom) {

                // Calculate relative position within inventory
                const relX = rect.left - iRect.left;
                const relY = rect.top - iRect.top;

                moveToInventory(dragEl, relX + inv.scrollLeft, relY);
                return;
            }

            // --- RECOVERY LOGIC ---
            // If we are here, we are NOT on the board and NOT in the inventory.
            // But getting strict "hit" on inventory is hard if we just dropped it "near" or "in" the general table area.
            // As per user request: "Everything is a table except the board".
            // So if it's NOT on the board, it should go to inventory/table logic, BUT we must ensure coords are safe.

            // Let's assume if it is NOT on the board, we try to put it in the inventory (table).
            // But we need to calculate where it is relative to the inventory container to keep it there.
            // If it is completely off screen, then Return To Origin.

            // Note: inv and iRect are already defined above.

            // Calculate position relative to Inventory Container
            // We treat the inventory container as the "reference frame" for the 'Table'.
            // Even if we drop it above the inventory, we can map it.
            let tableX = rect.left - iRect.left + inv.scrollLeft;
            let tableY = rect.top - iRect.top;

            // Simple Safety Check: Is it at least partially visible on screen?
            if (rect.right < 0 || rect.left > window.innerWidth || rect.bottom < 0 || rect.top > window.innerHeight) {
                returnToOrigin();
                return;
            }

            // If it's not on board, move to inventory with absolute coords
            moveToInventory(dragEl, tableX, tableY);

            returnToOrigin();
        }

        function moveToInventory(el, x = 0, y = 0) {
            // Remove from board logic
            placedShips = placedShips.filter(s => s.id !== el.dataset.id);

            el.dataset.location = 'inventory';

            // Restore visual
            updateShipVisual(el, el.matrix, 30);

            // Free Placement Logic with Constraints
            // Ensure it doesn't vanish.
            const container = document.getElementById('inventory-container');

            // We don't strictly clamp X because scroll is allowed, but we should clamp Y to not be super far off.
            // And maybe clamp X to min 0.
            if (x < 0) x = 0;
            if (y < -300) y = -300; // Arbitrary top limit (visual sanity)
            // Actually, if we want it to be "in the inventory area", y should be somewhat bounded.
            // But user wants "the whole area is a table".
            // The issue is if they drop it WAY up, `inventory-container` with `overflow: visible` (or hidden) might cut it off?
            // `inventory-container` has `overflow-x: auto` and fixed height 120px. 
            // If we place it absolute at y = -200, it might be invisible if container clips Y.
            // Container styles: `height: 120px; overflow-x: auto;`.
            // Usually `overflow-x: auto` implies `overflow-y: hidden` or auto.
            // If we want "Whole Screen" table effect, the inventory container is not the best parent.
            // BUT re-architecting to a global layer is complex.
            // WORKAROUND: Clamp Y to be inside the inventory strip (0 to ~80).
            // This forces the "Table" to be just the bottom strip.
            // If user wants "Gray Zone" (everything else), we can't easily parent it to inventory which is a small scrolling strip.
            // Compelling compromise: If dropped outside board, snap to Inventory Box, but keep X. Clamp Y.

            if (y < 0) y = 0;
            if (y > 80) y = 80; // Keep roughly in strip

            el.style.position = 'absolute';
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.zIndex = '';
            el.style.margin = '0';

            container.appendChild(el);

            // Clean up empty wrappers if any
            document.querySelectorAll('.inventory-item').forEach(item => {
                if (item.children.length === 0) item.remove();
            });

            selectShip(null, el);
            checkSetupReady();
            dragEl = null;
        }

        function returnToOrigin() {
            dragEl.style.position = 'relative';
            dragEl.style.left = '0';
            dragEl.style.top = '0';
            dragEl.style.zIndex = '';

            if (originData.location === 'inventory') {
                // Restore Inventory Appearance (Size 30)
                updateShipVisual(dragEl, dragEl.matrix, 30);
                originData.parent.appendChild(dragEl);
            } else {
                const s = originData.shipObj;
                // It was on board, so it stays Board Size
                placeShipOnBoard(dragEl, s.gx, s.gy, s.matrix, s.id);
            }
            dragEl = null;
        }

        function validatePlacementMatrix(gx, gy, matrix, ignoreId) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            if (gx < 0 || gy < 0 || gx + cols > gridSize || gy + rows > gridSize) return false;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (matrix[r][c] === 1) {
                        for (const ship of placedShips) {
                            if (ship.id === ignoreId) continue;
                            if (isPointInShip(gx + c, gy + r, ship)) return false;
                        }
                    }
                }
            }
            return true;
        }

        function isPointInShip(x, y, ship) {
            const relX = x - ship.gx;
            const relY = y - ship.gy;
            if (relY >= 0 && relY < ship.matrix.length && relX >= 0 && relX < ship.matrix[0].length) {
                return ship.matrix[relY][relX] === 1;
            }
            return false;
        }

        function placeShipOnBoard(el, gx, gy, matrix, id) {
            placedShips = placedShips.filter(s => s.id !== id);

            placedShips.push({ id, gx, gy, matrix });

            const board = document.getElementById('setup-board');
            el.dataset.location = 'board';
            el.dataset.gx = gx;
            el.dataset.gy = gy;

            updateShipVisual(el, matrix, tileSize);

            el.style.position = 'absolute';
            el.style.left = (gx * tileSize) + 'px';
            el.style.top = (gy * tileSize) + 'px';
            el.style.zIndex = 10;
            board.appendChild(el);

            document.getElementById('btn-rotate').disabled = false;
            selectShip(null, el); // Reactivate select
            dragEl = null;

            checkSetupReady();
        }

        function checkSetupReady() {
            const totalShips = fleetConfig.reduce((acc, c) => acc + c.count, 0);
            if (placedShips.length === totalShips) {
                document.getElementById('btn-ready').classList.remove('hidden');
            } else {
                document.getElementById('btn-ready').classList.add('hidden');
            }
        }

        function finalizeSetup() {
            show('screen-wait');
            isSetupReady = true;

            const myFleetData = placedShips.map(s => ({
                id: s.id,
                matrix: s.matrix,
                gx: s.gx, // Ensure we send gx/gy for consistency if needed, but fleetData uses x,y usually
                gy: s.gy
            }));

            // Generate My Ships Logic Objects
            myShips = placedShips.map(s => ({
                id: s.id,
                matrix: s.matrix,
                x: s.gx,
                y: s.gy,
                hits: new Set()
            }));

            conn.send({ type: 'READY_FLEET', fleet: myFleetData });
            checkStartGame();
        }

        function checkStartGame() {
            if (isSetupReady && enemyShipsList && enemyShipsList.length > 0) {
                startGame();
            }
        }

        function startGame() {
            show('screen-game');
            initGameUI();
            renderEnemyFleetPanel();

            // Turn Logic: Host starts
            myTurn = isHost;
            updateTurnUI();
        }

        // --- GAME PLAY LOGIC ---
        function initGameUI() {
            // Setup Enemy Board
            const eBoard = document.getElementById('enemy-board');
            eBoard.style.width = `${tileSize * gridSize}px`;
            eBoard.style.height = `${tileSize * gridSize}px`;

            const eGrid = document.getElementById('enemy-grid');
            eGrid.style.backgroundSize = `${tileSize}px ${tileSize}px`;
            eGrid.style.backgroundImage = `linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
                                          linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px)`;

            eBoard.onclick = (e) => onEnemyBoardClick(e);

            // Setup My Board (Static)
            const mBoard = document.getElementById('my-board');
            mBoard.style.width = `${tileSize * gridSize}px`;
            mBoard.style.height = `${tileSize * gridSize}px`;

            const mGrid = document.getElementById('my-grid');
            mGrid.style.backgroundSize = `${tileSize}px ${tileSize}px`;
            mGrid.style.backgroundImage = `linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
                                          linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px)`;

            const myContainer = document.getElementById('my-final-ships');
            myContainer.innerHTML = '';

            myShips.forEach(s => {
                const el = document.createElement('div');
                el.className = 'ship-visual';
                updateShipVisual(el, s.matrix, tileSize);
                el.style.position = 'absolute';
                el.style.left = (s.x * tileSize) + 'px';
                el.style.top = (s.y * tileSize) + 'px';
                myContainer.appendChild(el);
            });

            // Reset Stats
            myStats = { shots: 0, hits: 0, sunk: 0 };
            enemyStats = { shots: 0, hits: 0, sunk: 0 };

            renderEnemyFleetPanel();

        }

        function renderEnemyFleetPanel() {
            const panel = document.getElementById('enemy-fleet-panel');
            panel.innerHTML = '';
            enemyShipsList.forEach(s => {
                const card = document.createElement('div');
                card.className = 'enemy-ship-entry';
                card.id = `enemy-manifest-${s.id}`; // FIX: Added ID for lookup
                if (s.sunk) card.classList.add('sunk');

                // Normalize matrix to hide orientation (force horizontal-ish)
                const displayMatrix = normalizeShipMatrix(s.matrix);

                const visual = generateMatrixVisual(displayMatrix, 10); // Small preview
                card.appendChild(visual);
                panel.appendChild(card);
            });
        }

        function normalizeShipMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            // If taller than wide, rotate 90 degrees to make it horizontal
            if (rows > cols) {
                const newM = Array(cols).fill(0).map(() => Array(rows).fill(0));
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        newM[c][rows - 1 - r] = matrix[r][c];
                    }
                }
                return newM;
            }
            return matrix;
        }

        function onEnemyBoardClick(e) {
            if (!myTurn || inputLocked) return;
            const rect = document.getElementById('enemy-board').getBoundingClientRect();
            const bx = Math.floor((e.clientX - rect.left) / tileSize);
            const by = Math.floor((e.clientY - rect.top) / tileSize);

            if (bx < 0 || by < 0 || bx >= gridSize || by >= gridSize) return;

            // Check if already shot using GX/GY
            if (document.querySelector(`#enemy-markers .marker[data-gx="${bx}"][data-gy="${by}"]`)) return;

            sendShot(bx, by);
        }

        function sendShot(bx, by) {
            stopTurnTimer();
            // Optimistic marker
            conn.send({ type: 'SHOT', x: bx, y: by });
            inputLocked = true; // Prevents spam while waiting for result
            updateTurnUI();
        }

        function startTurnTimer() {
            stopTurnTimer();
            timeLeft = 30;
            const timerEl = document.getElementById('turn-timer');
            timerEl.style.display = 'inline-block';
            timerEl.innerText = timeLeft + 's';
            timerEl.style.color = '#ffffff';
            timerEl.style.transform = 'scale(1)';

            turnTimerInterval = setInterval(() => {
                timeLeft--;
                timerEl.innerText = timeLeft + 's';
                if (timeLeft <= 5) {
                    timerEl.style.color = '#ef4444';
                    timerEl.style.transform = 'scale(1.3)';
                } else {
                    timerEl.style.transform = 'scale(1)';
                }

                if (timeLeft <= 0) {
                    stopTurnTimer();
                    autoFire();
                }
            }, 1000);
        }

        function stopTurnTimer() {
            if (turnTimerInterval) clearInterval(turnTimerInterval);
            document.getElementById('turn-timer').style.display = 'none';
        }

        function autoFire() {
            if (!myTurn || inputLocked) return;
            // Find valid random spot
            let valid = false;
            let rx, ry;
            let attempts = 0;
            while (!valid && attempts < 200) {
                rx = Math.floor(Math.random() * gridSize);
                ry = Math.floor(Math.random() * gridSize);
                if (!document.querySelector(`#enemy-markers .marker[data-x="${rx}"][data-y="${rx}"]`)) { // Fix usage to rx, ry logic
                    // Actually logic below uses rx, ry properly?
                    // Let's use getElementById logic or just querySelector for specific Coords
                    // Better selector check:
                    if (!document.querySelector(`#enemy-markers .marker[data-x="${rx}"][data-y="${ry}"]`)) valid = true;
                }
                attempts++;
            }
            if (valid) sendShot(rx, ry);
        }

        function handleReceiveShot(x, y) {
            // Check Hit
            let hit = false;
            let sunkId = null;
            let sunkCoords = null; // To send back coords of sunk ship

            enemyStats.shots++;

            for (const ship of myShips) {
                if (isPointInShip(x, y, { gx: ship.x, gy: ship.y, matrix: ship.matrix })) {
                    hit = true;
                    // Use a Set to track hits if not exists
                    if (!ship.hits) ship.hits = new Set();
                    ship.hits.add(`${x},${y}`);

                    // Check sunk
                    let totalCells = 0;
                    ship.matrix.forEach(r => r.forEach(c => totalCells += c));
                    if (ship.hits.size === totalCells) {
                        sunkId = ship.id;
                        enemyStats.sunk++;
                        // Gather global coords of this ship
                        sunkCoords = [];
                        ship.matrix.forEach((row, mr) => {
                            row.forEach((val, mc) => {
                                if (val === 1) {
                                    sunkCoords.push({ x: ship.x + mc, y: ship.y + mr });
                                }
                            });
                        });
                    }
                    break;
                }
            }

            if (hit) {
                enemyStats.hits++;
                triggerShake();
            }

            // Highlight Last Move
            clearLastMoveHighlights('my-markers');
            const m = addMarker('my-markers', x, y, hit);
            m.classList.add('last-move');

            // If I am Sunk, I should also update my own markers to Fire? 
            // Yes, "My Fleet" view should also show fire.
            if (sunkId && sunkCoords) {
                updateMarkersToFire('my-markers', sunkCoords);
            }

            conn.send({ type: 'SHOT_RESULT', x, y, hit, sunkId, sunkCoords });

            // CHECK DEFEAT
            // If all my ships are sunk
            // We can calculate total expected hits vs current hits, or just check count
            const allSunk = myShips.every(s => {
                let total = 0;
                s.matrix.forEach(r => r.forEach(c => total += c));
                return s.hits && s.hits.size === total;
            });


            if (allSunk) {
                setTimeout(() => endGame(false), 1000);
            } else {
                // Logic Change: If HIT, opponent continues. If MISS, my turn.
                if (!hit) {
                    // Enemy Missed. I gain turn.
                    // Wait 2.5s to show result, then activate my turn.
                    setTimeout(() => {
                        myTurn = true;
                        inputLocked = false;
                        updateTurnUI();
                    }, 1500);
                } else {
                    // Enemy Hit. They keep turn. I stay defending.
                    myTurn = false;
                    updateTurnUI();
                }
            }
        }

        function handleShotResult(x, y, hit, sunkId, sunkCoords) {
            clearLastMoveHighlights('enemy-markers');
            const m = addMarker('enemy-markers', x, y, hit);
            m.classList.add('last-move');

            myStats.shots++;

            if (hit) {
                myStats.hits++;
                triggerShake(); // Shake on Hit dealt
                confetti({ particleCount: 30, spread: 20, origin: { y: 0.2 } });
            }

            if (sunkId) {
                myStats.sunk++;
                // Mark in manifest
                const entry = document.getElementById(`enemy-manifest-${sunkId}`);
                if (entry) entry.classList.add('sunk');

                // Update Data Model
                const enemyShip = enemyShipsList.find(s => s.id === sunkId);
                if (enemyShip) enemyShip.sunk = true;

                // Update Explosion Markers to FIRE
                if (sunkCoords) {
                    // Update Explosion Markers to FIRE
                    updateMarkersToFire('enemy-markers', sunkCoords);

                    confetti({ particleCount: 100, spread: 60 });
                    document.getElementById('game-info').innerText = "¬°BARCO HUNDIDO! üî•";
                    triggerShake(); // Sunk is a big hit
                    triggerShake(); // Sunk is a big hit
                }
            } else {
                document.getElementById('game-info').innerText = hit ? "¬°IMPACTO! üí•" : "Agua üåä";
                if (hit) triggerShake();
            }

            // CHECK VICTORY
            if (enemyShipsList.every(s => s.sunk)) {
                setTimeout(() => endGame(true), 1000);
            } else {
                if (hit) {
                    // HIT: Keep Turn.
                    // Delay unlocking input to show explosion (2.5s requested)
                    inputLocked = true;
                    myTurn = true;
                    updateTurnUI(); // Show "My Turn"
                    setTimeout(() => {
                        inputLocked = false;
                    }, 1500);
                } else {
                    // MISS: Lose Turn.
                    inputLocked = true; // Lock
                    myTurn = false;
                    // Wait 2.5s then Swap
                    setTimeout(() => {
                        updateTurnUI(); // Will swap to Defending
                        inputLocked = false;
                    }, 1500);
                }
            }
        }

        function endGame(victory) {
            show('screen-result');
            const title = document.getElementById('result-title');
            title.innerText = victory ? "¬°VICTORIA!" : "DERROTA";
            title.style.color = victory ? "#22c55e" : "#ef4444";

            // Update Stats
            // Accuracy
            const acc = myStats.shots > 0 ? Math.round((myStats.hits / myStats.shots) * 100) : 0;
            document.getElementById('stat-accuracy').innerText = `${acc}%`;

            // Sunk
            const totalEnemy = enemyShipsList.length;
            const sunkCount = enemyShipsList.filter(s => s.sunk).length; // or myStats.sunk
            document.getElementById('stat-sunk').innerText = `${sunkCount}/${totalEnemy}`;

            document.getElementById('stat-shots').innerText = myStats.shots;
            document.getElementById('stat-hits').innerText = myStats.hits;

            if (victory) {
                const duration = 3000;
                const end = Date.now() + duration;

                (function frame() {
                    confetti({
                        particleCount: 5,
                        angle: 60,
                        spread: 55,
                        origin: { x: 0 },
                        colors: ['#22c55e', '#ffffff']
                    });
                    confetti({
                        particleCount: 5,
                        angle: 120,
                        spread: 55,
                        origin: { x: 1 },
                        colors: ['#22c55e', '#ffffff']
                    });

                    if (Date.now() < end) {
                        requestAnimationFrame(frame);
                    }
                }());
            }
        }

        /* --- CHAT LOGIC --- */
        function toggleChat() {
            const el = document.getElementById('quick-chat-overlay');
            el.classList.toggle('hidden');
        }

        function sendChat(msg) {
            if (conn && conn.open) {
                conn.send({ type: 'CHAT', msg });
                showChatMessage(msg, true); // Show my own message too? Optional. Let's just feedback
                toggleChat();
            }
        }

        function showChatMessage(msg, isMe = false) {
            const toast = document.getElementById('chat-toast');
            toast.innerText = msg;
            toast.style.borderColor = isMe ? '#fbbf24' : '#22c55e';
            toast.style.color = isMe ? '#fbbf24' : '#22c55e';
            toast.classList.add('show');

            // Auto hide
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function clearLastMoveHighlights(layerId) {
            document.querySelectorAll(`#${layerId} .marker.last-move`).forEach(el => el.classList.remove('last-move'));
        }

        function updateMarkersToFire(layerId, coords) {
            const layer = document.getElementById(layerId);
            const markers = layer.querySelectorAll('.marker');
            markers.forEach(m => {
                const mx = parseInt(m.dataset.gx);
                const my = parseInt(m.dataset.gy);

                const isPart = coords.some(c => c.x === mx && c.y === my);
                if (isPart) {
                    m.innerText = "üî•";
                    m.classList.remove('hit-anim');
                    m.classList.add('sunk-fire');
                }
            });
        }



        function addMarker(layerId, x, y, isHit) {
            const layer = document.getElementById(layerId);
            const m = document.createElement('div');
            // Remove old ::after content classes if we want direct emoji control for animation simplicity, 
            // OR keep them and just allow animation on parent. 
            // Let's use direct content for simpler control with animations.
            m.className = 'marker';
            m.innerText = isHit ? "üí•" : "üåä";

            if (isHit) m.classList.add('hit-anim');
            else m.classList.add('miss-anim');

            m.style.left = `${x * tileSize}px`;
            m.style.top = `${y * tileSize}px`;
            m.style.width = `${tileSize}px`;
            m.style.height = `${tileSize}px`;
            m.dataset.gx = x;
            m.dataset.gy = y;
            layer.appendChild(m);
            return m; // Return element for further manip
        }

        function triggerShake() {
            const layout = document.querySelector('.game-layout');
            layout.classList.remove('shake-element');
            void layout.offsetWidth;
            layout.classList.add('shake-element');
        }



        function updateTurnUI() {
            const layout = document.querySelector('.game-layout');
            const currentlyDefending = layout ? layout.classList.contains('defending') : false;
            const willDefend = !myTurn;

            // Badges
            if (myTurn) {
                document.getElementById('turn-badge').style.display = 'inline-block';
                document.getElementById('wait-badge').style.display = 'none';
                if (!inputLocked) startTurnTimer(); // Start timer
                else stopTurnTimer(); // Hide if locked (waiting animation)
            } else {
                document.getElementById('turn-badge').style.display = 'none';
                document.getElementById('wait-badge').style.display = 'inline-block';
                stopTurnTimer();
            }

            // Animate Swap ONLY if state changes
            if (layout && currentlyDefending !== willDefend) {
                layout.classList.add('anim-swap');
                setTimeout(() => {
                    if (willDefend) layout.classList.add('defending');
                    else layout.classList.remove('defending');
                    layout.classList.remove('anim-swap');
                }, 300);
            }
        }


    </script>
</body>

</html>