<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Batalla Naval - P2P</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <script>
        (() => {
            function e(e, t, n, r) { Object.defineProperty(e, t, { get: n, set: r, enumerable: !0, configurable: !0 }) } function t(e) { return e && e.__esModule ? e.default : e } class n {
                constructor() {
                    this.chunkedMTU = 16300// The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.
                        ,// Binary stuff
                        this._dataCount = 1, this.chunk = e => { let t = [], n = e.byteLength, r = Math.ceil(n / this.chunkedMTU), i = 0, o = 0; for (; o < n;) { let s = Math.min(n, o + this.chunkedMTU), a = e.slice(o, s), c = { __peerData: this._dataCount, n: i, data: a, total: r }; t.push(c), o = s, i++ } return this._dataCount++, t }
                }
            } class r { append_buffer(e) { this.flush(), this._parts.push(e) } append(e) { this._pieces.push(e) } flush() { if (this._pieces.length > 0) { let e = new Uint8Array(this._pieces); this._parts.push(e), this._pieces = [] } } toArrayBuffer() { let e = []; for (let t of this._parts) e.push(t); return function (e) { let t = 0; for (let n of e) t += n.byteLength; let n = new Uint8Array(t), r = 0; for (let t of e) { let e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength); n.set(e, r), r += t.byteLength } return n }(e).buffer } constructor() { this.encoder = new TextEncoder, this._pieces = [], this._parts = [] } } function i(e) { let t = new s(e); return t.unpack() } function o(e) { let t = new a; return t.pack(e), t.getBuffer() } class s {
                unpack() { let e; let t = this.unpack_uint8(); if (t < 128) return t; if ((224 ^ t) < 32) return (224 ^ t) - 32; if ((e = 160 ^ t) <= 15) return this.unpack_raw(e); if ((e = 176 ^ t) <= 15) return this.unpack_string(e); if ((e = 144 ^ t) <= 15) return this.unpack_array(e); if ((e = 128 ^ t) <= 15) return this.unpack_map(e); switch (t) { case 192: return null; case 193: case 212: case 213: case 214: case 215: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 216: return e = this.unpack_uint16(), this.unpack_string(e); case 217: return e = this.unpack_uint32(), this.unpack_string(e); case 218: return e = this.unpack_uint16(), this.unpack_raw(e); case 219: return e = this.unpack_uint32(), this.unpack_raw(e); case 220: return e = this.unpack_uint16(), this.unpack_array(e); case 221: return e = this.unpack_uint32(), this.unpack_array(e); case 222: return e = this.unpack_uint16(), this.unpack_map(e); case 223: return e = this.unpack_uint32(), this.unpack_map(e) } } unpack_uint8() { let e = 255 & this.dataView[this.index]; return this.index++, e } unpack_uint16() { let e = this.read(2), t = (255 & e[0]) * 256 + (255 & e[1]); return this.index += 2, t } unpack_uint32() { let e = this.read(4), t = ((256 * e[0] + e[1]) * 256 + e[2]) * 256 + e[3]; return this.index += 4, t } unpack_uint64() { let e = this.read(8), t = ((((((256 * e[0] + e[1]) * 256 + e[2]) * 256 + e[3]) * 256 + e[4]) * 256 + e[5]) * 256 + e[6]) * 256 + e[7]; return this.index += 8, t } unpack_int8() { let e = this.unpack_uint8(); return e < 128 ? e : e - 256 } unpack_int16() { let e = this.unpack_uint16(); return e < 32768 ? e : e - 65536 } unpack_int32() { let e = this.unpack_uint32(); return e < 2147483648 ? e : e - 4294967296 } unpack_int64() { let e = this.unpack_uint64(); return e < 0x7fffffffffffffff ? e : e - 18446744073709552e3 } unpack_raw(e) { if (this.length < this.index + e) throw Error(`BinaryPackFailure: index is out of range ${this.index} ${e} ${this.length}`); let t = this.dataBuffer.slice(this.index, this.index + e); return this.index += e, t } unpack_string(e) {
                    let t, n; let r = this.read(e), i = 0, o = ""; for (; i < e;)(t = r[i]) < 160 ? (// One-byte sequence: bits 0xxxxxxx
                        n = t, i++) : (192 ^ t) < 32 ? (// Two-byte sequence: bits 110xxxxx 10xxxxxx
                            n = (31 & t) << 6 | 63 & r[i + 1], i += 2) : (224 ^ t) < 16 ? (// Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx
                                n = (15 & t) << 12 | (63 & r[i + 1]) << 6 | 63 & r[i + 2], i += 3) : (// Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                        n = (7 & t) << 18 | (63 & r[i + 1]) << 12 | (63 & r[i + 2]) << 6 | 63 & r[i + 3], i += 4), o += String.fromCodePoint(n); return this.index += e, o
                } unpack_array(e) { let t = Array(e); for (let n = 0; n < e; n++)t[n] = this.unpack(); return t } unpack_map(e) { let t = {}; for (let n = 0; n < e; n++) { let e = this.unpack(); t[e] = this.unpack() } return t } unpack_float() { let e = this.unpack_uint32(); return (0 == e >> 31 ? 1 : -1) * (8388607 & e | 8388608) * 2 ** ((e >> 23 & 255) - 127 - 23) } unpack_double() { let e = this.unpack_uint32(), t = this.unpack_uint32(), n = (e >> 20 & 2047) - 1023; return (0 == e >> 31 ? 1 : -1) * ((1048575 & e | 1048576) * 2 ** (n - 20) + t * 2 ** (n - 52)) } read(e) { let t = this.index; if (t + e <= this.length) return this.dataView.subarray(t, t + e); throw Error("BinaryPackFailure: read index out of range") } constructor(e) { this.index = 0, this.dataBuffer = e, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength }
            } class a { getBuffer() { return this._bufferBuilder.toArrayBuffer() } pack(e) { if ("string" == typeof e) this.pack_string(e); else if ("number" == typeof e) Math.floor(e) === e ? this.pack_integer(e) : this.pack_double(e); else if ("boolean" == typeof e) !0 === e ? this._bufferBuilder.append(195) : !1 === e && this._bufferBuilder.append(194); else if (void 0 === e) this._bufferBuilder.append(192); else if ("object" == typeof e) { if (null === e) this._bufferBuilder.append(192); else { let t = e.constructor; if (e instanceof Array) this.pack_array(e); else if (e instanceof ArrayBuffer) this.pack_bin(new Uint8Array(e)); else if ("BYTES_PER_ELEMENT" in e) this.pack_bin(new Uint8Array(e.buffer, e.byteOffset, e.byteLength)); else if (e instanceof Date) this.pack_string(e.toString()); else if (t == Object || t.toString().startsWith("class")) this.pack_object(e); else throw Error(`Type "${t.toString()}" not yet supported`) } } else throw Error(`Type "${typeof e}" not yet supported`); this._bufferBuilder.flush() } pack_bin(e) { let t = e.length; if (t <= 15) this.pack_uint8(160 + t); else if (t <= 65535) this._bufferBuilder.append(218), this.pack_uint16(t); else if (t <= 4294967295) this._bufferBuilder.append(219), this.pack_uint32(t); else throw Error("Invalid length"); this._bufferBuilder.append_buffer(e) } pack_string(e) { let t = this._textEncoder.encode(e), n = t.length; if (n <= 15) this.pack_uint8(176 + n); else if (n <= 65535) this._bufferBuilder.append(216), this.pack_uint16(n); else if (n <= 4294967295) this._bufferBuilder.append(217), this.pack_uint32(n); else throw Error("Invalid length"); this._bufferBuilder.append_buffer(t) } pack_array(e) { let t = e.length; if (t <= 15) this.pack_uint8(144 + t); else if (t <= 65535) this._bufferBuilder.append(220), this.pack_uint16(t); else if (t <= 4294967295) this._bufferBuilder.append(221), this.pack_uint32(t); else throw Error("Invalid length"); for (let n = 0; n < t; n++)this.pack(e[n]) } pack_integer(e) { if (e >= -32 && e <= 127) this._bufferBuilder.append(255 & e); else if (e >= 0 && e <= 255) this._bufferBuilder.append(204), this.pack_uint8(e); else if (e >= -128 && e <= 127) this._bufferBuilder.append(208), this.pack_int8(e); else if (e >= 0 && e <= 65535) this._bufferBuilder.append(205), this.pack_uint16(e); else if (e >= -32768 && e <= 32767) this._bufferBuilder.append(209), this.pack_int16(e); else if (e >= 0 && e <= 4294967295) this._bufferBuilder.append(206), this.pack_uint32(e); else if (e >= -2147483648 && e <= 2147483647) this._bufferBuilder.append(210), this.pack_int32(e); else if (e >= -0x8000000000000000 && e <= 0x7fffffffffffffff) this._bufferBuilder.append(211), this.pack_int64(e); else if (e >= 0 && e <= 18446744073709552e3) this._bufferBuilder.append(207), this.pack_uint64(e); else throw Error("Invalid integer") } pack_double(e) { let t = 0; e < 0 && (t = 1, e = -e); let n = Math.floor(Math.log(e) / Math.LN2), r = e / 2 ** n - 1, i = Math.floor(4503599627370496 * r), o = t << 31 | n + 1023 << 20 | i / 4294967296 & 1048575; this._bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(i % 4294967296) } pack_object(e) { let t = Object.keys(e), n = t.length; if (n <= 15) this.pack_uint8(128 + n); else if (n <= 65535) this._bufferBuilder.append(222), this.pack_uint16(n); else if (n <= 4294967295) this._bufferBuilder.append(223), this.pack_uint32(n); else throw Error("Invalid length"); for (let t in e) e.hasOwnProperty(t) && (this.pack(t), this.pack(e[t])) } pack_uint8(e) { this._bufferBuilder.append(e) } pack_uint16(e) { this._bufferBuilder.append(e >> 8), this._bufferBuilder.append(255 & e) } pack_uint32(e) { let t = 4294967295 & e; this._bufferBuilder.append((4278190080 & t) >>> 24), this._bufferBuilder.append((16711680 & t) >>> 16), this._bufferBuilder.append((65280 & t) >>> 8), this._bufferBuilder.append(255 & t) } pack_uint64(e) { let t = e / 4294967296, n = e % 4294967296; this._bufferBuilder.append((4278190080 & t) >>> 24), this._bufferBuilder.append((16711680 & t) >>> 16), this._bufferBuilder.append((65280 & t) >>> 8), this._bufferBuilder.append(255 & t), this._bufferBuilder.append((4278190080 & n) >>> 24), this._bufferBuilder.append((16711680 & n) >>> 16), this._bufferBuilder.append((65280 & n) >>> 8), this._bufferBuilder.append(255 & n) } pack_int8(e) { this._bufferBuilder.append(255 & e) } pack_int16(e) { this._bufferBuilder.append((65280 & e) >> 8), this._bufferBuilder.append(255 & e) } pack_int32(e) { this._bufferBuilder.append(e >>> 24 & 255), this._bufferBuilder.append((16711680 & e) >>> 16), this._bufferBuilder.append((65280 & e) >>> 8), this._bufferBuilder.append(255 & e) } pack_int64(e) { let t = Math.floor(e / 4294967296), n = e % 4294967296; this._bufferBuilder.append((4278190080 & t) >>> 24), this._bufferBuilder.append((16711680 & t) >>> 16), this._bufferBuilder.append((65280 & t) >>> 8), this._bufferBuilder.append(255 & t), this._bufferBuilder.append((4278190080 & n) >>> 24), this._bufferBuilder.append((16711680 & n) >>> 16), this._bufferBuilder.append((65280 & n) >>> 8), this._bufferBuilder.append(255 & n) } constructor() { this._bufferBuilder = new r, this._textEncoder = new TextEncoder } } let c = !0, l = !0; function p(e, t, n) { let r = e.match(t); return r && r.length >= n && parseInt(r[n], 10) } function d(e, t, n) { if (!e.RTCPeerConnection) return; let r = e.RTCPeerConnection.prototype, i = r.addEventListener; r.addEventListener = function (e, r) { if (e !== t) return i.apply(this, arguments); let o = e => { let t = n(e); t && (r.handleEvent ? r.handleEvent(t) : r(t)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(r, o), i.apply(this, [e, o]) }; let o = r.removeEventListener; r.removeEventListener = function (e, n) { if (e !== t || !this._eventMap || !this._eventMap[t] || !this._eventMap[t].has(n)) return o.apply(this, arguments); let r = this._eventMap[t].get(n); return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, r]) }, Object.defineProperty(r, "on" + t, { get() { return this["_on" + t] }, set(e) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e) }, enumerable: !0, configurable: !0 }) } function h(e) { return "boolean" != typeof e ? Error("Argument type: " + typeof e + ". Please use a boolean.") : (c = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function u(e) { return "boolean" != typeof e ? Error("Argument type: " + typeof e + ". Please use a boolean.") : (l = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function f() { "object" != typeof window || c || "undefined" == typeof console || "function" != typeof console.log || console.log.apply(console, arguments) } function m(e, t) { l && console.warn(e + " is deprecated, please use " + t + " instead.") }/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */function g(e) { return "[object Object]" === Object.prototype.toString.call(e) } function y(e, t, n) { let r = n ? "outbound-rtp" : "inbound-rtp", i = new Map; if (null === t) return i; let o = []; return e.forEach(e => { "track" === e.type && e.trackIdentifier === t.id && o.push(e) }), o.forEach(t => { e.forEach(n => { n.type === r && n.trackId === t.id && function e(t, n, r) { !n || r.has(n.id) || (r.set(n.id, n), Object.keys(n).forEach(i => { i.endsWith("Id") ? e(t, t.get(n[i]), r) : i.endsWith("Ids") && n[i].forEach(n => { e(t, t.get(n), r) }) })) }(e, n, i) }) }), i } var _, C, v, b, k, S, T, R, w, P, E, D, x, I, M, O, j = {}; function L(e, t) {
                let n = e && e.navigator; if (!n.mediaDevices) return; let r = function (e) { if ("object" != typeof e || e.mandatory || e.optional) return e; let t = {}; return Object.keys(e).forEach(n => { if ("require" === n || "advanced" === n || "mediaSource" === n) return; let r = "object" == typeof e[n] ? e[n] : { ideal: e[n] }; void 0 !== r.exact && "number" == typeof r.exact && (r.min = r.max = r.exact); let i = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t }; if (void 0 !== r.ideal) { t.optional = t.optional || []; let e = {}; "number" == typeof r.ideal ? (e[i("min", n)] = r.ideal, t.optional.push(e), (e = {})[i("max", n)] = r.ideal) : e[i("", n)] = r.ideal, t.optional.push(e) } void 0 !== r.exact && "number" != typeof r.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[i("", n)] = r.exact) : ["min", "max"].forEach(e => { void 0 !== r[e] && (t.mandatory = t.mandatory || {}, t.mandatory[i(e, n)] = r[e]) }) }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, i = function (e, i) {
                    if (t.version >= 61) return i(e); if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) { let t = function (e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }; t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = r(e.audio) } if (e && "object" == typeof e.video) {// Shim facingMode for mobile & surface pro.
                        let o = e.video.facingMode; o = o && ("object" == typeof o ? o : { ideal: o }); let s = t.version < 66; if (o && ("user" === o.exact || "environment" === o.exact || "user" === o.ideal || "environment" === o.ideal) && !(n.mediaDevices.getSupportedConstraints && n.mediaDevices.getSupportedConstraints().facingMode && !s)) { let t; if (delete e.video.facingMode, "environment" === o.exact || "environment" === o.ideal ? t = ["back", "rear"] : ("user" === o.exact || "user" === o.ideal) && (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then(n => { let s = (n = n.filter(e => "videoinput" === e.kind)).find(e => t.some(t => e.label.toLowerCase().includes(t))); return !s && n.length && t.includes("back") && (s = n[n.length - 1]), s && (e.video.deviceId = o.exact ? { exact: s.deviceId } : { ideal: s.deviceId }), e.video = r(e.video), f("chrome: " + JSON.stringify(e)), i(e) }) } e.video = r(e.video)
                    } return f("chrome: " + JSON.stringify(e)), i(e)
                }, o = function (e) { return t.version >= 64 ? e : { name: ({ PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" })[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } };// Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
                // function which returns a Promise, it does not accept spec-style
                // constraints.
                if (n.getUserMedia = (function (e, t, r) { i(e, e => { n.webkitGetUserMedia(e, t, e => { r && r(o(e)) }) }) }).bind(n), n.mediaDevices.getUserMedia) { let e = n.mediaDevices.getUserMedia.bind(n.mediaDevices); n.mediaDevices.getUserMedia = function (t) { return i(t, t => e(t).then(e => { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => { e.stop() }), new DOMException("", "NotFoundError"); return e }, e => Promise.reject(o(e)))) } }
            } function A(e, t) {
                if ((!e.navigator.mediaDevices || !("getDisplayMedia" in e.navigator.mediaDevices)) && e.navigator.mediaDevices) {// getSourceId is a function that returns a promise resolving with
                    // the sourceId of the screen/window/tab to be shared.
                    if ("function" != typeof t) { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then(t => { let r = n.video && n.video.width, i = n.video && n.video.height, o = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t, maxFrameRate: o || 3 } }, r && (n.video.mandatory.maxWidth = r), i && (n.video.mandatory.maxHeight = i), e.navigator.mediaDevices.getUserMedia(n) }) }
                }
            } function B(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function F(e) {
                if ("object" != typeof e || !e.RTCPeerConnection || "ontrack" in e.RTCPeerConnection.prototype)// emitted in unified-plan. Unfortunately this means we need
                    // to unconditionally wrap the event.
                    d(e, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e)); else {
                    Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(e) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e) }, enumerable: !0, configurable: !0 }); let t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () {
                        return this._ontrackpoly || (this._ontrackpoly = t => {// onaddstream does not fire when a track is added to an existing
                            // stream. But stream.onaddtrack is implemented so we use that.
                            t.stream.addEventListener("addtrack", n => { let r; r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === n.track.id) : { track: n.track }; let i = new Event("track"); i.track = n.track, i.receiver = r, i.transceiver = { receiver: r }, i.streams = [t.stream], this.dispatchEvent(i) }), t.stream.getTracks().forEach(n => { let r; r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === n.id) : { track: n }; let i = new Event("track"); i.track = n, i.receiver = r, i.transceiver = { receiver: r }, i.streams = [t.stream], this.dispatchEvent(i) })
                        }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                    }
                }
            } function z(e) {// Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
                if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                    let t = function (e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } };// augment addTrack when getSenders is not available.
                    if (!e.RTCPeerConnection.prototype.getSenders) {
                        e.RTCPeerConnection.prototype.getSenders = function () {
                            return this._senders = this._senders || [], this._senders.slice();// return a copy of the internal state.
                        }; let n = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { let i = n.apply(this, arguments); return i || (i = t(this, e), this._senders.push(i)), i }; let r = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { r.apply(this, arguments); let t = this._senders.indexOf(e); -1 !== t && this._senders.splice(t, 1) }
                    } let n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => { this._senders.push(t(this, e)) }) }; let r = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { this._senders = this._senders || [], r.apply(this, [e]), e.getTracks().forEach(e => { let t = this._senders.find(t => t.track === e); t && this._senders.splice(this._senders.indexOf(t), 1) }) }
                } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { let t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { let e = t.apply(this, []); return e.forEach(e => e._pc = this), e }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) }
            } function U(e) {
                if (!e.RTCPeerConnection) return; let t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () {
                    let [e, n, r] = arguments;// If selector is a function then we are in the old style stats so just
                    // pass back the original getStats format to avoid breaking old users.
                    if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);// When spec-style getStats is supported, return those when called with
                    // either no arguments or the selector argument is null.
                    if (0 === t.length && (0 == arguments.length || "function" != typeof e)) return t.apply(this, []); let i = function (e) { let t = {}, n = e.result(); return n.forEach(e => { let n = { id: e.id, timestamp: e.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type }; e.names().forEach(t => { n[t] = e.stat(t) }), t[n.id] = n }), t }, o = function (e) { return new Map(Object.keys(e).map(t => [t, e[t]])) }; return arguments.length >= 2 ? t.apply(this, [function (e) { n(o(i(e))) }, e]) : new Promise((e, n) => { t.apply(this, [function (t) { e(o(i(t))) }, n]) }).then(n, r)
                }
            } function N(e) {
                if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;// shim sender stats.
                if (!("getStats" in e.RTCRtpSender.prototype)) {
                    let t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { let e = t.apply(this, []); return e.forEach(e => e._pc = this), e }); let n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { let e = n.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () {
                        let e = this; return this._pc.getStats().then(t =>/* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */y(t, e.track, !0))
                    }
                }// shim receiver stats.
                if (!("getStats" in e.RTCRtpReceiver.prototype)) { let t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { let e = t.apply(this, []); return e.forEach(e => e._pc = this), e }), d(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () { let e = this; return this._pc.getStats().then(t => y(t, e.track, !1)) } } if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return;// shim RTCPeerConnection.getStats(track).
                let t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { let e, t, n; let r = arguments[0]; return (this.getSenders().forEach(t => { t.track === r && (e ? n = !0 : e = t) }), this.getReceivers().forEach(e => (e.track === r && (t ? n = !0 : t = e), e.track === r)), n || e && t) ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : e ? e.getStats() : t ? t.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) }
            } function $(e) {// shim addTrack/removeTrack with native variants in order to make
                // the interactions with legacy getLocalStreams behave as in other browsers.
                // Keeps a mapping stream.id => [stream, rtpsenders...]
                e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0]) }; let t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, n) { if (!n) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; let r = t.apply(this, arguments); return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(r) && this._shimmedLocalStreams[n.id].push(r) : this._shimmedLocalStreams[n.id] = [n, r], r }; let n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => { let t = this.getSenders().find(t => t.track === e); if (t) throw new DOMException("Track already exists.", "InvalidAccessError") }); let t = this.getSenders(); n.apply(this, arguments); let r = this.getSenders().filter(e => -1 === t.indexOf(e)); this._shimmedLocalStreams[e.id] = [e].concat(r) }; let r = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], r.apply(this, arguments) }; let i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => { let n = this._shimmedLocalStreams[t].indexOf(e); -1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t] }), i.apply(this, arguments) }
            } function J(e, t) {
                if (!e.RTCPeerConnection) return;// shim addTrack and removeTrack.
                if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return $(e);// also shim pc.getLocalStreams when addTrack is shimmed
                // to return the original streams.
                let n = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { let e = n.apply(this); return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id]) }; let r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) {// Add identity mapping for consistency with addTrack.
                    // Unless this is being used with a stream from addTrack.
                    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => { let t = this.getSenders().find(t => t.track === e); if (t) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[t.id]) { let n = new e.MediaStream(t.getTracks()); this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n } r.apply(this, [t])
                }; let i = e.RTCPeerConnection.prototype.removeStream;// replace the internal stream id with the external one and
                // vice versa.
                function o(e, t) { let n = t.sdp; return Object.keys(e._reverseStreams || []).forEach(t => { let r = e._reverseStreams[t], i = e._streams[r.id]; n = n.replace(RegExp(i.id, "g"), r.id) }), new RTCSessionDescription({ type: t.type, sdp: n }) } e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id] }, e.RTCPeerConnection.prototype.addTrack = function (t, n) {
                    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); let r = [].slice.call(arguments, 1); if (1 !== r.length || !r[0].getTracks().find(e => e === t))// [[associated MediaStreams]] internal slot.
                        throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); let i = this.getSenders().find(e => e.track === t); if (i) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; let o = this._streams[n.id]; if (o)// this is using odd Chrome behaviour, use with caution:
                        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
                        // Note: we rely on the high-level addTrack/dtmf shim to
                        // create the sender with a dtmf sender.
                        o.addTrack(t),// Trigger ONN async.
                            Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { let r = new e.MediaStream([t]); this._streams[n.id] = r, this._reverseStreams[r.id] = n, this.addStream(r) } return this.getSenders().find(e => e.track === t)
                }, ["createOffer", "createAnswer"].forEach(function (t) { let n = e.RTCPeerConnection.prototype[t]; e.RTCPeerConnection.prototype[t] = ({ [t]() { let e = arguments, t = arguments.length && "function" == typeof arguments[0]; return t ? n.apply(this, [t => { let n = o(this, t); e[0].apply(null, [n]) }, t => { e[1] && e[1].apply(null, t) }, arguments[2]]) : n.apply(this, arguments).then(e => o(this, e)) } })[t] }); let s = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { var e, t; let n; return arguments.length && arguments[0].type && (arguments[0] = (e = this, t = arguments[0], n = t.sdp, Object.keys(e._reverseStreams || []).forEach(t => { let r = e._reverseStreams[t], i = e._streams[r.id]; n = n.replace(RegExp(r.id, "g"), i.id) }), new RTCSessionDescription({ type: t.type, sdp: n }))), s.apply(this, arguments) };// TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier
                let a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { let e = a.get.apply(this); return "" === e.type ? e : o(this, e) } }), e.RTCPeerConnection.prototype.removeTrack = function (e) {
                    let t; if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");// We can not yet check for sender instanceof RTCRtpSender
                    // since we shim RTPSender. So we check if sender._pc is set.
                    if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); let n = e._pc === this; if (!n) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");// Search for the native stream the senders track belongs to.
                    this._streams = this._streams || {}, Object.keys(this._streams).forEach(n => { let r = this._streams[n].getTracks().find(t => e.track === t); r && (t = this._streams[n]) }), t && (1 === t.getTracks().length ?// takes care of any shimmed _senders.
                        this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
                }
            } function V(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (t) { let n = e.RTCPeerConnection.prototype[t]; e.RTCPeerConnection.prototype[t] = ({ [t]() { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } })[t] }) } function G(e, t) { d(e, "negotiationneeded", e => { let n = e.target; if (!(t.version < 72) && (!n.getConfiguration || "plan-b" !== n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e }) } e(j, "shimMediaStream", () => B), e(j, "shimOnTrack", () => F), e(j, "shimGetSendersWithDtmf", () => z), e(j, "shimGetStats", () => U), e(j, "shimSenderReceiverGetStats", () => N), e(j, "shimAddTrackRemoveTrackWithNative", () => $), e(j, "shimAddTrackRemoveTrack", () => J), e(j, "shimPeerConnection", () => V), e(j, "fixNegotiationNeeded", () => G), e(j, "shimGetUserMedia", () => L), e(j, "shimGetDisplayMedia", () => A); var W = {}; function H(e, t) {
                let n = e && e.navigator, r = e && e.MediaStreamTrack; if (n.getUserMedia = function (e, t, r) {// Replace Firefox 44+'s deprecation warning with unprefixed version.
                    m("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, r)
                }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) { let e = function (e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }, t = n.mediaDevices.getUserMedia.bind(n.mediaDevices); if (n.mediaDevices.getUserMedia = function (n) { return "object" == typeof n && "object" == typeof n.audio && (e((n = JSON.parse(JSON.stringify(n))).audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n) }, r && r.prototype.getSettings) { let t = r.prototype.getSettings; r.prototype.getSettings = function () { let n = t.apply(this, arguments); return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n } } if (r && r.prototype.applyConstraints) { let t = r.prototype.applyConstraints; r.prototype.applyConstraints = function (n) { return "audio" === this.kind && "object" == typeof n && (e(n = JSON.parse(JSON.stringify(n)), "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n]) } } }
            } function Y(e, t) {
                e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || !e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = function (n) {
                    if (!(n && n.video)) {
                        let e = new DOMException("getDisplayMedia without video constraints is undefined"); return e.name = "NotFoundError",// from https://heycam.github.io/webidl/#idl-DOMException-error-names
                            e.code = 8, Promise.reject(e)
                    } return !0 === n.video ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n)
                })
            } function K(e) { "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function X(e, t) {
                if ("object" != typeof e || !(e.RTCPeerConnection || e.mozRTCPeerConnection)) return;// probably media.peerconnection.enabled=false in about:config
                !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (t) { let n = e.RTCPeerConnection.prototype[t]; e.RTCPeerConnection.prototype[t] = ({ [t]() { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } })[t] }); let n = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, r = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () {
                    let [e, i, o] = arguments; return r.apply(this, [e || null]).then(e => {
                        if (t.version < 53 && !i)// Leave callback version alone; misc old uses of forEach before Map
                            try { e.forEach(e => { e.type = n[e.type] || e.type }) } catch (t) {
                                if ("TypeError" !== t.name) throw t;// Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                                e.forEach((t, r) => { e.set(r, Object.assign({}, t, { type: n[t.type] || t.type })) })
                            } return e
                    }).then(i, o)
                }
            } function q(e) { if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; let t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { let e = t.apply(this, []); return e.forEach(e => e._pc = this), e }); let n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { let e = n.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function Q(e) { if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; let t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { let e = t.apply(this, []); return e.forEach(e => e._pc = this), e }), d(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function Z(e) { !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { m("removeStream", "removeTrack"), this.getSenders().forEach(t => { t.track && e.getTracks().includes(t.track) && this.removeTrack(t) }) }) } function ee(e) {// rename DataChannel to RTCDataChannel (native fix in FF60):
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
                e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
            } function et(e) {// https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
                // Firefox ignores the init sendEncodings options passed to addTransceiver
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
                if (!("object" == typeof e && e.RTCPeerConnection)) return; let t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () {
                    this.setParametersPromises = [];// WebIDL input coercion and validation
                    let e = arguments[1] && arguments[1].sendEncodings; void 0 === e && (e = []), e = [...e]; let n = e.length > 0; n && e.forEach(e => { if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw RangeError("max_framerate must be >= 0.0") }); let r = t.apply(this, arguments); if (n) {// Check if the init options were applied. If not we do this in an
                        // asynchronous way and save the promise reference in a global object.
                        // This is an ugly hack, but at the same time is way more robust than
                        // checking the sender parameters before and after the createOffer
                        // Also note that after the createoffer we are not 100% sure that
                        // the params were asynchronously applied so we might miss the
                        // opportunity to recreate offer.
                        let { sender: t } = r, n = t.getParameters(); "encodings" in n &&// Avoid being fooled by patched getParameters() below.
                            (1 !== n.encodings.length || 0 !== Object.keys(n.encodings[0]).length) || (n.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(n).then(() => { delete t.sendEncodings }).catch(() => { delete t.sendEncodings })))
                    } return r
                })
            } function en(e) { if (!("object" == typeof e && e.RTCRtpSender)) return; let t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { let e = t.apply(this, arguments); return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e }) } function er(e) {// https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
                // Firefox ignores the init sendEncodings options passed to addTransceiver
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
                if (!("object" == typeof e && e.RTCPeerConnection)) return; let t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) }
            } function ei(e) {// https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
                // Firefox ignores the init sendEncodings options passed to addTransceiver
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
                if (!("object" == typeof e && e.RTCPeerConnection)) return; let t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) }
            } e(W, "shimOnTrack", () => K), e(W, "shimPeerConnection", () => X), e(W, "shimSenderGetStats", () => q), e(W, "shimReceiverGetStats", () => Q), e(W, "shimRemoveStream", () => Z), e(W, "shimRTCDataChannel", () => ee), e(W, "shimAddTransceiver", () => et), e(W, "shimGetParameters", () => en), e(W, "shimCreateOffer", () => er), e(W, "shimCreateAnswer", () => ei), e(W, "shimGetUserMedia", () => H), e(W, "shimGetDisplayMedia", () => Y); var eo = {}; function es(e) {
                if ("object" == typeof e && e.RTCPeerConnection) {
                    if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) {
                        let t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) {
                            this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e),// Try to emulate Chrome's behaviour of adding in audio-video order.
                                // Safari orders by track id.
                                e.getAudioTracks().forEach(n => t.call(this, n, e)), e.getVideoTracks().forEach(n => t.call(this, n, e))
                        }, e.RTCPeerConnection.prototype.addTrack = function (e, ...n) { return n && n.forEach(e => { this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e] }), t.apply(this, arguments) }
                    } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { this._localStreams || (this._localStreams = []); let t = this._localStreams.indexOf(e); if (-1 === t) return; this._localStreams.splice(t, 1); let n = e.getTracks(); this.getSenders().forEach(e => { n.includes(e.track) && this.removeTrack(e) }) })
                }
            } function ea(e) { if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(e) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => { e.streams.forEach(e => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return; this._remoteStreams.push(e); let t = new Event("addstream"); t.stream = e, this.dispatchEvent(t) }) }) } }); let t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { let e = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (t) { t.streams.forEach(t => { if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return; e._remoteStreams.push(t); let n = new Event("addstream"); n.stream = t, e.dispatchEvent(n) }) }), t.apply(e, arguments) } } } function ec(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; let t = e.RTCPeerConnection.prototype, n = t.createOffer, r = t.createAnswer, i = t.setLocalDescription, o = t.setRemoteDescription, s = t.addIceCandidate; t.createOffer = function (e, t) { let r = arguments.length >= 2 ? arguments[2] : arguments[0], i = n.apply(this, [r]); return t ? (i.then(e, t), Promise.resolve()) : i }, t.createAnswer = function (e, t) { let n = arguments.length >= 2 ? arguments[2] : arguments[0], i = r.apply(this, [n]); return t ? (i.then(e, t), Promise.resolve()) : i }; let a = function (e, t, n) { let r = i.apply(this, [e]); return n ? (r.then(t, n), Promise.resolve()) : r }; t.setLocalDescription = a, a = function (e, t, n) { let r = o.apply(this, [e]); return n ? (r.then(t, n), Promise.resolve()) : r }, t.setRemoteDescription = a, a = function (e, t, n) { let r = s.apply(this, [e]); return n ? (r.then(t, n), Promise.resolve()) : r }, t.addIceCandidate = a } function el(e) {
                let t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) {// shim not needed in Safari 12.1
                    let e = t.mediaDevices, n = e.getUserMedia.bind(e); t.mediaDevices.getUserMedia = e => n(ep(e))
                } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = (function (e, n, r) { t.mediaDevices.getUserMedia(e).then(n, r) }).bind(t))
            } function ep(e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: function e(t) { return g(t) ? Object.keys(t).reduce(function (n, r) { let i = g(t[r]), o = i ? e(t[r]) : t[r], s = i && !Object.keys(o).length; return void 0 === o || s ? n : Object.assign(n, { [r]: o }) }, {}) : t }(e.video) }) : e } function ed(e) {
                if (!e.RTCPeerConnection) return;// migrate from non-spec RTCIceServer.url to RTCIceServer.urls
                let t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, n) { if (e && e.iceServers) { let t = []; for (let n = 0; n < e.iceServers.length; n++) { let r = e.iceServers[n]; void 0 === r.urls && r.url ? (m("RTCIceServer.url", "RTCIceServer.urls"), (r = JSON.parse(JSON.stringify(r))).urls = r.url, delete r.url, t.push(r)) : t.push(e.iceServers[n]) } e.iceServers = t } return new t(e, n) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: () => t.generateCertificate })
            } function eh(e) {// Add event.transceiver member over deprecated event.receiver
                "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } })
            } function eu(e) { let t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); let t = this.getTransceivers().find(e => "audio" === e.receiver.track.kind); !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); let n = this.getTransceivers().find(e => "video" === e.receiver.track.kind); !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video", { direction: "recvonly" }) } return t.apply(this, arguments) } } function ef(e) { "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } e(eo, "shimLocalStreamsAPI", () => es), e(eo, "shimRemoteStreamsAPI", () => ea), e(eo, "shimCallbacksAPI", () => ec), e(eo, "shimGetUserMedia", () => el), e(eo, "shimConstraints", () => ep), e(eo, "shimRTCIceServerUrls", () => ed), e(eo, "shimTrackEventTransceiver", () => eh), e(eo, "shimCreateOfferLegacy", () => eu), e(eo, "shimAudioContext", () => ef); var em = {}; e(em, "shimRTCIceCandidate", () => e_), e(em, "shimRTCIceCandidateRelayProtocol", () => eC), e(em, "shimMaxMessageSize", () => ev), e(em, "shimSendThrowTypeError", () => eb), e(em, "shimConnectionState", () => ek), e(em, "removeExtmapAllowMixed", () => eS), e(em, "shimAddIceCandidateNullOrEmpty", () => eT), e(em, "shimParameterlessSetLocalDescription", () => eR);/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 *//* eslint-env node */var eg = {};// SDP helpers.
            let ey = {}; function e_(e) {// foundation is arbitrarily chosen as an indicator for full support for
                // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
                if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; let n = e.RTCIceCandidate; e.RTCIceCandidate = function (e) {
                    if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substring(2)), e.candidate && e.candidate.length) {// Augment the native candidate with the parsed fields.
                        let r = new n(e), i =/*@__PURE__*/t(eg).parseCandidate(e.candidate); for (let e in i) e in r || Object.defineProperty(r, e, { value: i[e] }); return (// Override serializer to not serialize the extra attributes.
                            r.toJSON = function () { return { candidate: r.candidate, sdpMid: r.sdpMid, sdpMLineIndex: r.sdpMLineIndex, usernameFragment: r.usernameFragment } }, r)
                    } return new n(e)
                }, e.RTCIceCandidate.prototype = n.prototype,// Hook up the augmented candidate in onicecandidate and
                    // addEventListener('icecandidate', ...)
                    d(e, "icecandidate", t => (t.candidate && Object.defineProperty(t, "candidate", { value: new e.RTCIceCandidate(t.candidate), writable: "false" }), t))
            } function eC(e) {
                !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype ||// Hook up the augmented candidate in onicecandidate and
                    // addEventListener('icecandidate', ...)
                    d(e, "icecandidate", e => {
                        if (e.candidate) {
                            let n =/*@__PURE__*/t(eg).parseCandidate(e.candidate.candidate); "relay" === n.type &&// to relayProtocol.
                                (e.candidate.relayProtocol = ({ 0: "tls", 1: "tcp", 2: "udp" })[n.priority >> 24])
                        } return e
                    })
            } function ev(e, n) {
                if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return void 0 === this._sctp ? null : this._sctp } }); let r = function (e) { if (!e || !e.sdp) return !1; let n =/*@__PURE__*/t(eg).splitSections(e.sdp); return n.shift(), n.some(e => { let n =/*@__PURE__*/t(eg).parseMLine(e); return n && "application" === n.kind && -1 !== n.protocol.indexOf("SCTP") }) }, i = function (e) {// TODO: Is there a better solution for detecting Firefox?
                    let t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (null === t || t.length < 2) return -1; let n = parseInt(t[1], 10);// Test for NaN (yes, this is ugly)
                    return n != n ? -1 : n
                }, o = function (e) {// Every implementation we know can send at least 64 KiB.
                    // Note: Although Chrome is technically able to send up to 256 KiB, the
                    //       data does not reach the other peer reliably.
                    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
                    let t = 65536; return "firefox" === n.browser && (// fragmentation.
                        t = n.version < 57 ? -1 === e ? 16384 : 2147483637 : n.version < 60 ? 57 === n.version ? 65535 : 65536 : 2147483637), t
                }, s = function (e, r) {// Note: 65536 bytes is the default value from the SDP spec. Also,
                    //       every implementation we know supports receiving 65536 bytes.
                    let i = 65536; "firefox" === n.browser && 57 === n.version && (i = 65535); let o =/*@__PURE__*/t(eg).matchPrefix(e.sdp, "a=max-message-size:"); return o.length > 0 ? i = parseInt(o[0].substring(19), 10) : "firefox" === n.browser && -1 !== r &&// both local and remote are Firefox, the remote peer can receive
                        // ~2 GiB.
                        (i = 2147483637), i
                }, a = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () {// Chrome decided to not expose .sctp in plan-b mode.
                    // As usual, adapter.js has to do an 'ugly worakaround'
                    // to cover up the mess.
                    if (this._sctp = null, "chrome" === n.browser && n.version >= 76) { let { sdpSemantics: e } = this.getConfiguration(); "plan-b" === e && Object.defineProperty(this, "sctp", { get() { return void 0 === this._sctp ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (r(arguments[0])) {
                        let e;// Check if the remote is FF.
                        let t = i(arguments[0]), n = o(t), r = s(arguments[0], t); e = 0 === n && 0 === r ? Number.POSITIVE_INFINITY : 0 === n || 0 === r ? Math.max(n, r) : Math.min(n, r);// Create a dummy RTCSctpTransport object and the 'maxMessageSize'
                        // attribute.
                        let a = {}; Object.defineProperty(a, "maxMessageSize", { get: () => e }), this._sctp = a
                    } return a.apply(this, arguments)
                }
            } function eb(e) {
                if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return;// Note: Although Firefox >= 57 has a native implementation, the maximum
                //       message size can be reset for all data channels at a later stage.
                //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                function t(e, t) { let n = e.send; e.send = function () { let r = arguments[0], i = r.length || r.size || r.byteLength; if ("open" === e.readyState && t.sctp && i > t.sctp.maxMessageSize) throw TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)"); return n.apply(e, arguments) } } let n = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { let e = n.apply(this, arguments); return t(e, this), e }, d(e, "datachannel", e => (t(e.channel, e.target), e))
            } function ek(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; let t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return ({ completed: "connected", checking: "connecting" })[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(e) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(e => { let n = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => { let t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; let n = new Event("connectionstatechange", e); t.dispatchEvent(n) } return e }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } }) } function eS(e, t) {/* remove a=extmap-allow-mixed for webrtc.org < M71 */if (!e.RTCPeerConnection || "chrome" === t.browser && t.version >= 71 || "safari" === t.browser && t.version >= 605) return; let n = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (t) {
                if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
                    let n = t.sdp.split("\n").filter(e => "a=extmap-allow-mixed" !== e.trim()).join("\n");// Safari enforces read-only-ness of RTCSessionDescription fields.
                    e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t.type, sdp: n }) : t.sdp = n
                } return n.apply(this, arguments)
            }
            } function eT(e, t) {// Support for addIceCandidate(null or undefined)
                // as well as addIceCandidate({candidate: "", ...})
                // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
                // Note: must be called before other polyfills which change the signature.
                if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; let n = e.RTCPeerConnection.prototype.addIceCandidate; n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) })
            } function eR(e, t) {
                if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; let n = e.RTCPeerConnection.prototype.setLocalDescription; n && 0 !== n.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () {
                    let e = arguments[0] || {}; if ("object" != typeof e || e.type && e.sdp) return n.apply(this, arguments); if (!// The remaining steps should technically happen when SLD comes off the
                        // RTCPeerConnection's operations chain (not ahead of going on it), but
                        // this is too difficult to shim. Instead, this shim only covers the
                        // common case where the operations chain is empty. This is imperfect, but
                        // should cover many cases. Rationale: Even if we can't reduce the glare
                        // window to zero on imperfect implementations, there's value in tapping
                        // into the perfect negotiation pattern that several browsers support.
                        (e = { type: e.type, sdp: e.sdp }).type) switch (this.signalingState) { case "stable": case "have-local-offer": case "have-remote-pranswer": e.type = "offer"; break; default: e.type = "answer" }if (e.sdp || "offer" !== e.type && "answer" !== e.type) return n.apply(this, [e]); let t = "offer" === e.type ? this.createOffer : this.createAnswer; return t.apply(this).then(e => n.apply(this, [e]))
                })
            }// Generate an alphanumeric identifier for cname or mids.
            // TODO: use UUIDs instead? https://gist.github.com/jed/982883
            ey.generateIdentifier = function () { return Math.random().toString(36).substring(2, 12) },// The RTCP CNAME used by all peerconnections from the same JS.
                ey.localCName = ey.generateIdentifier(),// Splits SDP into lines, dealing with both CRLF and LF.
                ey.splitLines = function (e) { return e.trim().split("\n").map(e => e.trim()) },// Splits SDP into sessionpart and mediasections. Ensures CRLF.
                ey.splitSections = function (e) { let t = e.split("\nm="); return t.map((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n") },// Returns the session description.
                ey.getDescription = function (e) { let t = ey.splitSections(e); return t && t[0] },// Returns the individual media sections.
                ey.getMediaSections = function (e) { let t = ey.splitSections(e); return t.shift(), t },// Returns lines that start with a certain prefix.
                ey.matchPrefix = function (e, t) { return ey.splitLines(e).filter(e => 0 === e.indexOf(t)) },// Parses an ICE candidate line. Sample input:
                // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
                // rport 55996"
                // Input can be prefixed with a=.
                ey.parseCandidate = function (e) {
                    let t;// Parse both variants.
                    t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "); let n = {
                        foundation: t[0], component: { 1: "rtp", 2: "rtcp" }[t[1]] || t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10),// skip parts[6] == 'typ'
                        type: t[7]
                    }; for (let e = 8; e < t.length; e += 2)switch (t[e]) { case "raddr": n.relatedAddress = t[e + 1]; break; case "rport": n.relatedPort = parseInt(t[e + 1], 10); break; case "tcptype": n.tcpType = t[e + 1]; break; case "ufrag": n.ufrag = t[e + 1], n.usernameFragment = t[e + 1]; break; default: void 0 === n[t[e]] && (n[t[e]] = t[e + 1]) }return n
                },// Translates a candidate object into SDP candidate attribute.
                // This does not include the a= prefix!
                ey.writeCandidate = function (e) { let t = []; t.push(e.foundation); let n = e.component; "rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); let r = e.type; return t.push("typ"), t.push(r), "host" !== r && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ") },// Parses an ice-options line, returns an array of option tags.
                // Sample input:
                // a=ice-options:foo bar
                ey.parseIceOptions = function (e) { return e.substring(14).split(" ") },// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
                // a=rtpmap:111 opus/48000/2
                ey.parseRtpMap = function (e) {
                    let t = e.substring(9).split(" "), n = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1,// legacy alias, got renamed back to channels in ORTC.
                        n.numChannels = n.channels, n
                },// Generates a rtpmap line from RTCRtpCodecCapability or
                // RTCRtpCodecParameters.
                ey.writeRtpMap = function (e) { let t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); let n = e.channels || e.numChannels || 1; return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n" },// Parses a extmap line (headerextension from RFC 5285). Sample input:
                // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
                // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
                ey.parseExtmap = function (e) { let t = e.substring(9).split(" "); return { id: parseInt(t[0], 10), direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv", uri: t[1], attributes: t.slice(2).join(" ") } },// Generates an extmap line from RTCRtpHeaderExtensionParameters or
                // RTCRtpHeaderExtension.
                ey.writeExtmap = function (e) { return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + (e.attributes ? " " + e.attributes : "") + "\r\n" },// Parses a fmtp line, returns dictionary. Sample input:
                // a=fmtp:96 vbr=on;cng=on
                // Also deals with vbr=on; cng=on
                ey.parseFmtp = function (e) { let t; let n = {}, r = e.substring(e.indexOf(" ") + 1).split(";"); for (let e = 0; e < r.length; e++)n[(t = r[e].trim().split("="))[0].trim()] = t[1]; return n },// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
                ey.writeFmtp = function (e) { let t = "", n = e.payloadType; if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { let r = []; Object.keys(e.parameters).forEach(t => { void 0 !== e.parameters[t] ? r.push(t + "=" + e.parameters[t]) : r.push(t) }), t += "a=fmtp:" + n + " " + r.join(";") + "\r\n" } return t },// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
                // a=rtcp-fb:98 nack rpsi
                ey.parseRtcpFb = function (e) { let t = e.substring(e.indexOf(" ") + 1).split(" "); return { type: t.shift(), parameter: t.join(" ") } },// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
                ey.writeRtcpFb = function (e) { let t = "", n = e.payloadType; return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(e => { t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n" }), t },// Parses a RFC 5576 ssrc media attribute. Sample input:
                // a=ssrc:3735928559 cname:something
                ey.parseSsrcMedia = function (e) { let t = e.indexOf(" "), n = { ssrc: parseInt(e.substring(7, t), 10) }, r = e.indexOf(":", t); return r > -1 ? (n.attribute = e.substring(t + 1, r), n.value = e.substring(r + 1)) : n.attribute = e.substring(t + 1), n },// Parse a ssrc-group line (see RFC 5576). Sample input:
                // a=ssrc-group:semantics 12 34
                ey.parseSsrcGroup = function (e) { let t = e.substring(13).split(" "); return { semantics: t.shift(), ssrcs: t.map(e => parseInt(e, 10)) } },// Extracts the MID (RFC 5888) from a media section.
                // Returns the MID or undefined if no mid line was found.
                ey.getMid = function (e) { let t = ey.matchPrefix(e, "a=mid:")[0]; if (t) return t.substring(6) },// Parses a fingerprint line for DTLS-SRTP.
                ey.parseFingerprint = function (e) { let t = e.substring(14).split(" "); return { algorithm: t[0].toLowerCase(), value: t[1].toUpperCase() } },// Extracts DTLS parameters from SDP media section or sessionpart.
                // FIXME: for consistency with other functions this should only
                //   get the fingerprint line as input. See also getIceParameters.
                ey.getDtlsParameters = function (e, t) {
                    let n = ey.matchPrefix(e + t, "a=fingerprint:");// Note: a=setup line is ignored since we use the 'auto' role in Edge.
                    return { role: "auto", fingerprints: n.map(ey.parseFingerprint) }
                },// Serializes DTLS parameters to SDP.
                ey.writeDtlsParameters = function (e, t) { let n = "a=setup:" + t + "\r\n"; return e.fingerprints.forEach(e => { n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n" }), n },// Parses a=crypto lines into
                //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
                ey.parseCryptoLine = function (e) { let t = e.substring(9).split(" "); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) } }, ey.writeCryptoLine = function (e) { return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? ey.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n" },// Parses the crypto key parameters into
                //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
                ey.parseCryptoKeyParams = function (e) { if (0 !== e.indexOf("inline:")) return null; let t = e.substring(7).split("|"); return { keyMethod: "inline", keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(":")[0] : void 0, mkiLength: t[2] ? t[2].split(":")[1] : void 0 } }, ey.writeCryptoKeyParams = function (e) { return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "") },// Extracts all SDES parameters.
                ey.getCryptoParameters = function (e, t) { let n = ey.matchPrefix(e + t, "a=crypto:"); return n.map(ey.parseCryptoLine) },// Parses ICE information from SDP media section or sessionpart.
                // FIXME: for consistency with other functions this should only
                //   get the ice-ufrag and ice-pwd lines as input.
                ey.getIceParameters = function (e, t) { let n = ey.matchPrefix(e + t, "a=ice-ufrag:")[0], r = ey.matchPrefix(e + t, "a=ice-pwd:")[0]; return n && r ? { usernameFragment: n.substring(12), password: r.substring(10) } : null },// Serializes ICE parameters to SDP.
                ey.writeIceParameters = function (e) { let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"; return e.iceLite && (t += "a=ice-lite\r\n"), t },// Parses the SDP media section and returns RTCRtpParameters.
                ey.parseRtpParameters = function (e) {
                    let t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n = ey.splitLines(e), r = n[0].split(" "); t.profile = r[2]; for (let n = 3; n < r.length; n++) {
                        let i = r[n], o = ey.matchPrefix(e, "a=rtpmap:" + i + " ")[0]; if (o) {
                            let n = ey.parseRtpMap(o), r = ey.matchPrefix(e, "a=fmtp:" + i + " ");// parse FEC mechanisms from rtpmap lines.
                            switch (// Only the first a=fmtp:<pt> is considered.
                            n.parameters = r.length ? ey.parseFmtp(r[0]) : {}, n.rtcpFeedback = ey.matchPrefix(e, "a=rtcp-fb:" + i + " ").map(ey.parseRtcpFb), t.codecs.push(n), n.name.toUpperCase()) { case "RED": case "ULPFEC": t.fecMechanisms.push(n.name.toUpperCase()) }
                        }
                    } ey.matchPrefix(e, "a=extmap:").forEach(e => { t.headerExtensions.push(ey.parseExtmap(e)) }); let i = ey.matchPrefix(e, "a=rtcp-fb:* ").map(ey.parseRtcpFb);// FIXME: parse rtcp.
                    return t.codecs.forEach(e => { i.forEach(t => { let n = e.rtcpFeedback.find(e => e.type === t.type && e.parameter === t.parameter); n || e.rtcpFeedback.push(t) }) }), t
                },// Generates parts of the SDP media section describing the capabilities /
                // parameters.
                ey.writeRtpDescription = function (e, t) {
                    let n = ""; n += "m=" + e + " " + (t.codecs.length > 0 ? "9" : "0") + " " + (t.profile || "UDP/TLS/RTP/SAVPF") + " " + t.codecs.map(e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType).join(" ") + "\r\nc=IN IP4 0.0.0.0\r\na=rtcp:9 IN IP4 0.0.0.0\r\n",// Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
                        t.codecs.forEach(e => { n += ey.writeRtpMap(e) + ey.writeFmtp(e) + ey.writeRtcpFb(e) }); let r = 0;// FIXME: write fecMechanisms.
                    return t.codecs.forEach(e => { e.maxptime > r && (r = e.maxptime) }), r > 0 && (n += "a=maxptime:" + r + "\r\n"), t.headerExtensions && t.headerExtensions.forEach(e => { n += ey.writeExtmap(e) }), n
                },// Parses the SDP media section and returns an array of
                // RTCRtpEncodingParameters.
                ey.parseRtpEncodingParameters = function (e) {
                    let t; let n = [], r = ey.parseRtpParameters(e), i = -1 !== r.fecMechanisms.indexOf("RED"), o = -1 !== r.fecMechanisms.indexOf("ULPFEC"), s = ey.matchPrefix(e, "a=ssrc:").map(e => ey.parseSsrcMedia(e)).filter(e => "cname" === e.attribute), a = s.length > 0 && s[0].ssrc, c = ey.matchPrefix(e, "a=ssrc-group:FID").map(e => { let t = e.substring(17).split(" "); return t.map(e => parseInt(e, 10)) }); c.length > 0 && c[0].length > 1 && c[0][0] === a && (t = c[0][1]), r.codecs.forEach(e => { if ("RTX" === e.name.toUpperCase() && e.parameters.apt) { let r = { ssrc: a, codecPayloadType: parseInt(e.parameters.apt, 10) }; a && t && (r.rtx = { ssrc: t }), n.push(r), i && ((r = JSON.parse(JSON.stringify(r))).fec = { ssrc: a, mechanism: o ? "red+ulpfec" : "red" }, n.push(r)) } }), 0 === n.length && a && n.push({ ssrc: a });// we support both b=AS and b=TIAS but interpret AS as TIAS.
                    let l = ey.matchPrefix(e, "b="); return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substring(7), 10) : 0 === l[0].indexOf("b=AS:") ? 950 * parseInt(l[0].substring(5), 10) - 16e3 : void 0, n.forEach(e => { e.maxBitrate = l })), n
                },// parses http://draft.ortc.org/#rtcrtcpparameters*
                ey.parseRtcpParameters = function (e) {
                    let t = {}, n = ey.matchPrefix(e, "a=ssrc:").map(e => ey.parseSsrcMedia(e)).filter(e => "cname" === e.attribute)[0]; n && (t.cname = n.value, t.ssrc = n.ssrc);// Edge uses the compound attribute instead of reducedSize
                    // compound is !reducedSize
                    let r = ey.matchPrefix(e, "a=rtcp-rsize"); t.reducedSize = r.length > 0, t.compound = 0 === r.length;// parses the rtcp-mux attrbute.
                    // Note that Edge does not support unmuxed RTCP.
                    let i = ey.matchPrefix(e, "a=rtcp-mux"); return t.mux = i.length > 0, t
                }, ey.writeRtcpParameters = function (e) { let t = ""; return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t },// parses either a=msid: or a=ssrc:... msid lines and returns
                // the id of the MediaStream and MediaStreamTrack.
                ey.parseMsid = function (e) { let t; let n = ey.matchPrefix(e, "a=msid:"); if (1 === n.length) return { stream: (t = n[0].substring(7).split(" "))[0], track: t[1] }; let r = ey.matchPrefix(e, "a=ssrc:").map(e => ey.parseSsrcMedia(e)).filter(e => "msid" === e.attribute); if (r.length > 0) return { stream: (t = r[0].value.split(" "))[0], track: t[1] } },// SCTP
                // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
                // to draft-ietf-mmusic-sctp-sdp-05
                ey.parseSctpDescription = function (e) { let t; let n = ey.parseMLine(e), r = ey.matchPrefix(e, "a=max-message-size:"); r.length > 0 && (t = parseInt(r[0].substring(19), 10)), isNaN(t) && (t = 65536); let i = ey.matchPrefix(e, "a=sctp-port:"); if (i.length > 0) return { port: parseInt(i[0].substring(12), 10), protocol: n.fmt, maxMessageSize: t }; let o = ey.matchPrefix(e, "a=sctpmap:"); if (o.length > 0) { let e = o[0].substring(10).split(" "); return { port: parseInt(e[0], 10), protocol: e[1], maxMessageSize: t } } },// SCTP
                // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
                // support by now receiving in this format, unless we originally parsed
                // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
                // protocol of DTLS/SCTP -- without UDP/ or TCP/)
                ey.writeSctpDescription = function (e, t) { let n = []; return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("") },// Generate a session ID for SDP.
                // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
                // recommends using a cryptographically random +ve 64-bit value
                // but right now this should be acceptable and within the right range
                ey.generateSessionId = function () { return Math.random().toString().substr(2, 22) },// Write boiler plate for start of SDP
                // sessId argument is optional - if not supplied it will
                // be generated randomly
                // sessVersion is optional and defaults to 2
                // sessUser is optional and defaults to 'thisisadapterortc'
                ey.writeSessionBoilerplate = function (e, t, n) { return "v=0\r\no=" + (n || "thisisadapterortc") + " " + (e || ey.generateSessionId()) + " " + (void 0 !== t ? t : 2) + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n" },// Gets the direction from the mediaSection or the sessionpart.
                ey.getDirection = function (e, t) {// Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
                    let n = ey.splitLines(e); for (let e = 0; e < n.length; e++)switch (n[e]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return n[e].substring(2) }return t ? ey.getDirection(t) : "sendrecv"
                }, ey.getKind = function (e) { let t = ey.splitLines(e), n = t[0].split(" "); return n[0].substring(2) }, ey.isRejected = function (e) { return "0" === e.split(" ", 2)[1] }, ey.parseMLine = function (e) { let t = ey.splitLines(e), n = t[0].substring(2).split(" "); return { kind: n[0], port: parseInt(n[1], 10), protocol: n[2], fmt: n.slice(3).join(" ") } }, ey.parseOLine = function (e) { let t = ey.matchPrefix(e, "o=")[0], n = t.substring(2).split(" "); return { username: n[0], sessionId: n[1], sessionVersion: parseInt(n[2], 10), netType: n[3], addressType: n[4], address: n[5] } },// a very naive interpretation of a valid SDP.
                ey.isValidSDP = function (e) { if ("string" != typeof e || 0 === e.length) return !1; let t = ey.splitLines(e); for (let e = 0; e < t.length; e++)if (t[e].length < 2 || "=" !== t[e].charAt(1)) return !1; return !0 }, eg = ey; let ew = function ({ window: e } = {}, t = { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }) {
                    let n = function (e) {// Returned result object.
                        let t = { browser: null, version: null };// Fail early if it's not a browser
                        if (void 0 === e || !e.navigator || !e.navigator.userAgent) return t.browser = "Not a browser.", t; let { navigator: n } = e; return n.mozGetUserMedia ? (t.browser = "firefox", t.version = p(n.userAgent, /Firefox\/(\d+)\./, 1)) : n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection ? (// Chrome, Chromium, Webview, Opera.
                            // Version matches Chrome/WebRTC version.
                            // Chrome 74 removed webkitGetUserMedia on http as well so we need the
                            // more complicated fallback to webkitRTCPeerConnection.
                            t.browser = "chrome", t.version = p(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2)) : e.RTCPeerConnection && n.userAgent.match(/AppleWebKit\/(\d+)\./) ? (t.browser = "safari", t.version = p(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype) : t.browser = "Not a supported browser.", t
                    }(e), r = { browserDetails: n, commonShim: em, extractVersion: p, disableLog: h, disableWarnings: u, sdp: eg };// Shim browser if found.
                    switch (n.browser) {
                        case "chrome": if (!j || !j.shimPeerConnection || !t.shimChrome) { f("Chrome shim is not included in this adapter release."); break } if (null === n.version) { f("Chrome shim can not determine version, not shimming."); break } f("adapter.js shimming chrome."),// Export to the adapter global object visible in the browser.
                            r.browserShim = j,// Must be called before shimPeerConnection.
                            eT(e, n), eR(e, n), j.shimGetUserMedia(e, n), j.shimMediaStream(e, n), j.shimPeerConnection(e, n), j.shimOnTrack(e, n), j.shimAddTrackRemoveTrack(e, n), j.shimGetSendersWithDtmf(e, n), j.shimGetStats(e, n), j.shimSenderReceiverGetStats(e, n), j.fixNegotiationNeeded(e, n), e_(e, n), eC(e, n), ek(e, n), ev(e, n), eb(e, n), eS(e, n); break; case "firefox": if (!W || !W.shimPeerConnection || !t.shimFirefox) { f("Firefox shim is not included in this adapter release."); break } f("adapter.js shimming firefox."),// Export to the adapter global object visible in the browser.
                                r.browserShim = W,// Must be called before shimPeerConnection.
                                eT(e, n), eR(e, n), W.shimGetUserMedia(e, n), W.shimPeerConnection(e, n), W.shimOnTrack(e, n), W.shimRemoveStream(e, n), W.shimSenderGetStats(e, n), W.shimReceiverGetStats(e, n), W.shimRTCDataChannel(e, n), W.shimAddTransceiver(e, n), W.shimGetParameters(e, n), W.shimCreateOffer(e, n), W.shimCreateAnswer(e, n), e_(e, n), ek(e, n), ev(e, n), eb(e, n); break; case "safari": if (!eo || !t.shimSafari) { f("Safari shim is not included in this adapter release."); break } f("adapter.js shimming safari."),// Export to the adapter global object visible in the browser.
                                    r.browserShim = eo,// Must be called before shimCallbackAPI.
                                    eT(e, n), eR(e, n), eo.shimRTCIceServerUrls(e, n), eo.shimCreateOfferLegacy(e, n), eo.shimCallbacksAPI(e, n), eo.shimLocalStreamsAPI(e, n), eo.shimRemoteStreamsAPI(e, n), eo.shimTrackEventTransceiver(e, n), eo.shimGetUserMedia(e, n), eo.shimAudioContext(e, n), e_(e, n), eC(e, n), ev(e, n), eb(e, n), eS(e, n); break; default: f("Unsupported browser!")
                    }return r
                }({ window: "undefined" == typeof window ? void 0 : window }), eP = ew.default || ew, eE = new class {
                    isWebRTCSupported() { return "undefined" != typeof RTCPeerConnection } isBrowserSupported() { let e = this.getBrowser(), t = this.getVersion(), n = this.supportedBrowsers.includes(e); return !!n && ("chrome" === e ? t >= this.minChromeVersion : "firefox" === e ? t >= this.minFirefoxVersion : "safari" === e && !this.isIOS && t >= this.minSafariVersion) } getBrowser() { return eP.browserDetails.browser } getVersion() { return eP.browserDetails.version || 0 } isUnifiedPlanSupported() { let e; let t = this.getBrowser(), n = eP.browserDetails.version || 0; if ("chrome" === t && n < this.minChromeVersion) return !1; if ("firefox" === t && n >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; let r = !1; try { (e = new RTCPeerConnection).addTransceiver("audio"), r = !0 } catch (e) { } finally { e && e.close() } return r } toString() {
                        return `Supports:
    browser:${this.getBrowser()}
    version:${this.getVersion()}
    isIOS:${this.isIOS}
    isWebRTCSupported:${this.isWebRTCSupported()}
    isBrowserSupported:${this.isBrowserSupported()}
    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`
                    } constructor() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 }
                }, eD = e => !e || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(e), ex = () => Math.random().toString(36).slice(2), eI = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, eM = new class extends n {
                    noop() { } blobToArrayBuffer(e, t) { let n = new FileReader; return n.onload = function (e) { e.target && t(e.target.result) }, n.readAsArrayBuffer(e), n } binaryStringToArrayBuffer(e) { let t = new Uint8Array(e.length); for (let n = 0; n < e.length; n++)t[n] = 255 & e.charCodeAt(n); return t.buffer } isSecure() { return "https:" === location.protocol } constructor(...e) {
                        super(...e), this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443,// Browsers that need chunking:
                            this.chunkedBrowsers = { Chrome: 1, chrome: 1 },// Returns browser-agnostic default config
                            this.defaultConfig = eI, this.browser = eE.getBrowser(), this.browserVersion = eE.getVersion(), this.pack = o, this.unpack = i,/**
	 * A hash of WebRTC features mapped to booleans that correspond to whether the feature is supported by the current browser.
	 *
	 * :::caution
	 * Only the properties documented here are guaranteed to be present on `util.supports`
	 * :::
	 */this.supports = function () {
                                let e; let t = { browser: eE.isBrowserSupported(), webRTC: eE.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!t.webRTC) return t; try {
                                    let n; e = new RTCPeerConnection(eI), t.audioVideo = !0; try {
                                        n = e.createDataChannel("_PEERJSTEST", { ordered: !0 }), t.data = !0, t.reliable = !!n.ordered;// Binary test
                                        try { n.binaryType = "blob", t.binaryBlob = !eE.isIOS } catch (e) { }
                                    } catch (e) { } finally { n && n.close() }
                                } catch (e) { } finally { e && e.close() } return t
                            }(),// Ensure alphanumeric ids
                            this.validateId = eD, this.randomToken = ex
                    }
                }; (_ = w || (w = {}))[_./**
	 * Prints no logs.
	 */Disabled = 0] = "Disabled", _[_./**
	 * Prints only errors.
	 */Errors = 1] = "Errors", _[_./**
	 * Prints errors and warnings.
	 */Warnings = 2] = "Warnings", _[_./**
	 * Prints all logs.
	 */All = 3] = "All"; var eO = new class { get logLevel() { return this._logLevel } set logLevel(e) { this._logLevel = e } log(...e) { this._logLevel >= w.All && this._print(w.All, ...e) } warn(...e) { this._logLevel >= w.Warnings && this._print(w.Warnings, ...e) } error(...e) { this._logLevel >= w.Errors && this._print(w.Errors, ...e) } setLogFunction(e) { this._print = e } _print(e, ...t) { let n = ["PeerJS: ", ...t]; for (let e in n) n[e] instanceof Error && (n[e] = "(" + n[e].name + ") " + n[e].message); e >= w.All ? console.log(...n) : e >= w.Warnings ? console.warn("WARNING", ...n) : e >= w.Errors && console.error("ERROR", ...n) } constructor() { this._logLevel = w.Disabled } }, ej = {}, eL = Object.prototype.hasOwnProperty, eA = "~";/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */function eB() { }/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */function eF(e, t, n) { this.fn = e, this.context = t, this.once = n || !1 }/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */function ez(e, t, n, r, i) { if ("function" != typeof n) throw TypeError("The listener must be a function"); var o = new eF(n, r || e, i), s = eA ? eA + t : t; return e._events[s] ? e._events[s].fn ? e._events[s] = [e._events[s], o] : e._events[s].push(o) : (e._events[s] = o, e._eventsCount++), e }/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */function eU(e, t) { 0 == --e._eventsCount ? e._events = new eB : delete e._events[t] }/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */function eN() { this._events = new eB, this._eventsCount = 0 } Object.create && (eB.prototype = Object.create(null), new eB().__proto__ || (eA = !1)),/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */eN.prototype.eventNames = function () { var e, t, n = []; if (0 === this._eventsCount) return n; for (t in e = this._events) eL.call(e, t) && n.push(eA ? t.slice(1) : t); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(e)) : n },/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */eN.prototype.listeners = function (e) { var t = eA ? eA + e : e, n = this._events[t]; if (!n) return []; if (n.fn) return [n.fn]; for (var r = 0, i = n.length, o = Array(i); r < i; r++)o[r] = n[r].fn; return o },/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */eN.prototype.listenerCount = function (e) { var t = eA ? eA + e : e, n = this._events[t]; return n ? n.fn ? 1 : n.length : 0 },/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */eN.prototype.emit = function (e, t, n, r, i, o) { var s = eA ? eA + e : e; if (!this._events[s]) return !1; var a, c, l = this._events[s], p = arguments.length; if (l.fn) { switch (l.once && this.removeListener(e, l.fn, void 0, !0), p) { case 1: return l.fn.call(l.context), !0; case 2: return l.fn.call(l.context, t), !0; case 3: return l.fn.call(l.context, t, n), !0; case 4: return l.fn.call(l.context, t, n, r), !0; case 5: return l.fn.call(l.context, t, n, r, i), !0; case 6: return l.fn.call(l.context, t, n, r, i, o), !0 }for (c = 1, a = Array(p - 1); c < p; c++)a[c - 1] = arguments[c]; l.fn.apply(l.context, a) } else { var d, h = l.length; for (c = 0; c < h; c++)switch (l[c].once && this.removeListener(e, l[c].fn, void 0, !0), p) { case 1: l[c].fn.call(l[c].context); break; case 2: l[c].fn.call(l[c].context, t); break; case 3: l[c].fn.call(l[c].context, t, n); break; case 4: l[c].fn.call(l[c].context, t, n, r); break; default: if (!a) for (d = 1, a = Array(p - 1); d < p; d++)a[d - 1] = arguments[d]; l[c].fn.apply(l[c].context, a) } } return !0 },/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */eN.prototype.on = function (e, t, n) { return ez(this, e, t, n, !1) },/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */eN.prototype.once = function (e, t, n) { return ez(this, e, t, n, !0) },/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */eN.prototype.removeListener = function (e, t, n, r) {
                    var i = eA ? eA + e : e; if (!this._events[i]) return this; if (!t) return eU(this, i), this; var o = this._events[i]; if (o.fn) o.fn !== t || r && !o.once || n && o.context !== n || eU(this, i); else {
                        for (var s = 0, a = [], c = o.length; s < c; s++)(o[s].fn !== t || r && !o[s].once || n && o[s].context !== n) && a.push(o[s]);//
                        // Reset the array, or remove it completely if we have no more listeners.
                        //
                        a.length ? this._events[i] = 1 === a.length ? a[0] : a : eU(this, i)
                    } return this
                },/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */eN.prototype.removeAllListeners = function (e) { var t; return e ? (t = eA ? eA + e : e, this._events[t] && eU(this, t)) : (this._events = new eB, this._eventsCount = 0), this },//
                // Alias methods names because people roll like that.
                //
                eN.prototype.off = eN.prototype.removeListener, eN.prototype.addListener = eN.prototype.on,//
                // Expose the prefix.
                //
                eN.prefixed = eA,//
                // Allow `EventEmitter` to be imported as module namespace.
                //
                eN.EventEmitter = eN, ej = eN, (C = P || (P = {})).Data = "data", C.Media = "media", (v = E || (E = {}))./**
	 * The client's browser does not support some or all WebRTC features that you are trying to use.
	 */BrowserIncompatible = "browser-incompatible", v./**
	 * You've already disconnected this peer from the server and can no longer make any new connections on it.
	 */Disconnected = "disconnected", v./**
	 * The ID passed into the Peer constructor contains illegal characters.
	 */InvalidID = "invalid-id", v./**
	 * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).
	 */InvalidKey = "invalid-key", v./**
	 * Lost or cannot establish a connection to the signalling server.
	 */Network = "network", v./**
	 * The peer you're trying to connect to does not exist.
	 */PeerUnavailable = "peer-unavailable", v./**
	 * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.
	 */SslUnavailable = "ssl-unavailable", v./**
	 * Unable to reach the server.
	 */ServerError = "server-error", v./**
	 * An error from the underlying socket.
	 */SocketError = "socket-error", v./**
	 * The underlying socket closed unexpectedly.
	 */SocketClosed = "socket-closed", v./**
	 * The ID passed into the Peer constructor is already taken.
	 *
	 * :::caution
	 * This error is not fatal if your peer has open peer-to-peer connections.
	 * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,
	 * but its old ID has now been taken.
	 * :::
	 */UnavailableID = "unavailable-id", v./**
	 * Native WebRTC errors.
	 */WebRTC = "webrtc", (b = D || (D = {})).NegotiationFailed = "negotiation-failed", b.ConnectionClosed = "connection-closed", (k = x || (x = {})).NotOpenYet = "not-open-yet", k.MessageToBig = "message-too-big", (S = I || (I = {})).Binary = "binary", S.BinaryUTF8 = "binary-utf8", S.JSON = "json", S.None = "raw", (T = M || (M = {})).Message = "message", T.Disconnected = "disconnected", T.Error = "error", T.Close = "close", (R = O || (O = {})).Heartbeat = "HEARTBEAT", R.Candidate = "CANDIDATE", R.Offer = "OFFER", R.Answer = "ANSWER", R.Open = "OPEN", R.Error = "ERROR", R.IdTaken = "ID-TAKEN", R.InvalidKey = "INVALID-KEY", R.Leave = "LEAVE", R.Expire = "EXPIRE"; var e$ = {}; e$ = JSON.parse('{"name":"peerjs","version":"1.5.1","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xfcckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","Soren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","browser-minified-cbor":"dist/serializer.cbor.mjs","browser-minified-msgpack":"dist/serializer.msgpack.mjs","types":"dist/types.d.ts","engines":{"node":">= 14"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"},"source":"lib/global.ts"},"browser-minified-cbor":{"context":"browser","outputFormat":"esmodule","isLibrary":true,"optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"},"source":"lib/dataconnection/StreamConnection/Cbor.ts"},"browser-minified-msgpack":{"context":"browser","outputFormat":"esmodule","isLibrary":true,"optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"},"source":"lib/dataconnection/StreamConnection/MsgPack.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit && tsc -p e2e/tsconfig.json --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"jest","test:watch":"jest --watch","coverage":"jest --coverage --collectCoverageFrom=\\"./lib/**\\"","format":"prettier --write .","format:check":"prettier --check .","semantic-release":"semantic-release","e2e":"wdio run e2e/wdio.local.conf.ts","e2e:bstack":"wdio run e2e/wdio.bstack.conf.ts"},"devDependencies":{"@parcel/config-default":"^2.9.3","@parcel/packager-ts":"^2.9.3","@parcel/transformer-typescript-tsc":"^2.9.3","@parcel/transformer-typescript-types":"^2.9.3","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@swc/core":"^1.3.27","@swc/jest":"^0.2.24","@types/jasmine":"^4.3.4","@wdio/browserstack-service":"^8.11.2","@wdio/cli":"^8.11.2","@wdio/globals":"^8.11.2","@wdio/jasmine-framework":"^8.11.2","@wdio/local-runner":"^8.11.2","@wdio/spec-reporter":"^8.11.2","@wdio/types":"^8.10.4","http-server":"^14.1.1","jest":"^29.3.1","jest-environment-jsdom":"^29.3.1","mock-socket":"^9.0.0","parcel":"^2.9.3","prettier":"^3.0.0","semantic-release":"^21.0.0","ts-node":"^10.9.1","typescript":"^5.0.0","wdio-geckodriver-service":"^5.0.1"},"dependencies":{"@msgpack/msgpack":"^2.8.0","cbor-x":"^1.5.3","eventemitter3":"^4.0.7","peerjs-js-binarypack":"^2.0.0","webrtc-adapter":"^8.0.0"},"alias":{"process":false,"buffer":false}}'); class eJ extends ej.EventEmitter {
                start(e, t) {
                    this._id = e; let n = `${this._baseUrl}&id=${e}&token=${t}`; !this._socket && this._disconnected && (this._socket = new WebSocket(n + "&version=" + e$.version), this._disconnected = !1, this._socket.onmessage = e => { let t; try { t = JSON.parse(e.data), eO.log("Server message received:", t) } catch (t) { eO.log("Invalid server message", e.data); return } this.emit(M.Message, t) }, this._socket.onclose = e => { this._disconnected || (eO.log("Socket closed.", e), this._cleanup(), this._disconnected = !0, this.emit(M.Disconnected)) },// Take care of the queue of connections if necessary and make sure Peer knows
                        // socket is open.
                        this._socket.onopen = () => { this._disconnected || (this._sendQueuedMessages(), eO.log("Socket open"), this._scheduleHeartbeat()) })
                } _scheduleHeartbeat() { this._wsPingTimer = setTimeout(() => { this._sendHeartbeat() }, this.pingInterval) } _sendHeartbeat() { if (!this._wsOpen()) { eO.log("Cannot send heartbeat, because socket closed"); return } let e = JSON.stringify({ type: O.Heartbeat }); this._socket.send(e), this._scheduleHeartbeat() }/** Is the websocket currently open? */_wsOpen() { return !!this._socket && 1 === this._socket.readyState }/** Send queued messages. */_sendQueuedMessages() {//Create copy of queue and clear it,
                    //because send method push the message back to queue if smth will go wrong
                    let e = [...this._messagesQueue]; for (let t of (this._messagesQueue = [], e)) this.send(t)
                }/** Exposed send for DC & Peer. */send(e) {
                    if (this._disconnected) return;// If we didn't get an ID yet, we can't yet send anything so we should queue
                    // up these messages.
                    if (!this._id) { this._messagesQueue.push(e); return } if (!e.type) { this.emit(M.Error, "Invalid message"); return } if (!this._wsOpen()) return; let t = JSON.stringify(e); this._socket.send(t)
                } close() { this._disconnected || (this._cleanup(), this._disconnected = !0) } _cleanup() { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) } constructor(e, t, n, r, i, o = 5e3) { super(), this.pingInterval = o, this._disconnected = !0, this._messagesQueue = [], this._baseUrl = (e ? "wss://" : "ws://") + t + ":" + n + r + "peerjs?key=" + i }
            } class eV {/** Returns a PeerConnection object set up correctly (for data, media). */startConnection(e) {
                let t = this._startPeerConnection();// What do we need to do now?
                if (// Set the connection's PC.
                    this.connection.peerConnection = t, this.connection.type === P.Media && e._stream && this._addTracksToConnection(e._stream, t), e.originator) { let n = this.connection, r = { ordered: !!e.reliable }, i = t.createDataChannel(n.label, r); n._initializeDataChannel(i), this._makeOffer() } else this.handleSDP("OFFER", e.sdp)
            }/** Start a PC. */_startPeerConnection() { eO.log("Creating RTCPeerConnection."); let e = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(e), e }/** Set up various WebRTC listeners. */_setupListeners(e) {
                let t = this.connection.peer, n = this.connection.connectionId, r = this.connection.type, i = this.connection.provider; eO.log("Listening for ICE candidates."), e.onicecandidate = e => { e.candidate && e.candidate.candidate && (eO.log(`Received ICE candidates for ${t}:`, e.candidate), i.socket.send({ type: O.Candidate, payload: { candidate: e.candidate, type: r, connectionId: n }, dst: t })) }, e.oniceconnectionstatechange = () => { switch (e.iceConnectionState) { case "failed": eO.log("iceConnectionState is failed, closing connections to " + t), this.connection.emitError(D.NegotiationFailed, "Negotiation of connection to " + t + " failed."), this.connection.close(); break; case "closed": eO.log("iceConnectionState is closed, closing connections to " + t), this.connection.emitError(D.ConnectionClosed, "Connection to " + t + " closed."), this.connection.close(); break; case "disconnected": eO.log("iceConnectionState changed to disconnected on the connection with " + t); break; case "completed": e.onicecandidate = () => { } }this.connection.emit("iceStateChanged", e.iceConnectionState) }, eO.log("Listening for data channel"),// Fired between offer and answer, so options should already be saved
                    // in the options hash.
                    e.ondatachannel = e => { eO.log("Received data channel"); let r = e.channel, o = i.getConnection(t, n); o._initializeDataChannel(r) }, eO.log("Listening for remote stream"), e.ontrack = e => { eO.log("Received remote stream"); let r = e.streams[0], o = i.getConnection(t, n); o.type === P.Media && this._addStreamToMediaConnection(r, o) }
            } cleanup() {
                eO.log("Cleaning up PeerConnection to " + this.connection.peer); let e = this.connection.peerConnection; if (!e) return; this.connection.peerConnection = null,//unsubscribe from all PeerConnection's events
                    e.onicecandidate = e.oniceconnectionstatechange = e.ondatachannel = e.ontrack = () => { }; let t = "closed" !== e.signalingState, n = !1, r = this.connection.dataChannel; r && (n = !!r.readyState && "closed" !== r.readyState), (t || n) && e.close()
            } async _makeOffer() {
                let e = this.connection.peerConnection, t = this.connection.provider; try {
                    let n = await e.createOffer(this.connection.options.constraints); eO.log("Created offer."), this.connection.options.sdpTransform && "function" == typeof this.connection.options.sdpTransform && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp); try { await e.setLocalDescription(n), eO.log("Set localDescription:", n, `for:${this.connection.peer}`); let r = { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata }; if (this.connection.type === P.Data) { let e = this.connection; r = { ...r, label: e.label, reliable: e.reliable, serialization: e.serialization } } t.socket.send({ type: O.Offer, payload: r, dst: this.connection.peer }) } catch (e) {// TODO: investigate why _makeOffer is being called from the answer
                        "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" != e && (t.emitError(E.WebRTC, e), eO.log("Failed to setLocalDescription, ", e))
                    }
                } catch (e) { t.emitError(E.WebRTC, e), eO.log("Failed to createOffer, ", e) }
            } async _makeAnswer() { let e = this.connection.peerConnection, t = this.connection.provider; try { let n = await e.createAnswer(); eO.log("Created answer."), this.connection.options.sdpTransform && "function" == typeof this.connection.options.sdpTransform && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp); try { await e.setLocalDescription(n), eO.log("Set localDescription:", n, `for:${this.connection.peer}`), t.socket.send({ type: O.Answer, payload: { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId }, dst: this.connection.peer }) } catch (e) { t.emitError(E.WebRTC, e), eO.log("Failed to setLocalDescription, ", e) } } catch (e) { t.emitError(E.WebRTC, e), eO.log("Failed to create answer, ", e) } }/** Handle an SDP. */async handleSDP(e, t) { t = new RTCSessionDescription(t); let n = this.connection.peerConnection, r = this.connection.provider; eO.log("Setting remote description", t); try { await n.setRemoteDescription(t), eO.log(`Set remoteDescription:${e} for:${this.connection.peer}`), "OFFER" === e && await this._makeAnswer() } catch (e) { r.emitError(E.WebRTC, e), eO.log("Failed to setRemoteDescription, ", e) } }/** Handle a candidate. */async handleCandidate(e) { eO.log("handleCandidate:", e); try { await this.connection.peerConnection.addIceCandidate(e), eO.log(`Added ICE candidate for:${this.connection.peer}`) } catch (e) { this.connection.provider.emitError(E.WebRTC, e), eO.log("Failed to handleCandidate, ", e) } } _addTracksToConnection(e, t) { if (eO.log(`add tracks from stream ${e.id} to peer connection`), !t.addTrack) return eO.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); e.getTracks().forEach(n => { t.addTrack(n, e) }) } _addStreamToMediaConnection(e, t) { eO.log(`add stream ${e.id} to media connection ${t.connectionId}`), t.addStream(e) } constructor(e) { this.connection = e }
            } class eG extends ej.EventEmitter {/**
	 * Emits a typed error message.
	 *
	 * @internal
	 */emitError(e, t) {
                    eO.error("Error:", t),// @ts-ignore
                        this.emit("error", new eW(`${e}`, t))
                }
            } class eW extends Error {/**
	 * @internal
	 */constructor(e, t) { "string" == typeof t ? super(t) : (super(), Object.assign(this, t)), this.type = e }
            } class eH extends eG {/**
	 * Whether the media connection is active (e.g. your call has been answered).
	 * You can check this if you want to set a maximum wait time for a one-sided call.
	 */get open() { return this._open } constructor(e, t, n) { super(), this.peer = e, this.provider = t, this.options = n, this._open = !1, this.metadata = n.metadata }
            } class eY extends eH {/**
	 * For media connections, this is always 'media'.
	 */get type() { return P.Media } get localStream() { return this._localStream } get remoteStream() { return this._remoteStream }/** Called by the Negotiator when the DataChannel is ready. */_initializeDataChannel(e) { this.dataChannel = e, this.dataChannel.onopen = () => { eO.log(`DC#${this.connectionId} dc connection success`), this.emit("willCloseOnRemote") }, this.dataChannel.onclose = () => { eO.log(`DC#${this.connectionId} dc closed for:`, this.peer), this.close() } } addStream(e) { eO.log("Receiving stream", e), this._remoteStream = e, super.emit("stream", e) }/**
	 * @internal
	 */handleMessage(e) { let t = e.type, n = e.payload; switch (e.type) { case O.Answer: this._negotiator.handleSDP(t, n.sdp), this._open = !0; break; case O.Candidate: this._negotiator.handleCandidate(n.candidate); break; default: eO.warn(`Unrecognized message type:${t} from peer:${this.peer}`) } }/**
     * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call
     * `answer` on the media connection provided by the callback to accept the call
     * and optionally send your own media stream.

     *
     * @param stream A WebRTC media stream.
     * @param options
     * @returns
     */answer(e, t = {}) {
                    if (this._localStream) { eO.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = e, t && t.sdpTransform && (this.options.sdpTransform = t.sdpTransform), this._negotiator.startConnection({ ...this.options._payload, _stream: e });// Retrieve lost messages stored because PeerConnection not set up.
                    let n = this.provider._getMessages(this.connectionId); for (let e of n) this.handleMessage(e); this._open = !0
                }/**
	 * Exposed functionality for users.
	 *//**
	 * Closes the media connection.
	 */close() { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, super.emit("close")) } constructor(e, t, n) { super(e, t, n), this._localStream = this.options._stream, this.connectionId = this.options.connectionId || eY.ID_PREFIX + eM.randomToken(), this._negotiator = new eV(this), this._localStream && this._negotiator.startConnection({ _stream: this._localStream, originator: !0 }) }
            } eY.ID_PREFIX = "mc_"; class eK {
                _buildRequest(e) {
                    let t = this._options.secure ? "https" : "http", { host: n, port: r, path: i, key: o } = this._options, s = new URL(`${t}://${n}:${r}${i}${o}/${e}`); return (// TODO: Why timestamp, why random?
                        s.searchParams.set("ts", `${Date.now()}${Math.random()}`), s.searchParams.set("version", e$.version), fetch(s.href, { referrerPolicy: this._options.referrerPolicy }))
                }/** Get a unique ID from the server via XHR and initialize with it. */async retrieveId() { try { let e = await this._buildRequest("id"); if (200 !== e.status) throw Error(`Error. Status:${e.status}`); return e.text() } catch (t) { eO.error("Error retrieving ID", t); let e = ""; throw "/" === this._options.path && this._options.host !== eM.CLOUD_HOST && (e = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), Error("Could not get an ID from the server." + e) } }/** @deprecated */async listAllPeers() { try { let e = await this._buildRequest("peers"); if (200 !== e.status) { if (401 === e.status) { let e = ""; throw e = this._options.host === eM.CLOUD_HOST ? "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", Error("It doesn't look like you have permission to list peers IDs. " + e) } throw Error(`Error. Status:${e.status}`) } return e.json() } catch (e) { throw eO.error("Error retrieving list peers", e), Error("Could not get list peers from the server." + e) } } constructor(e) { this._options = e }
            } class eX extends eH {
                get type() { return P.Data }/** Called by the Negotiator when the DataChannel is ready. */_initializeDataChannel(e) {
                    this.dataChannel = e, this.dataChannel.onopen = () => { eO.log(`DC#${this.connectionId} dc connection success`), this._open = !0, this.emit("open") }, this.dataChannel.onmessage = e => {
                        eO.log(`DC#${this.connectionId} dc onmessage:`, e.data);// this._handleDataMessage(e);
                    }, this.dataChannel.onclose = () => { eO.log(`DC#${this.connectionId} dc closed for:`, this.peer), this.close() }
                }/**
	 * Exposed functionality for users.
	 *//** Allows user to close connection. */close(e) { if (e?.flush) { this.send({ __peerData: { type: "close" } }); return } this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this.dataChannel = null), this.open && (this._open = !1, super.emit("close")) }/** Allows user to send data. */send(e, t = !1) { if (!this.open) { this.emitError(x.NotOpenYet, "Connection is not open. You should listen for the `open` event before sending messages."); return } return this._send(e, t) } async handleMessage(e) { let t = e.payload; switch (e.type) { case O.Answer: await this._negotiator.handleSDP(e.type, t.sdp); break; case O.Candidate: await this._negotiator.handleCandidate(t.candidate); break; default: eO.warn("Unrecognized message type:", e.type, "from peer:", this.peer) } } constructor(e, t, n) { super(e, t, n), this.connectionId = this.options.connectionId || eX.ID_PREFIX + ex(), this.label = this.options.label || this.connectionId, this.reliable = !!this.options.reliable, this._negotiator = new eV(this), this._negotiator.startConnection(this.options._payload || { originator: !0, reliable: this.reliable }) }
            } eX.ID_PREFIX = "dc_", eX.MAX_BUFFERED_AMOUNT = 8388608; class eq extends eX {
                get bufferSize() { return this._bufferSize } _initializeDataChannel(e) { super._initializeDataChannel(e), this.dataChannel.binaryType = "arraybuffer", this.dataChannel.addEventListener("message", e => this._handleDataMessage(e)) } _bufferedSend(e) { (this._buffering || !this._trySend(e)) && (this._buffer.push(e), this._bufferSize = this._buffer.length) }// Returns true if the send succeeds.
                _trySend(e) { if (!this.open) return !1; if (this.dataChannel.bufferedAmount > eX.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(() => { this._buffering = !1, this._tryBuffer() }, 50), !1; try { this.dataChannel.send(e) } catch (e) { return eO.error(`DC#:${this.connectionId} Error when sending:`, e), this._buffering = !0, this.close(), !1 } return !0 }// Try to send the first message in the buffer.
                _tryBuffer() { if (!this.open || 0 === this._buffer.length) return; let e = this._buffer[0]; this._trySend(e) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } close(e) { if (e?.flush) { this.send({ __peerData: { type: "close" } }); return } this._buffer = [], this._bufferSize = 0, super.close() } constructor(...e) { super(...e), this._buffer = [], this._bufferSize = 0, this._buffering = !1 }
            } class eQ extends eq {
                close(e) { super.close(e), this._chunkedData = {} }// Handles a DataChannel message.
                _handleDataMessage({ data: e }) {
                    let t = i(e), n = t.__peerData; if (n) {
                        if ("close" === n.type) { this.close(); return }// Chunked data -- piece things back together.
                        // @ts-ignore
                        this._handleChunk(t); return
                    } this.emit("data", t)
                } _handleChunk(e) {
                    let t = e.__peerData, n = this._chunkedData[t] || { data: [], count: 0, total: e.total }; if (n.data[e.n] = new Uint8Array(e.data), n.count++, this._chunkedData[t] = n, n.total === n.count) {// Clean up before making the recursive call to `_handleDataMessage`.
                        delete this._chunkedData[t];// We've received all the chunks--time to construct the complete data.
                        // const data = new Blob(chunkInfo.data);
                        let e = function (e) { let t = 0; for (let n of e) t += n.byteLength; let n = new Uint8Array(t), r = 0; for (let t of e) n.set(t, r), r += t.byteLength; return n }(n.data); this._handleDataMessage({ data: e })
                    }
                } _send(e, t) { if (e instanceof Blob) return e.arrayBuffer().then(e => { this._send(e, t) }); let n = o(e); if (!t && n.byteLength > this.chunker.chunkedMTU) { this._sendChunks(n); return } this._bufferedSend(n) } _sendChunks(e) { let t = this.chunker.chunk(e); for (let e of (eO.log(`DC#${this.connectionId} Try to send ${t.length} chunks...`), t)) this.send(e, !0) } constructor(e, t, r) { super(e, t, r), this.chunker = new n, this.serialization = I.Binary, this._chunkedData = {} }
            } class eZ extends eq { _handleDataMessage({ data: e }) { super.emit("data", e) } _send(e, t) { this._bufferedSend(e) } constructor(...e) { super(...e), this.serialization = I.None } } class e0 extends eq {// Handles a DataChannel message.
                _handleDataMessage({ data: e }) { let t = this.parse(this.decoder.decode(e)), n = t.__peerData; if (n && "close" === n.type) { this.close(); return } this.emit("data", t) } _send(e, t) { let n = this.encoder.encode(this.stringify(e)); if (n.byteLength >= eM.chunkedMTU) { this.emitError(x.MessageToBig, "Message too big for JSON channel"); return } this._bufferedSend(n) } constructor(...e) { super(...e), this.serialization = I.JSON, this.encoder = new TextEncoder, this.decoder = new TextDecoder, this.stringify = JSON.stringify, this.parse = JSON.parse }
            } class e1 extends eG {/**
	 * The brokering ID of this peer
	 *
	 * If no ID was specified in {@apilink Peer | the constructor},
	 * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.
	 */get id() { return this._id } get options() { return this._options } get open() { return this._open }/**
	 * @internal
	 */get socket() { return this._socket }/**
	 * A hash of all connections associated with this peer, keyed by the remote peer's ID.
	 * @deprecated
	 * Return type will change from Object to Map<string,[]>
	 */get connections() { let e = Object.create(null); for (let [t, n] of this._connections) e[t] = n; return e }/**
	 * true if this peer and all of its connections can no longer be used.
	 */get destroyed() { return this._destroyed }/**
	 * false if there is an active connection to the PeerServer.
	 */get disconnected() { return this._disconnected } _createServerConnection() { let e = new eJ(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return e.on(M.Message, e => { this._handleMessage(e) }), e.on(M.Error, e => { this._abort(E.SocketError, e) }), e.on(M.Disconnected, () => { this.disconnected || (this.emitError(E.Network, "Lost connection to server."), this.disconnect()) }), e.on(M.Close, () => { this.disconnected || this._abort(E.SocketClosed, "Underlying socket is already closed.") }), e }/** Initialize a connection with the server. */_initialize(e) { this._id = e, this.socket.start(e, this._options.token) }/** Handles messages from the server. */_handleMessage(e) {
                    let t = e.type, n = e.payload, r = e.src; switch (t) {
                        case O.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case O.Error: this._abort(E.ServerError, n.msg); break; case O.IdTaken: this._abort(E.UnavailableID, `ID "${this.id}" is taken`); break; case O.InvalidKey: this._abort(E.InvalidKey, `API KEY "${this._options.key}" is invalid`); break; case O.Leave: eO.log(`Received leave message from ${r}`), this._cleanupPeer(r), this._connections.delete(r); break; case O.Expire: this.emitError(E.PeerUnavailable, `Could not connect to peer ${r}`); break; case O.Offer: {// we should consider switching this to CALL/CONNECT, but this is the least breaking option.
                            let e = n.connectionId, t = this.getConnection(r, e);// Create a new connection.
                            if (t && (t.close(), eO.warn(`Offer received for existing Connection ID:${e}`)), n.type === P.Media) { let i = new eY(r, this, { connectionId: e, _payload: n, metadata: n.metadata }); t = i, this._addConnection(r, t), this.emit("call", i) } else if (n.type === P.Data) { let i = new this._serializers[n.serialization](r, this, { connectionId: e, _payload: n, metadata: n.metadata, label: n.label, serialization: n.serialization, reliable: n.reliable }); t = i, this._addConnection(r, t), this.emit("connection", i) } else { eO.warn(`Received malformed connection type:${n.type}`); return }// Find messages.
                            let i = this._getMessages(e); for (let e of i) t.handleMessage(e); break
                        } default: { if (!n) { eO.warn(`You received a malformed message from ${r} of type ${t}`); return } let i = n.connectionId, o = this.getConnection(r, i); o && o.peerConnection ? o.handleMessage(e) : i ? this._storeMessage(i, e) : eO.warn("You received an unrecognized message:", e) }
                    }
                }/** Stores messages without a set up connection, to be claimed later. */_storeMessage(e, t) { this._lostMessages.has(e) || this._lostMessages.set(e, []), this._lostMessages.get(e).push(t) }/**
	 * Retrieve messages from lost message store
	 * @internal
	 *///TODO Change it to private
                _getMessages(e) { let t = this._lostMessages.get(e); return t ? (this._lostMessages.delete(e), t) : [] }/**
	 * Connects to the remote peer specified by id and returns a data connection.
	 * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).
	 * @param options for specifying details about Peer Connection
	 */connect(e, t = {}) { if (t = { serialization: "default", ...t }, this.disconnected) { eO.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(E.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } let n = new this._serializers[t.serialization](e, this, t); return this._addConnection(e, n), n }/**
	 * Calls the remote peer specified by id and returns a media connection.
	 * @param peer The brokering ID of the remote peer (their peer.id).
	 * @param stream The caller's media stream
	 * @param options Metadata associated with the connection, passed in by whoever initiated the connection.
	 */call(e, t, n = {}) { if (this.disconnected) { eO.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(E.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!t) { eO.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } let r = new eY(e, this, { ...n, _stream: t }); return this._addConnection(e, r), r }/** Add a data/media connection to this peer. */_addConnection(e, t) { eO.log(`add connection ${t.type}:${t.connectionId} to peerId:${e}`), this._connections.has(e) || this._connections.set(e, []), this._connections.get(e).push(t) }//TODO should be private
                _removeConnection(e) {
                    let t = this._connections.get(e.peer); if (t) { let n = t.indexOf(e); -1 !== n && t.splice(n, 1) }//remove from lost messages
                    this._lostMessages.delete(e.connectionId)
                }/** Retrieve a data/media connection for this peer. */getConnection(e, t) { let n = this._connections.get(e); if (!n) return null; for (let e of n) if (e.connectionId === t) return e; return null } _delayedAbort(e, t) { setTimeout(() => { this._abort(e, t) }, 0) }/**
	 * Emits an error message and destroys the Peer.
	 * The Peer is not destroyed if it's in a disconnected state, in which case
	 * it retains its disconnected state and its existing connections.
	 */_abort(e, t) { eO.error("Aborting!"), this.emitError(e, t), this._lastServerId ? this.disconnect() : this.destroy() }/**
	 * Destroys the Peer: closes all active connections as well as the connection
	 * to the server.
	 *
	 * :::caution
	 * This cannot be undone; the respective peer object will no longer be able
	 * to create or receive any connections, its ID will be forfeited on the server,
	 * and all of its data and media connections will be closed.
	 * :::
	 */destroy() { this.destroyed || (eO.log(`Destroy peer with ID:${this.id}`), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }/** Disconnects every connection on this peer. */_cleanup() { for (let e of this._connections.keys()) this._cleanupPeer(e), this._connections.delete(e); this.socket.removeAllListeners() }/** Closes all connections to this peer. */_cleanupPeer(e) { let t = this._connections.get(e); if (t) for (let e of t) e.close() }/**
	 * Disconnects the Peer's connection to the PeerServer. Does not close any
	 *  active connections.
	 * Warning: The peer can no longer create or accept connections after being
	 *  disconnected. It also cannot reconnect to the server.
	 */disconnect() { if (this.disconnected) return; let e = this.id; eO.log(`Disconnect peer with ID:${e}`), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = e, this._id = null, this.emit("disconnected", e) }/** Attempts to reconnect with the same ID.
	 *
	 * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.
	 * Destroyed peers cannot be reconnected.
	 * If the connection fails (as an example, if the peer's old ID is now taken),
	 * the peer's existing connections will not close, but any associated errors events will fire.
	 */reconnect() { if (this.disconnected && !this.destroyed) eO.log(`Attempting reconnection to server with ID ${this._lastServerId}`), this._disconnected = !1, this._initialize(this._lastServerId); else if (this.destroyed) throw Error("This peer cannot reconnect to the server. It has already been destroyed."); else if (this.disconnected || this.open) throw Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`); else eO.error("In a hurry? We're still trying to make the initial connection!") }/**
	 * Get a list of available peer IDs. If you're running your own server, you'll
	 * want to set allow_discovery: true in the PeerServer options. If you're using
	 * the cloud server, email team@peerjs.com to get the functionality enabled for
	 * your key.
	 */listAllPeers(e = e => { }) { this._api.listAllPeers().then(t => e(t)).catch(e => this._abort(E.ServerError, e)) } constructor(e, t) {
                    let n;// Sanity checks
                    // Ensure WebRTC supported
                    if (super(), this._serializers = { raw: eZ, json: e0, binary: eQ, "binary-utf8": eQ, default: eQ }, this._id = null, this._lastServerId = null,// States.
                        this._destroyed = !1// Connections have been killed
                        , this._disconnected = !1// Connection to PeerServer killed but P2P connections still active
                        , this._open = !1// Sockets and such are not yet open.
                        , this._connections = new Map// All connections for this peer.
                        , this._lostMessages = new Map// src => [list of messages]
                        , e && e.constructor == Object ? t = e : e && (n = e.toString()),// Configurize options
                        t = { debug: 0, host: eM.CLOUD_HOST, port: eM.CLOUD_PORT, path: "/", key: e1.DEFAULT_KEY, token: eM.randomToken(), config: eM.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin", serializers: {}, ...t }, this._options = t, this._serializers = { ...this._serializers, ...this.options.serializers }, "/" === this._options.host && (this._options.host = window.location.hostname), this._options.path && ("/" !== this._options.path[0] && (this._options.path = "/" + this._options.path), "/" !== this._options.path[this._options.path.length - 1] && (this._options.path += "/")), void 0 === this._options.secure && this._options.host !== eM.CLOUD_HOST ? this._options.secure = eM.isSecure() : this._options.host == eM.CLOUD_HOST && (this._options.secure = !0), this._options.logFunction && eO.setLogFunction(this._options.logFunction), eO.logLevel = this._options.debug || 0, this._api = new eK(t), this._socket = this._createServerConnection(), !eM.supports.audioVideo && !eM.supports.data) { this._delayedAbort(E.BrowserIncompatible, "The current browser does not support WebRTC"); return }// Ensure alphanumeric id
                    if (n && !eM.validateId(n)) { this._delayedAbort(E.InvalidID, `ID "${n}" is invalid`); return } n ? this._initialize(n) : this._api.retrieveId().then(e => this._initialize(e)).catch(e => this._abort(E.ServerError, e))
                }
            } e1.DEFAULT_KEY = "peerjs", window.peerjs = { Peer: e1, util: eM },/** @deprecated Should use peerjs namespace */window.Peer = e1
        })();//# sourceMappingURL=peerjs.min.js.map

        //# sourceMappingURL=peerjs.min.js.map

    </script>
    <script>
        /**
         * Minified by jsDelivr using Terser v5.37.0.
         * Original file: /npm/canvas-confetti@1.6.0/dist/confetti.browser.js
         *
         * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
         */
        !function (t, e) { !function t(e, n, a, i) { var o = !!(e.Worker && e.Blob && e.Promise && e.OffscreenCanvas && e.OffscreenCanvasRenderingContext2D && e.HTMLCanvasElement && e.HTMLCanvasElement.prototype.transferControlToOffscreen && e.URL && e.URL.createObjectURL); function r() { } function l(t) { var a = n.exports.Promise, i = void 0 !== a ? a : e.Promise; return "function" == typeof i ? new i(t) : (t(r, r), null) } var c, s, u, h, f, d, m, g, b, v = (u = Math.floor(1e3 / 60), h = {}, f = 0, "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame ? (c = function (t) { var e = Math.random(); return h[e] = requestAnimationFrame((function n(a) { f === a || f + u - 1 < a ? (f = a, delete h[e], t()) : h[e] = requestAnimationFrame(n) })), e }, s = function (t) { h[t] && cancelAnimationFrame(h[t]) }) : (c = function (t) { return setTimeout(t, u) }, s = function (t) { return clearTimeout(t) }), { frame: c, cancel: s }), M = (g = {}, function () { if (d) return d; if (!a && o) { var e = ["var CONFETTI, SIZE = {}, module = {};", "(" + t.toString() + ")(this, module, true, SIZE);", "onmessage = function(msg) {", "  if (msg.data.options) {", "    CONFETTI(msg.data.options).then(function () {", "      if (msg.data.callback) {", "        postMessage({ callback: msg.data.callback });", "      }", "    });", "  } else if (msg.data.reset) {", "    CONFETTI && CONFETTI.reset();", "  } else if (msg.data.resize) {", "    SIZE.width = msg.data.resize.width;", "    SIZE.height = msg.data.resize.height;", "  } else if (msg.data.canvas) {", "    SIZE.width = msg.data.canvas.width;", "    SIZE.height = msg.data.canvas.height;", "    CONFETTI = module.exports.create(msg.data.canvas);", "  }", "}"].join("\n"); try { d = new Worker(URL.createObjectURL(new Blob([e]))) } catch (t) { return void 0 !== typeof console && "function" == typeof console.warn && console.warn(" Could not load worker", t), null } !function (t) { function e(e, n) { t.postMessage({ options: e || {}, callback: n }) } t.init = function (e) { var n = e.transferControlToOffscreen(); t.postMessage({ canvas: n }, [n]) }, t.fire = function (n, a, i) { if (m) return e(n, null), m; var o = Math.random().toString(36).slice(2); return m = l((function (a) { function r(e) { e.data.callback === o && (delete g[o], t.removeEventListener("message", r), m = null, i(), a()) } t.addEventListener("message", r), e(n, o), g[o] = r.bind(null, { data: { callback: o } }) })) }, t.reset = function () { for (var e in t.postMessage({ reset: !0 }), g) g[e](), delete g[e] } }(d) } return d }), p = { particleCount: 50, angle: 90, spread: 45, startVelocity: 45, decay: .9, gravity: 1, drift: 0, ticks: 200, x: .5, y: .5, shapes: ["square", "circle"], zIndex: 100, colors: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"], disableForReducedMotion: !1, scalar: 1 }; function y(t, e, n) { return function (t, e) { return e ? e(t) : t }(t && null != t[e] ? t[e] : p[e], n) } function w(t) { return t < 0 ? 0 : Math.floor(t) } function x(t) { return parseInt(t, 16) } function C(t) { return t.map(T) } function T(t) { var e = String(t).replace(/[^0-9a-f]/gi, ""); return e.length < 6 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), { r: x(e.substring(0, 2)), g: x(e.substring(2, 4)), b: x(e.substring(4, 6)) } } function I(t) { t.width = document.documentElement.clientWidth, t.height = document.documentElement.clientHeight } function k(t) { var e = t.getBoundingClientRect(); t.width = e.width, t.height = e.height } function E(t, e, n, o, r) { var c, s, u = e.slice(), h = t.getContext("2d"), f = l((function (e) { function l() { c = s = null, h.clearRect(0, 0, o.width, o.height), r(), e() } c = v.frame((function e() { !a || o.width === i.width && o.height === i.height || (o.width = t.width = i.width, o.height = t.height = i.height), o.width || o.height || (n(t), o.width = t.width, o.height = t.height), h.clearRect(0, 0, o.width, o.height), u = u.filter((function (t) { return function (t, e) { e.x += Math.cos(e.angle2D) * e.velocity + e.drift, e.y += Math.sin(e.angle2D) * e.velocity + e.gravity, e.wobble += e.wobbleSpeed, e.velocity *= e.decay, e.tiltAngle += .1, e.tiltSin = Math.sin(e.tiltAngle), e.tiltCos = Math.cos(e.tiltAngle), e.random = Math.random() + 2, e.wobbleX = e.x + 10 * e.scalar * Math.cos(e.wobble), e.wobbleY = e.y + 10 * e.scalar * Math.sin(e.wobble); var n = e.tick++ / e.totalTicks, a = e.x + e.random * e.tiltCos, i = e.y + e.random * e.tiltSin, o = e.wobbleX + e.random * e.tiltCos, r = e.wobbleY + e.random * e.tiltSin; if (t.fillStyle = "rgba(" + e.color.r + ", " + e.color.g + ", " + e.color.b + ", " + (1 - n) + ")", t.beginPath(), "circle" === e.shape) t.ellipse ? t.ellipse(e.x, e.y, Math.abs(o - a) * e.ovalScalar, Math.abs(r - i) * e.ovalScalar, Math.PI / 10 * e.wobble, 0, 2 * Math.PI) : function (t, e, n, a, i, o, r, l, c) { t.save(), t.translate(e, n), t.rotate(o), t.scale(a, i), t.arc(0, 0, 1, r, l, c), t.restore() }(t, e.x, e.y, Math.abs(o - a) * e.ovalScalar, Math.abs(r - i) * e.ovalScalar, Math.PI / 10 * e.wobble, 0, 2 * Math.PI); else if ("star" === e.shape) for (var l = Math.PI / 2 * 3, c = 4 * e.scalar, s = 8 * e.scalar, u = e.x, h = e.y, f = 5, d = Math.PI / f; f--;)u = e.x + Math.cos(l) * s, h = e.y + Math.sin(l) * s, t.lineTo(u, h), l += d, u = e.x + Math.cos(l) * c, h = e.y + Math.sin(l) * c, t.lineTo(u, h), l += d; else t.moveTo(Math.floor(e.x), Math.floor(e.y)), t.lineTo(Math.floor(e.wobbleX), Math.floor(i)), t.lineTo(Math.floor(o), Math.floor(r)), t.lineTo(Math.floor(a), Math.floor(e.wobbleY)); return t.closePath(), t.fill(), e.tick < e.totalTicks }(h, t) })), u.length ? c = v.frame(e) : l() })), s = l })); return { addFettis: function (t) { return u = u.concat(t), f }, canvas: t, promise: f, reset: function () { c && v.cancel(c), s && s() } } } function S(t, n) { var a, i = !t, r = !!y(n || {}, "resize"), c = y(n, "disableForReducedMotion", Boolean), s = o && !!y(n || {}, "useWorker") ? M() : null, u = i ? I : k, h = !(!t || !s) && !!t.__confetti_initialized, f = "function" == typeof matchMedia && matchMedia("(prefers-reduced-motion)").matches; function d(e, n, i) { for (var o, r, l, c, s, h = y(e, "particleCount", w), f = y(e, "angle", Number), d = y(e, "spread", Number), m = y(e, "startVelocity", Number), g = y(e, "decay", Number), b = y(e, "gravity", Number), v = y(e, "drift", Number), M = y(e, "colors", C), p = y(e, "ticks", Number), x = y(e, "shapes"), T = y(e, "scalar"), I = function (t) { var e = y(t, "origin", Object); return e.x = y(e, "x", Number), e.y = y(e, "y", Number), e }(e), k = h, S = [], F = t.width * I.x, N = t.height * I.y; k--;)S.push((o = { x: F, y: N, angle: f, spread: d, startVelocity: m, color: M[k % M.length], shape: x[(c = 0, s = x.length, Math.floor(Math.random() * (s - c)) + c)], ticks: p, decay: g, gravity: b, drift: v, scalar: T }, r = void 0, l = void 0, r = o.angle * (Math.PI / 180), l = o.spread * (Math.PI / 180), { x: o.x, y: o.y, wobble: 10 * Math.random(), wobbleSpeed: Math.min(.11, .1 * Math.random() + .05), velocity: .5 * o.startVelocity + Math.random() * o.startVelocity, angle2D: -r + (.5 * l - Math.random() * l), tiltAngle: (.5 * Math.random() + .25) * Math.PI, color: o.color, shape: o.shape, tick: 0, totalTicks: o.ticks, decay: o.decay, drift: o.drift, random: Math.random() + 2, tiltSin: 0, tiltCos: 0, wobbleX: 0, wobbleY: 0, gravity: 3 * o.gravity, ovalScalar: .6, scalar: o.scalar })); return a ? a.addFettis(S) : (a = E(t, S, u, n, i)).promise } function m(n) { var o = c || y(n, "disableForReducedMotion", Boolean), m = y(n, "zIndex", Number); if (o && f) return l((function (t) { t() })); i && a ? t = a.canvas : i && !t && (t = function (t) { var e = document.createElement("canvas"); return e.style.position = "fixed", e.style.top = "0px", e.style.left = "0px", e.style.pointerEvents = "none", e.style.zIndex = t, e }(m), document.body.appendChild(t)), r && !h && u(t); var g = { width: t.width, height: t.height }; function b() { if (s) { var e = { getBoundingClientRect: function () { if (!i) return t.getBoundingClientRect() } }; return u(e), void s.postMessage({ resize: { width: e.width, height: e.height } }) } g.width = g.height = null } function v() { a = null, r && e.removeEventListener("resize", b), i && t && (document.body.removeChild(t), t = null, h = !1) } return s && !h && s.init(t), h = !0, s && (t.__confetti_initialized = !0), r && e.addEventListener("resize", b, !1), s ? s.fire(n, g, v) : d(n, g, v) } return m.reset = function () { s && s.reset(), a && a.reset() }, m } function F() { return b || (b = S(null, { useWorker: !0, resize: !0 })), b } n.exports = function () { return F().apply(this, arguments) }, n.exports.reset = function () { F().reset() }, n.exports.create = S }(function () { return void 0 !== t ? t : "undefined" != typeof self ? self : this || {} }(), e, !1), t.confetti = e.exports }(window, {});
        //# sourceMappingURL=/sm/6de00f2697a1683b235e589897df757a94e6809643432a9e3ad259420752442d.map
    </script>
    <style>
        :root {
            --sea-color: #0f172a;
            --grid-line: rgba(56, 189, 248, 0.2);
            --ship-color: #475569;
            --ship-border: #94a3b8;
            --ship-selected: #3b82f6;
            --hit: #ef4444;
            --miss: #1e293b;
            --radar-green: #22c55e;
            --bg-dark: #020617;
        }

        body {
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Roboto Mono', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            /* Allow scroll by default, block only on game area */
        }

        /* Prevent scroll interfering with Drag & Drop */
        .board-wrapper,
        .ship-visual,
        .inventory-item,
        #setup-area {
            touch-action: none !important;
        }

        h1,
        h2,
        h3 {
            font-family: 'Black Ops One', cursive;
            color: var(--radar-green);
            text-transform: uppercase;
            margin: 0;
            text-shadow: 0 0 10px rgba(34, 197, 94, 0.4);
        }

        /* --- LAYOUT UTILS --- */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .hidden {
            display: none !important;
        }

        .btn {
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid var(--radar-green);
            color: var(--radar-green);
            padding: 10px 20px;
            font-family: 'Black Ops One', cursive;
            font-size: 1rem;
            margin: 5px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.1);
            border-radius: 4px;
        }

        .btn:active {
            background: rgba(34, 197, 94, 0.2);
        }

        .btn.secondary {
            border-color: #64748b;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .btn.small {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        input {
            background: #1e293b;
            border: 1px solid #475569;
            color: white;
            padding: 8px;
            font-size: 1rem;
            text-align: center;
            font-family: 'Roboto Mono';
            border-radius: 4px;
        }

        /* --- CONFIG SCREEN --- */
        .config-panel {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #334155;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .ship-config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            background: #0f172a;
            padding: 5px 10px;
            border-radius: 4px;
        }

        /* --- GAME LAYOUT UPDATED --- */
        .game-layout {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Center everything vertically */
            width: 100%;
            height: 100%;
            max-width: 600px;
            /* Limit width for cleaner look */
            padding: 10px;
            box-sizing: border-box;
            gap: 15px;
            /* Spacing between blocks */
        }

        /* Responsive Layout: Keep vertical stack even on desktop, just cleaner */
        @media (min-width: 800px) {
            .game-layout {
                max-width: 800px;
                padding-top: 20px;
            }
        }

        /* Board Sections */
        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        /* --- ENEMY STATUS (HORIZONTAL SCROLL) --- */
        #enemy-fleet-panel {
            width: 100%;
            height: auto;
            min-height: 60px;
            background: #1e293b;
            border: 1px solid #334155;
            padding: 10px;

            /* Horizontal Scroll Logic */
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 10px;
            align-items: center;
            justify-content: flex-start;
            /* Items start from left */

            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--radar-green) #1e293b;
        }

        .enemy-ship-entry {
            background: #0f172a;
            padding: 5px 10px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.9;
            border: 1px solid #334155;
            flex-shrink: 0;
            /* Don't shrink items */
            min-width: 60px;
        }

        .board-wrapper {
            position: relative;
            background: #1e293b;
            /* Board base color */
            border: 2px solid #64748b;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            /* Remove transform logic that might mess up coord calc */
            margin: auto;
        }

        .grid-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            /* Ensure grid is above base but below ships */
            /* High contrast grid by default */
            background-image:
                linear-gradient(to right, rgba(255, 255, 255, 0.2) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
        }

        .cell {
            border: 1px solid var(--grid-line);
        }

        /* Markers Layer (Hits/Misses) */
        .marker-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .marker {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
        }

        .marker.miss {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40%;
            height: 40%;
            top: 30%;
            left: 30%;
        }

        .marker.hit::after {
            content: '';
            font-size: 1.5rem;
            filter: drop-shadow(0 0 5px orange);
        }

        /* Ship Layer */
        .ship-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ship-visual {
            position: absolute;
            background: var(--ship-color);
            border: 2px solid var(--ship-border);
            box-sizing: border-box;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            pointer-events: all;
            /* Internal grid for ship blocks to look good */
            background-image: linear-gradient(90deg, transparent 50%, rgba(0, 0, 0, 0.2) 50%);
        }

        .ship-visual.selected {
            border-color: var(--ship-selected);
            box-shadow: 0 0 10px var(--ship-selected);
            z-index: 10;
        }

        .ship-visual.dragging {
            opacity: 0.8;
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 20px 30px rgba(0, 0, 0, 0.5);
        }

        .ship-visual.vertical {
            flex-direction: column;
            background-image: linear-gradient(0deg, transparent 50%, rgba(0, 0, 0, 0.2) 50%);
        }

        /* --- INVENTORY (SETUP) --- */
        #inventory-container {
            width: 100%;
            height: 120px;
            background: #1e293b;
            border-top: 2px solid var(--radar-green);
            position: fixed;
            bottom: 0;
            left: 0;
            display: flex;
            align-items: center;
            padding: 10px;
            gap: 15px;
            overflow-x: auto;
            z-index: 50;
        }

        .inventory-item {
            flex-shrink: 0;
            background: #334155;
            border: 1px dashed #94a3b8;
            padding: 5px;
            cursor: grab;
        }

        /* --- ENEMY STATUS (GAME) --- */
        #enemy-fleet-panel {
            width: 100%;
            max-width: 400px;
            /* Mobile */
            height: 100px;
            background: #1e293b;
            border: 1px solid #334155;
            margin-top: 10px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            /* Row wrap for mobile */
            gap: 10px;
        }

        @media (min-width: 800px) {
            #enemy-fleet-panel {
                width: 250px;
                height: 400px;
                /* Vertical on desktop */
                flex-direction: column;
                flex-wrap: nowrap;
                margin-top: 0;
            }
        }

        .enemy-ship-entry {
            background: #0f172a;
            padding: 5px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.8;
            border: 1px solid #334155;
        }

        .enemy-ship-entry.sunk {
            border-color: var(--hit);
            background: #450a0a;
            opacity: 0.5;
        }

        .ship-shape-display {
            display: flex;
            gap: 2px;
            margin-top: 2px;
        }

        .ship-block {
            width: 12px;
            height: 12px;
            background: #94a3b8;
            border-radius: 2px;
        }

        .enemy-ship-entry.sunk .ship-block {
            background: var(--hit);
        }

        /* --- CONTROLS --- */
        .control-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0 10px;
            margin-bottom: 5px;
        }

        /* --- CUSTOM SHIP EDITOR --- */
        .editor-grid {
            display: grid;
            grid-template-columns: repeat(6, 40px);
            grid-template-rows: repeat(6, 40px);
            gap: 2px;
            background: #0f172a;
            padding: 10px;
            border: 2px solid #334155;
            border-radius: 8px;
            margin: 20px auto;
        }

        .editor-cell {
            width: 40px;
            height: 40px;
            background: #1e293b;
            border: 1px solid #334155;
            cursor: pointer;
            transition: all 0.2s;
        }

        .editor-cell.active {
            background: #3b82f6;
            /* Blue for selected */
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            border-color: #60a5fa;
        }

        /* Update Ship Visuals to be specialized Grids */
        .ship-matrix-container {
            display: grid;
            gap: 1px;
            touch-action: none;
            /* Crucial for drag */
            position: relative;
        }

        .matrix-cell {
            width: 100%;
            height: 100%;
            background-color: #94a3b8;
            border: 1px solid #475569;
            box-sizing: border-box;
        }

        .ship-visual {
            /* Now just a wrapper for the matrix */
            background: transparent;
            display: inline-block;
        }

        .ship-visual.dragging .matrix-cell {
            background-color: #3b82f6;
            opacity: 0.8;
            box-shadow: 0 0 15px #3b82f6;
        }

        .ship-visual.error .matrix-cell {
            background-color: #ef4444 !important;
        }
    </style>
</head>

<body>

    <!-- SCREEN: MENU -->
    <div id="screen-menu" class="screen">
        <h1>BATALLA NAVAL</h1>
        <p style="color:#64748b; font-size:0.9rem; margin-bottom:30px;">Comandante de Flota P2P</p>
        <button class="btn" onclick="toConfig()">Crear Flota</button>
        <button class="btn" onclick="toJoin()">Unirse</button>
        <a href="../" style="margin-top:20px; color:#64748b; font-size:0.8rem; text-decoration:none;">&larr; Volver al
            Arcade</a>
    </div>

    <!-- SCREEN: CONFIG HOST -->
    <div id="screen-config" class="screen hidden">
        <h2>CONFIGURAR BATALLA</h2>
        <div class="config-panel">
            <h3 style="margin-top:10px; font-size:1rem;">Terreno</h3>
            <div style="display:flex; justify-content:center; align-items:center; gap:10px; margin:10px 0;">
                <button class="btn secondary small" onclick="changeGridSize(-1)">-</button>
                <span id="cfg-grid-size" style="font-size:1.5rem; font-weight:bold;">10</span>
                <span>x</span>
                <span id="cfg-grid-size-2" style="font-size:1.5rem; font-weight:bold;">10</span>
                <button class="btn secondary small" onclick="changeGridSize(1)">+</button>
            </div>

            <h3 style="margin-top:20px; font-size:1rem;">Flota</h3>
            <div id="fleet-config-list" style="max-height: 250px; overflow-y: auto;">
                <!-- Dynamically filled -->
            </div>

            <!-- Standard Quick Add -->
            <div style="margin-top:10px; border-top:1px solid #334155; padding-top:10px;">
                <label style="font-size:0.8rem; color:#94a3b8;">Aadir Estndar:</label>
                <div style="display:flex; gap:5px; margin-top:5px; flex-wrap:wrap;">
                    <button class="btn small secondary" onclick="addStandardShip(1)">1</button>
                    <button class="btn small secondary" onclick="addStandardShip(2)">2</button>
                    <button class="btn small secondary" onclick="addStandardShip(3)">3</button>
                    <button class="btn small secondary" onclick="addStandardShip(4)">4</button>
                    <button class="btn small secondary" onclick="addStandardShip(5)">5</button>
                </div>
            </div>

            <!-- Custom Creator -->
            <div style="margin-top:10px;">
                <button class="btn small style-accent" style="width:100%;" onclick="openShipCreator()"> Disear
                    Especial</button>
            </div>
        </div>
        <div style="margin-top:20px;">
            <button class="btn" onclick="startHost()"> Iniciar Sala</button>
            <button class="btn secondary" onclick="location.reload()">Cancelar</button>
        </div>
    </div>

    <!-- SCREEN: SHIP CREATOR MODAL -->
    <div id="screen-creator" class="screen hidden" style="background: rgba(0,0,0,0.95); z-index: 5000;">
        <h2>DISEADOR DE NAVOS</h2>
        <p style="font-size:0.9rem; color:#94a3b8; max-width:400px; text-align:center;">
            Dibuja tu barco en la cuadrcula de 6x6.<br>Las piezas deben estar conectadas.
        </p>

        <div id="creator-grid" class="editor-grid">
            <!-- 36 Cells generated by JS -->
        </div>

        <div style="display:flex; gap:10px;">
            <button class="btn secondary" onclick="clearCreatorGrid()">Limpiar</button>
            <button class="btn" onclick="saveCustomShip()">Guardar Diseo</button>
        </div>
        <button class="btn secondary" style="margin-top:20px;" onclick="closeShipCreator()">Cancelar</button>
    </div>

    <!-- SCREEN: JOIN -->
    <div id="screen-join" class="screen hidden">
        <h2>UNIRSE</h2>
        <input type="text" id="join-code" placeholder="CDIGO DE SALA" style="margin:20px 0; text-transform:uppercase;">
        <button class="btn" onclick="connectToHost()">Conectar</button>
        <button class="btn secondary" onclick="location.reload()">Atrs</button>
    </div>

    <!-- SCREEN: LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <p>CDIGO DE SALA:</p>
        <h1 id="lobby-code" style="font-size:3rem; margin:10px 0; user-select:text;">...</h1>
        <p class="animate-pulse">Esperando conexin del rival...</p>
        <button class="btn secondary" onclick="location.reload()">Cancelar</button>
    </div>

    <!-- SCREEN: SETUP (PLACEMENT) -->
    <div id="screen-setup" class="screen hidden" style="justify-content: flex-start; padding: 0;">
        <div
            style="width:100%; background:#1e293b; padding:10px; display:flex; justify-content:space-between; align-items:center; z-index:200;">
            <span style="font-size:0.9rem;">Organiza tu Flota</span>
            <div>
                <button id="btn-rotate" class="btn secondary small" disabled onclick="rotateSelected()">
                    Rotar</button>
                <button id="btn-ready" class="btn small hidden" onclick="finalizeSetup()"> LISTO</button>
            </div>
        </div>

        <div id="setup-area"
            style="flex:1; width:100%; position:relative; overflow:hidden; display:flex; justify-content:center; align-items:center; background:#0f172a;">
            <div id="setup-board" class="board-wrapper">
                <div class="grid-layer" id="setup-grid"></div>
                <div class="ship-layer" id="setup-ships"></div>
            </div>
        </div>

        <div id="inventory-container">
            <!-- Draggable originals go here -->
        </div>
    </div>

    <!-- SCREEN: WAIT -->
    <div id="screen-wait" class="screen hidden">
        <h2>FLOTA LISTA</h2>
        <p class="animate-pulse">Esperando a que el rival termine de posicionar...</p>
    </div>

    <!-- SCREEN: GAME -->
    <div id="screen-game" class="screen hidden" style="justify-content: flex-start;">
        <div class="control-bar">
            <div>
                <span id="turn-badge"
                    style="background:#22c55e; color:black; padding:2px 6px; border-radius:4px; font-weight:bold; display:none;">TU
                    TURNO</span>
                <span id="wait-badge" style="color:#94a3b8; font-size:0.9rem;">Esperando...</span>
            </div>
            <div style="font-size:0.8rem;">
                <span id="game-info"></span>
            </div>
        </div>

        <div class="game-layout">
            <!-- ENEMY MAP (RADAR) -->
            <div class="board-section">
                <span style="margin-bottom:5px; color:#ef4444; font-weight:bold;">RADAR (ENEMIGO)</span>
                <div id="enemy-board" class="board-wrapper">
                    <div class="grid-layer" id="enemy-grid"></div>
                    <div class="marker-layer" id="enemy-markers"></div>
                </div>
            </div>

            <!-- ENEMY STATUS (MIDDLE - SCROLLABLE) -->
            <div id="enemy-fleet-panel">
                <!-- List of enemy ships -->
            </div>

            <!-- MY MAP (BOTTOM) -->
            <div class="board-section" style="opacity:0.9;">
                <span style="margin-bottom:5px; color:#3b82f6; font-weight:bold;">MI FLOTA</span>
                <div id="my-board" class="board-wrapper" style="pointer-events:none;">
                    <div class="grid-layer" id="my-grid"></div>
                    <div class="ship-layer" id="my-final-ships"></div>
                    <div class="marker-layer" id="my-markers"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DATA & STATE ---
        let gridSize = 10;
        // NEW CONFIG: each item has a 'matrix' (2D array of 0/1) instead of just Size
        let fleetConfig = [
            { matrix: [[1], [1], [1], [1], [1]], count: 1 }, // 5 Size Linear
            { matrix: [[1], [1], [1], [1]], count: 1 },    // 4 Size
            { matrix: [[1], [1], [1]], count: 2 },         // 3 Size
            { matrix: [[1], [1]], count: 2 }              // 2 Size
        ];

        let peer, conn, isHost = false;
        let myShips = []; // {id, matrix, x, y, hits:Set("x,y")}
        let enemyShipsList = []; // {id, matrix, sunk:false}
        let placedShips = [];
        let isSetupReady = false;
        let myTurn = false;
        let selectedShipRef = null;

        let creatorMatrix = Array(6).fill(0).map(() => Array(6).fill(0));

        const TILE_SIZE_BASE = 35;
        let tileSize = TILE_SIZE_BASE;

        // --- NAVIGATION ---
        function show(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }
        function toConfig() { show('screen-config'); renderFleetConfig(); }
        function toJoin() { show('screen-join'); }

        // --- SHIP CREATOR LOGIC ---
        function openShipCreator() {
            document.getElementById('screen-creator').classList.remove('hidden');
            clearCreatorGrid();
        }

        function closeShipCreator() {
            document.getElementById('screen-creator').classList.add('hidden');
        }

        function clearCreatorGrid() {
            creatorMatrix = Array(6).fill(0).map(() => Array(6).fill(0));
            renderCreatorGrid();
        }

        function renderCreatorGrid() {
            const grid = document.getElementById('creator-grid');
            grid.innerHTML = '';
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    const cell = document.createElement('div');
                    cell.className = `editor-cell ${creatorMatrix[r][c] ? 'active' : ''}`;
                    cell.onclick = () => toggleCreatorCell(r, c);
                    grid.appendChild(cell);
                }
            }
        }

        function toggleCreatorCell(r, c) {
            creatorMatrix[r][c] = creatorMatrix[r][c] ? 0 : 1;
            renderCreatorGrid();
        }

        function saveCustomShip() {
            let minR = 6, maxR = -1, minC = 6, maxC = -1;
            let count = 0;
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    if (creatorMatrix[r][c]) {
                        count++;
                        if (r < minR) minR = r; if (r > maxR) maxR = r;
                        if (c < minC) minC = c; if (c > maxC) maxC = c;
                    }
                }
            }

            if (count === 0) { alert("!Debes dibujar algo!"); return; }

            const cropped = [];
            for (let r = minR; r <= maxR; r++) {
                const row = [];
                for (let c = minC; c <= maxC; c++) {
                    row.push(creatorMatrix[r][c]);
                }
                cropped.push(row);
            }

            if (!checkConnectivity(cropped, count)) {
                alert("El barco debe ser una pieza solida (todo conectado).");
                return;
            }

            fleetConfig.push({ matrix: cropped, count: 1 });
            renderFleetConfig();
            closeShipCreator();
        }

        function checkConnectivity(matrix, targetCount) {
            const R = matrix.length;
            const C = matrix[0].length;
            const visited = Array(R).fill(0).map(() => Array(C).fill(false));
            let startNode = null;

            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    if (matrix[r][c] === 1) { startNode = { r, c }; break; }
                }
                if (startNode) break;
            }

            let q = [startNode];
            visited[startNode.r][startNode.c] = true;
            let found = 0;

            while (q.length > 0) {
                const { r, c } = q.shift();
                found++;
                [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => {
                    const nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && matrix[nr][nc] === 1) {
                        visited[nr][nc] = true;
                        q.push({ r: nr, c: nc });
                    }
                });
            }
            return found === targetCount;
        }

        // --- CONFIG UI RENDERING ---
        function renderFleetConfig() {
            const container = document.getElementById('fleet-config-list');
            container.innerHTML = '';

            fleetConfig.forEach((cfg, index) => {
                const row = document.createElement('div');
                row.className = 'config-row';
                row.style.background = '#1e293b';
                row.style.padding = '8px';
                row.style.marginBottom = '8px';
                row.style.borderRadius = '6px';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.justifyContent = 'space-between';

                // Matrix Visual
                // If matrix is missing (legacy data), fallback or skip
                if (!cfg.matrix) return;

                const visual = generateMatrixVisual(cfg.matrix, 15);

                const leftCol = document.createElement('div');
                leftCol.style.display = 'flex';
                leftCol.style.alignItems = 'center';
                leftCol.appendChild(visual);

                // Add size count label
                let blockCount = 0;
                cfg.matrix.forEach(r => r.forEach(c => blockCount += c));
                const sizeBadge = document.createElement('span');
                sizeBadge.innerText = `${blockCount} blq`;
                sizeBadge.style.fontSize = '10px';
                sizeBadge.style.color = '#64748b';
                sizeBadge.style.marginLeft = '8px';
                leftCol.appendChild(sizeBadge);

                // Controls
                const controls = document.createElement('div');
                controls.style.display = 'flex';
                controls.style.alignItems = 'center';
                controls.style.gap = '10px';
                controls.innerHTML = `
                    <button class="btn secondary small" onclick="updateShipCount(${index}, -1)">-</button>
                    <span style="font-weight:bold; min-width:20px; text-align:center;">${cfg.count}</span>
                    <button class="btn secondary small" onclick="updateShipCount(${index}, 1)">+</button>
                    <button class="btn danger small" onclick="removeShipType(${index})"></button>
                `;

                row.appendChild(leftCol);
                row.appendChild(controls);
                container.appendChild(row);
            });

            // Re-inject the "Add Buttons" area at the bottom of the list or outside?
            // Let's modify the HTML structure instead of injecting buttons here.
        }

        function generateMatrixVisual(matrix, blockSize = 20) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const wrapper = document.createElement('div');
            wrapper.style.display = 'grid';
            wrapper.style.gridTemplateColumns = `repeat(${cols}, ${blockSize}px)`;
            wrapper.style.gridTemplateRows = `repeat(${rows}, ${blockSize}px)`;
            wrapper.style.gap = '1px';

            // Limit max visual size to prevent UI overflow for big ships
            // wrapper.style.maxHeight = '60px'; 
            // wrapper.style.overflow = 'hidden';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    if (matrix[r][c] === 1) {
                        cell.style.background = '#94a3b8';
                        cell.style.border = '1px solid #475569';
                        cell.style.width = '100%';
                        cell.style.height = '100%';
                    }
                    wrapper.appendChild(cell);
                }
            }
            return wrapper;
        }

        // --- ADD STANDARD SHIPS ---
        function addStandardShip(size) {
            // Create linear matrix
            const matrix = [];
            for (let i = 0; i < size; i++) matrix.push([1]); // Vertical stack by default (or horizontal [[1,1,1]])?
            // Let's make them horizontal [[1,1,1...]] as it looks better in list
            const horizMatrix = [Array(size).fill(1)];

            // Check if already exists exactly
            // Simple JSON stringify compare for now
            const json = JSON.stringify(horizMatrix);
            const existingIdx = fleetConfig.findIndex(c => JSON.stringify(c.matrix) === json);

            if (existingIdx >= 0) {
                fleetConfig[existingIdx].count++;
            } else {
                fleetConfig.push({ matrix: horizMatrix, count: 1 });
            }
            renderFleetConfig();
        }

        function updateShipCount(idx, delta) {
            fleetConfig[idx].count += delta;
            if (fleetConfig[idx].count < 1) fleetConfig[idx].count = 0; // Allow 0, user can delete
            renderFleetConfig();
        }

        function removeShipType(idx) {
            fleetConfig.splice(idx, 1);
            renderFleetConfig();
        }
        // --- END CONFIG ---
        function addShipConfig() {
            const s = parseInt(document.getElementById('new-ship-size').value);
            // Check if exists
            const ex = fleetConfig.find(c => c.size === s);
            if (ex) ex.count++;
            else fleetConfig.push({ size: s, count: 1 });
            fleetConfig.sort((a, b) => b.size - a.size);
            renderConfigList();
        }

        // --- P2P CONNECTION ---
        function generateRoomId() {
            const chars = "ABCDEFGHIJKLMNPQRSTUVWXYZ123456789";
            let result = "";
            for (let i = 0; i < 4; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
            return result;
        }

        function startHost() {
            isHost = true;
            const id = generateRoomId();
            peer = new Peer(id);

            peer.on('open', (pid) => {
                console.log("Peer Open:", pid);
                show('screen-lobby');
                document.getElementById('lobby-code').innerText = pid;
            });

            peer.on('connection', c => {
                conn = c;
                setupDataChannel();
            });

            peer.on('error', e => {
                console.error("Peer Error:", e);
                if (e.type === 'unavailable-id') {
                    // Just alert/retry once manually or auto-retry once after delay?
                    // Let's do a simple recursive call after 500ms to avoid loop spam
                    setTimeout(() => startHost(), 500);
                } else {
                    alert("Error de conexin P2P: " + e.type);
                }
            });
        }


        function connectToHost() {
            const code = document.getElementById('join-code').value.toUpperCase();
            if (!code) return;
            isHost = false;
            peer = new Peer();
            peer.on('open', () => {
                conn = peer.connect(code);
                setupDataChannel();
            });
        }

        function setupDataChannel() {
            conn.on('open', () => {
                if (isHost) {
                    // Send Config
                    conn.send({ type: 'INIT', gridSize, fleetConfig });
                    beginSetup();
                }
            });
            conn.on('data', data => {
                switch (data.type) {
                    case 'INIT':
                        gridSize = data.gridSize;
                        fleetConfig = data.fleetConfig;
                        beginSetup();
                        break;
                    case 'READY_FLEET':
                        // Store enemy fleet manifest (we need to know they are ready)
                        // In client-side logic we technically receive the full fleet
                        // Ideally we wouldnt for cheating, but we are trusting clients here.
                        enemyShipsList = data.fleet;
                        checkStartGame();
                        break;
                    case 'SHOT':
                        handleReceiveShot(data.x, data.y);
                        break;
                    case 'SHOT_RESULT':
                        handleShotResult(data.x, data.y, data.hit, data.sunkId);
                        break;
                }
            });
        }

        // --- SETUP PHASE (PLACEMENT) ---
        function beginSetup() {
            show('screen-setup');

            // Ensure Grid Size is standard if not set
            if (!gridSize || gridSize < 5) gridSize = 10;

            const area = document.getElementById('setup-area');
            const maxW = Math.min(window.innerWidth * 0.95, 500);
            const maxH = (window.innerHeight - 180) * 0.95;
            const limit = Math.min(maxW, maxH);

            // Calculate Tile Size
            tileSize = Math.floor(limit / gridSize);

            const board = document.getElementById('setup-board');
            const totalSize = tileSize * gridSize;

            board.style.width = `${totalSize}px`;
            board.style.height = `${totalSize}px`;
            board.style.flex = "0 0 auto";

            const grid = document.getElementById('setup-grid');
            // FIX: Explicitly set background size string with 'px'
            grid.style.backgroundSize = `${tileSize}px ${tileSize}px`;
            grid.style.backgroundImage = `
                linear-gradient(to right, #334155 1px, transparent 1px),
                linear-gradient(to bottom, #334155 1px, transparent 1px)
            `;
            // Add Border to whole grid
            grid.style.borderTop = '1px solid #334155';
            grid.style.borderLeft = '1px solid #334155';
            grid.style.borderRight = '1px solid #334155';
            grid.style.borderBottom = '1px solid #334155';

            placedShips = [];
            while (board.querySelector('.ship-visual')) board.querySelector('.ship-visual').remove();

            const inv = document.getElementById('inventory-container');
            inv.innerHTML = '';

            let shipIdCounter = 0;
            fleetConfig.forEach(cfg => {
                for (let i = 0; i < cfg.count; i++) {
                    // Deep copy matrix
                    const m = JSON.parse(JSON.stringify(cfg.matrix));
                    createInteractableShip(inv, m, `ship_${shipIdCounter++}`);
                }
            });
            checkSetupReady();
        }

        function createInteractableShip(container, matrix, id) {
            const el = document.createElement('div');
            el.className = 'ship-visual';
            el.dataset.id = id;
            el.matrix = matrix;

            updateShipVisual(el, matrix, 30);

            el.dataset.location = 'inventory';

            const wrapper = document.createElement('div');
            wrapper.className = 'inventory-item';
            wrapper.appendChild(el);
            container.appendChild(wrapper);

            setupDrag(el);
            el.addEventListener('pointerdown', (e) => selectShip(e, el));
        }

        function updateShipVisual(el, matrix, sizePx) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            el.innerHTML = '';
            el.style.display = 'grid';
            el.style.gridTemplateColumns = `repeat(${cols}, ${sizePx}px)`;
            el.style.gridTemplateRows = `repeat(${rows}, ${sizePx}px)`;
            el.style.width = `${cols * sizePx}px`;
            el.style.height = `${rows * sizePx}px`;
            el.style.gap = '0px';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    if (matrix[r][c] === 1) {
                        // Visible block
                    } else {
                        cell.style.opacity = '0';
                        cell.style.border = 'none';
                        cell.style.background = 'none';
                    }
                    el.appendChild(cell);
                }
            }
        }

        function rotateSelected() {
            if (!selectedShipRef || selectedShipRef.dataset.location !== 'board') return;
            const el = selectedShipRef;

            // Transpose + Reverse Row (Rotate 90deg)
            const oldM = el.matrix;
            const R = oldM.length, C = oldM[0].length;
            const newM = Array(C).fill(0).map(() => Array(R).fill(0));

            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    newM[c][R - 1 - r] = oldM[r][c];
                }
            }

            const gx = parseInt(el.dataset.gx);
            const gy = parseInt(el.dataset.gy);

            if (validatePlacementMatrix(gx, gy, newM, el.dataset.id)) {
                el.matrix = newM;
                updateShipVisual(el, newM, tileSize);
                placeShipOnBoard(el, gx, gy, newM, el.dataset.id);
            } else {
                el.classList.add('error');
                setTimeout(() => el.classList.remove('error'), 200);
            }
        }

        // --- DRAG & DROP (MATRIX SUPPORT) ---
        let dragEl = null;
        let originData = null;

        function selectShip(e, el) {
            if (selectedShipRef) selectedShipRef.classList.remove('selected');
            selectedShipRef = el;
            el.classList.add('selected');
            document.getElementById('btn-rotate').disabled = (el.dataset.location !== 'board');
        }

        function setupDrag(el) {
            el.addEventListener('pointerdown', startDrag);
        }

        function startDrag(e) {
            dragEl = this;
            if (dragEl.dataset.locked === 'true') return;
            selectShip(e, dragEl);

            const rect = dragEl.getBoundingClientRect();

            // Calculate relative offset ratio to preserve grab point across resize
            const ratioX = (e.clientX - rect.left) / rect.width;
            const ratioY = (e.clientY - rect.top) / rect.height;

            originData = {
                parent: dragEl.parentElement,
                location: dragEl.dataset.location,
                shipObj: dragEl.dataset.location === 'board' ?
                    placedShips.find(s => s.id === dragEl.dataset.id) : null,
                originalWidth: rect.width, // Backup for inventory restoration
                ratioX: ratioX,
                ratioY: ratioY
            };

            // Force resize to Board TileSize immediately for accurate visual
            updateShipVisual(dragEl, dragEl.matrix, tileSize);

            // Re-calc offset based on NEW size
            const newW = dragEl.scrollWidth; // or clientWidth
            const newH = dragEl.scrollHeight;

            const realOffsetX = newW * ratioX;
            const realOffsetY = newH * ratioY;

            originData.offsetX = realOffsetX;
            originData.offsetY = realOffsetY;

            dragEl.style.position = 'fixed';
            dragEl.style.zIndex = 1000;
            dragEl.style.left = (e.clientX - realOffsetX) + 'px';
            dragEl.style.top = (e.clientY - realOffsetY) + 'px';
            document.body.appendChild(dragEl);

            dragEl.setPointerCapture(e.pointerId);
            dragEl.classList.add('dragging');
            dragEl.addEventListener('pointermove', moveDrag);
            dragEl.addEventListener('pointerup', endDrag);
        }

        function moveDrag(e) {
            if (!dragEl) return;
            e.preventDefault();
            dragEl.style.left = (e.clientX - originData.offsetX) + 'px';
            dragEl.style.top = (e.clientY - originData.offsetY) + 'px';
        }

        function endDrag(e) {
            if (!dragEl) return;
            dragEl.classList.remove('dragging');
            dragEl.removeEventListener('pointermove', moveDrag);
            dragEl.removeEventListener('pointerup', endDrag);
            dragEl.releasePointerCapture(e.pointerId);

            const rect = dragEl.getBoundingClientRect();
            const board = document.getElementById('setup-board');
            const bRect = board.getBoundingClientRect();

            // Check center point or just strict overlap? 
            // Let's use Top-Left + minimal tolerance
            // Ideally we want to map the Top-Left of the ship to grid

            // Calculate tentative grid pos
            const gx = Math.round((rect.left - bRect.left) / tileSize);
            const gy = Math.round((rect.top - bRect.top) / tileSize);

            if (rect.left + 10 > bRect.left && rect.right - 10 < bRect.right &&
                rect.top + 10 > bRect.top && rect.bottom - 10 < bRect.bottom) {

                // It is largely inside the board area
                if (validatePlacementMatrix(gx, gy, dragEl.matrix, dragEl.dataset.id)) {
                    placeShipOnBoard(dragEl, gx, gy, dragEl.matrix, dragEl.dataset.id);
                    return;
                }
            } else if (gx >= 0 && gy >= 0 && gx < gridSize && gy < gridSize) {
                // It is partial, try to snap if valid
                if (validatePlacementMatrix(gx, gy, dragEl.matrix, dragEl.dataset.id)) {
                    placeShipOnBoard(dragEl, gx, gy, dragEl.matrix, dragEl.dataset.id);
                    return;
                }
            }

            returnToOrigin();
        }

        function returnToOrigin() {
            dragEl.style.position = 'relative';
            dragEl.style.left = '0';
            dragEl.style.top = '0';
            dragEl.style.zIndex = '';

            if (originData.location === 'inventory') {
                // Restore Inventory Appearance (Size 30)
                updateShipVisual(dragEl, dragEl.matrix, 30);
                originData.parent.appendChild(dragEl);
            } else {
                const s = originData.shipObj;
                // It was on board, so it stays Board Size
                placeShipOnBoard(dragEl, s.gx, s.gy, s.matrix, s.id);
            }
            dragEl = null;
        }

        function validatePlacementMatrix(gx, gy, matrix, ignoreId) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            if (gx < 0 || gy < 0 || gx + cols > gridSize || gy + rows > gridSize) return false;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (matrix[r][c] === 1) {
                        for (const ship of placedShips) {
                            if (ship.id === ignoreId) continue;
                            if (isPointInShip(gx + c, gy + r, ship)) return false;
                        }
                    }
                }
            }
            return true;
        }

        function isPointInShip(x, y, ship) {
            const relX = x - ship.gx;
            const relY = y - ship.gy;
            if (relY >= 0 && relY < ship.matrix.length && relX >= 0 && relX < ship.matrix[0].length) {
                return ship.matrix[relY][relX] === 1;
            }
            return false;
        }

        function placeShipOnBoard(el, gx, gy, matrix, id) {
            placedShips = placedShips.filter(s => s.id !== id);

            placedShips.push({ id, gx, gy, matrix });

            const board = document.getElementById('setup-board');
            el.dataset.location = 'board';
            el.dataset.gx = gx;
            el.dataset.gy = gy;

            updateShipVisual(el, matrix, tileSize);

            el.style.position = 'absolute';
            el.style.left = (gx * tileSize) + 'px';
            el.style.top = (gy * tileSize) + 'px';
            el.style.zIndex = 10;
            board.appendChild(el);

            document.getElementById('btn-rotate').disabled = false;
            selectShip(null, el); // Reactivate select
            dragEl = null;

            checkSetupReady();
        }

        function checkSetupReady() {
            const totalShips = fleetConfig.reduce((acc, c) => acc + c.count, 0);
            if (placedShips.length === totalShips) {
                document.getElementById('btn-ready').classList.remove('hidden');
            } else {
                document.getElementById('btn-ready').classList.add('hidden');
            }
        }

        function finalizeSetup() {
            show('screen-wait');
            isSetupReady = true;

            const myFleetData = placedShips.map(s => ({
                id: s.id,
                matrix: s.matrix,
                gx: s.gx, // Ensure we send gx/gy for consistency if needed, but fleetData uses x,y usually
                gy: s.gy
            }));

            // Generate My Ships Logic Objects
            myShips = placedShips.map(s => ({
                id: s.id,
                matrix: s.matrix,
                x: s.gx,
                y: s.gy,
                hits: new Set()
            }));

            conn.send({ type: 'READY_FLEET', fleet: myFleetData });
            checkStartGame();
        }

        function checkStartGame() {
            if (isSetupReady && enemyShipsList && enemyShipsList.length > 0) {
                startGame();
            }
        }

        function startGame() {
            show('screen-game');
            initGameUI();
            renderEnemyFleetPanel();

            // Turn Logic: Host starts
            myTurn = isHost;
            updateTurnUI();
        }

        // --- GAME PLAY LOGIC ---
        function initGameUI() {
            // Setup Enemy Board
            const eBoard = document.getElementById('enemy-board');
            eBoard.style.width = `${tileSize * gridSize}px`;
            eBoard.style.height = `${tileSize * gridSize}px`;

            const eGrid = document.getElementById('enemy-grid');
            eGrid.style.backgroundSize = `${tileSize}px ${tileSize}px`;
            eGrid.style.backgroundImage = `linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
                                          linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px)`;

            eBoard.onclick = (e) => onEnemyBoardClick(e);

            // Setup My Board (Static)
            const mBoard = document.getElementById('my-board');
            mBoard.style.width = `${tileSize * gridSize}px`;
            mBoard.style.height = `${tileSize * gridSize}px`;

            const mGrid = document.getElementById('my-grid');
            mGrid.style.backgroundSize = `${tileSize}px ${tileSize}px`;
            mGrid.style.backgroundImage = `linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
                                          linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px)`;

            const myContainer = document.getElementById('my-final-ships');
            myContainer.innerHTML = '';

            myShips.forEach(s => {
                const el = document.createElement('div');
                el.className = 'ship-visual';
                updateShipVisual(el, s.matrix, tileSize);
                el.style.position = 'absolute';
                el.style.left = (s.x * tileSize) + 'px';
                el.style.top = (s.y * tileSize) + 'px';
                myContainer.appendChild(el);
            });

            renderEnemyFleetPanel();
            updateTurnUI();
        }

        function renderEnemyFleetPanel() {
            const panel = document.getElementById('enemy-fleet-panel');
            panel.innerHTML = '';
            enemyShipsList.forEach(s => {
                const card = document.createElement('div');
                card.className = 'enemy-ship-card';
                if (s.sunk) card.classList.add('sunk');

                const visual = generateMatrixVisual(s.matrix, 10); // Small preview
                card.appendChild(visual);
                panel.appendChild(card);
            });
        }

        function onEnemyBoardClick(e) {
            if (!myTurn) return;
            const rect = document.getElementById('enemy-board').getBoundingClientRect();
            const bx = Math.floor((e.clientX - rect.left) / tileSize);
            const by = Math.floor((e.clientY - rect.top) / tileSize);

            if (bx < 0 || by < 0 || bx >= gridSize || by >= gridSize) return;

            // Check if already shot (simple check via marker existence)
            // But ideally keep a record. For now let's send shot.
            if (document.querySelector(`#enemy-markers .marker[data-x="${bx}"][data-y="${by}"]`)) return;

            // Optimistic marker
            conn.send({ type: 'SHOT', x: bx, y: by });
            myTurn = false;
            updateTurnUI();
        }

        function handleReceiveShot(x, y) {
            // Check Hit
            let hit = false;
            let sunkId = null;

            for (const ship of myShips) {
                if (isPointInShip(x, y, { gx: ship.x, gy: ship.y, matrix: ship.matrix })) {
                    hit = true;
                    // Use a Set to track hits if not exists
                    if (!ship.hits) ship.hits = new Set();
                    ship.hits.add(`${x},${y}`);

                    // Check sunk
                    let totalCells = 0;
                    ship.matrix.forEach(r => r.forEach(c => totalCells += c));
                    if (ship.hits.size === totalCells) {
                        sunkId = ship.id;
                    }
                    break;
                }
            }

            addMarker('my-markers', x, y, hit);
            conn.send({ type: 'SHOT_RESULT', x, y, hit, sunkId });

            myTurn = true;
            document.getElementById('turn-badge').style.display = 'inline-block';
            document.getElementById('wait-badge').style.display = 'none';
        }

        function handleShotResult(x, y, hit, sunkId) {
            addMarker('enemy-markers', x, y, hit);
            if (sunkId) {
                const s = enemyShipsList.find(s => s.id === sunkId);
                if (s) {
                    s.sunk = true;
                    renderEnemyFleetPanel();
                    document.getElementById('game-info').innerText = "HUNDIDO!";
                    confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
                }
            } else {
                document.getElementById('game-info').innerText = hit ? "IMPACTO!" : "Agua";
            }
        }

        function addMarker(layerId, x, y, hit) {
            const layer = document.getElementById(layerId);
            const m = document.createElement('div');
            m.className = `marker ${hit ? 'hit' : 'miss'}`;
            m.dataset.x = x;
            m.dataset.y = y;
            m.style.left = (x * tileSize) + 'px';
            m.style.top = (y * tileSize) + 'px';
            m.style.width = tileSize + 'px';
            m.style.height = tileSize + 'px';

            if (hit) {
                m.innerText = '';
                m.style.fontSize = (tileSize * 0.6) + 'px';
                m.style.display = 'flex'; m.style.justifyContent = 'center'; m.style.alignItems = 'center';
            }
            layer.appendChild(m);
        }

        function updateTurnUI() {
            if (myTurn) {
                document.getElementById('turn-badge').style.display = 'inline-block';
                document.getElementById('wait-badge').style.display = 'none';
            } else {
                document.getElementById('turn-badge').style.display = 'none';
                document.getElementById('wait-badge').style.display = 'inline-block';
            }
        }

    </script>
</body>

</html>