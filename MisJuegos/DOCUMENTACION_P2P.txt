DOCUMENTACIÓN TÉCNICA: PROTOCOLO P2P "FAST-DUAL" (Estándar Arcade)
==================================================================
Versión: 2.0 (Estable/Robusta)
Fecha: Enero 2026
Estado: Aprobado y probado en producción (Battleship, DualWeb)

1. INTRODUCCIÓN
---------------
Este protocolo define el estándar de conectividad multijugador para el proyecto "Arcade de Juegos".
Su objetivo es lograr una conexión Peer-to-Peer (P2P) extremadamente rápida (< 500ms), confiable y sin necesidad de configurar servidores de señalización propios (backend-less), utilizando la infraestructura pública de PeerJS de manera eficiente.

La clave del éxito de este protocolo (vs versiones anteriores) es la "Generación de ID en Cliente" y el manejo asíncrono robusto.

2. ARQUITECTURA
---------------
- **Librería Core:** PeerJS (v1.5.1 o superior)
- **Topología:** P2P Directo (Mesh/Star). Los datos viajan navegador-a-navegador.
- **Broker/Signaling:** Servidor público de PeerJS (solo handshake inicial).
- **Transporte:** WebRTC (UDP/TCP según disponibilidad).

3. IMPLEMENTACIÓN BASE (Copiar y Pegar)
---------------------------------------

### A. Dependencias
Incluir en el `<head>` o antes del script principal:
`<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>`

### B. Inicialización del HOST (Quien crea la partida)
El Host NO pregunta al servidor por un ID. El Host INVENTA un ID corto aleatorio y le dice al servidor "Este es mi ID". Esto elimina latencia de red.

```javascript
let peer;       // Instancia propia (mi identidad)
let conn;       // La conexión con el rival
let isHost = false;

function initPeer() {
    // 1. Generamos ID localmente (4 chars es suficiente para evitar colisiones casuales)
    const shortId = Math.random().toString(36).substring(2, 6).toUpperCase();
    
    // 2. Inicializamos Peer forzando este ID
    peer = new Peer(shortId);

    peer.on('open', (id) => {
        console.log("Sala Creada con ÉXITO. ID:", id);
        isHost = true;
        // AQUÍ: Mostrar UI de "Sala de Espera" y mostrar 'id' al usuario
        document.getElementById('display-code').innerText = id;
    });

    peer.on('connection', (c) => {
        // Un rival se ha conectado
        handleConnection(c);
    });

    peer.on('error', (err) => {
        console.error("Error P2P:", err);
        // Si el ID ya existe (colisión rara), reintentar recursivamente
        if (err.type === 'unavailable-id') {
            initPeer(); 
        } else {
            alert("Error de red: " + err);
        }
    });
}
```

### C. Inicialización del CLIENTE (Quien se une)
El Cliente no necesita un ID bonito. Deja que el servidor le asigne uno largo UUID. Solo necesita saber el ID corto del Host.

```javascript
function joinGame() {
    const hostCode = document.getElementById('code-input').value.toUpperCase();
    if (!hostCode) return;

    isHost = false;
    
    // Sin argumentos = ID automático del servidor
    peer = new Peer();

    peer.on('open', () => {
        // Ya tenemos identidad, ahora llamamos al Host
        const c = peer.connect(hostCode);
        handleConnection(c);
    });

    peer.on('error', (err) => alert("No se pudo conectar: " + err));
}
```

### D. Manejo de Conexión (Común)
Esta función unifica la lógica una vez que el "cable" está tendido entre los dos jugadores.

```javascript
function handleConnection(c) {
    conn = c; // Guardamos referencia global

    conn.on('open', () => {
        console.log("¡CONEXIÓN ESTABLECIDA!");
        
        // Host: Suele enviar la configuración inicial de la partida
        if (isHost) {
            conn.send({ type: 'INIT_GAME', config: { level: 1 } });
        }
        
        // AQUÍ: Ocultar Lobby, Mostrar Pantalla de Juego
        startGameUI();
    });

    conn.on('data', (data) => {
        // Router de mensajes
        switch(data.type) {
            case 'INIT_GAME':
                // Cliente recibe config
                setupLevel(data.config);
                break;
            case 'PLAYER_MOVE':
                updatePlayerPos(data.x, data.y);
                break;
            case 'GAME_OVER':
                showResult(data.win);
                break;
            default:
                console.log("Paquete desconocido:", data);
        }
    });

    conn.on('close', () => {
        alert("Rival desconectado");
        resetGame(); // Volver al menú
    });
    
    conn.on('error', (err) => console.error("Error en túnel de datos:", err));
}
```

4. BUENAS PRÁCTICAS Y NOTAS
---------------------------
- **Cierre de Conexiones:** Siempre manejar `conn.on('close')`. Las redes móviles suelen cortar conexiones brevemente.
- **Reinicio:** Si se quiere reiniciar la partida, enviar un mensaje `{type: 'RESTART'}` en lugar de recargar la página, para mantener el túnel abierto.
- **Datos:** Enviar objetos JSON simples es lo mejor. Para juegos de acción (tiempo real), enviar solo los inputs o posiciones clave, no todo el estado del juego cada frame.
- **Colisiones:** La probabilidad de colisión con un ID de 4 caracteres alfanuméricos es baja para un uso casual, pero el código del Host maneja el error `unavailable-id` reintentando automáticamente por seguridad.

5. EJEMPLO DE FLUJO DE MENSAJES (BATTLESHIP)
--------------------------------------------
1. **Host** > `INIT` (GridSize, Configuración de Flota)
2. **Cliente** > `READY_FLEET` (Mi flota ya ubicada)
3. **Host** > `START_GAME` (O simplemente inicia el turno)
4. (Durante el juego) > `SHOT` {x, y}
5. (Respuesta) > `SHOT_RESULT` {x, y, hit: true/false, sunkId: null/id}

==================================================================
Este documento es la referencia oficial para el sistema "Arcade de Juegos".
