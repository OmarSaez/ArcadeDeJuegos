<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DualWeb HTML5</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            /* Dejar pasar toques al canvas cuando estamos jugando */
        }

        .menu-screen {
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #0ff;
            text-align: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        h1 {
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 0 0 10px #0ff;
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            margin: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
        }

        button:active {
            transform: scale(0.95);
        }

        input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #777;
            color: #fff;
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            text-align: center;
            width: 200px;
            margin-bottom: 20px;
        }

        #game-canvas {
            display: block;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        #health-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 10px;
            background: #333;
            border: 1px solid #555;
            display: none;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: #0f0;
            transition: width 0.2s, background 0.2s;
            box-shadow: 0 0 10px #0f0;
        }

        #ios-sensor-btn {
            display: none;
            /* Se mostrar√° solo si es necesario */
            margin-top: 20px;
            background: #ff00ff;
            border-color: #ff00ff;
            color: white;
            font-size: 0.9rem;
            padding: 10px;
        }

        .status-msg {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <canvas id="game-canvas"></canvas>

    <div id="health-bar">
        <div id="health-fill"></div>
    </div>

    <div id="ui-layer">
        <!-- PANTALLA DE INICIO -->
        <div id="start-screen" class="menu-screen">
            <h1>DualWeb</h1>
            <p>Conecta dos dispositivos y enfr√©ntate.</p>
            <button onclick="isHost=true; initPeer();">CREAR SALA (Host)</button>
            <br>
            <div style="margin: 10px 0;">‚Äî O ‚Äî</div>
            <input type="text" id="room-code" placeholder="C√ìDIGO SALA">
            <br>
            <button onclick="joinGame()">UNIRSE</button>

            <button id="ios-sensor-btn" onclick="requestSensorPermission()">üì± Activar Sensores (iOS)</button>
        </div>

        <!-- PANTALLA DE ESPERA (HOST) -->
        <div id="waiting-screen" class="menu-screen" style="display:none;">
            <h2>Esperando Rival...</h2>
            <p>Tu C√≥digo:</p>
            <h1 id="display-code" style="font-size: 3rem; color: #ff00ff;">...</h1>
            <p class="status-msg">Comparte este c√≥digo para jugar.</p>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-screen" class="menu-screen" style="display:none;">
            <h1 id="result-title">FIN DEL JUEGO</h1>
            <button onclick="restartGame()">REVANCHA</button>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script>
        // --- CONSTANTES ---
        const CANVAS = document.getElementById('game-canvas');
        const CTX = CANVAS.getContext('2d');
        let W, H;

        // --- ESTADO DEL JUEGO ---
        let gameState = 'MENU'; // MENU, WAITING, PLAYING, GAMEOVER
        let myId = null;
        let isHost = false;
        let conn = null;
        let fullSyncInterval = null;

        // Jugador Local
        const player = {
            x: 0.5, // 0 a 1 (posici√≥n relativa horizontal)
            y: 0.8, // 0 a 1 (posici√≥n relativa vertical)
            color: '#0ff', // Cyan por defecto
            hp: 100,
            vx: 0,
            vy: 0,
            width: 0.1, // Ancho relativo
            widthPx: 0
        };

        // Rival (Fantasma)
        const enemy = {
            x: 0.5,
            y: 0.2, // El rival aparece "arriba" en espejo? No, solo mostramos su sombra si queremos
            active: false,
            color: '#ff00ff' // Magenta
        };

        let bullets = []; // { x, y, vx, vy, isMine }

        // --- SETUP CANVAS ---
        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            CANVAS.width = W;
            CANVAS.height = H;
            player.widthPx = W * player.width;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- CONTROLES (GYRO + MOUSE) ---
        let gyroActive = false;
        let baseBeta = 0;
        let baseGamma = 0;

        function handleOrientation(event) {
            if (!gyroActive) return;
            // Gamma: Inclinaci√≥n Izq/Der (-90 a 90)
            // Beta: Inclinaci√≥n Adelante/Atr√°s (-180 a 180)

            // Simplificamos: Usamos Gamma para mover eje X
            // Sensibilidad
            const tiltX = event.gamma;
            const tiltY = event.beta;

            // Zona muerta y velocidad
            if (Math.abs(tiltX) > 2) player.vx += tiltX * 0.0005;
            if (Math.abs(tiltY - 45) > 2) player.vy += (tiltY - 45) * 0.0005; // 45 grados inclinaci√≥n base
        }
        window.addEventListener('deviceorientation', handleOrientation);

        // Fallback Mouse/Touch Drag
        CANVAS.addEventListener('pointermove', (e) => {
            if (!gyroActive) {
                // Mover nave directamente al dedo/mouse (m√°s f√°cil para pruebas PC)
                player.x = e.clientX / W;
                player.y = e.clientY / H;
            }
        });

        // Disparo: Tap en pantalla
        CANVAS.addEventListener('pointerdown', (e) => {
            if (gameState === 'PLAYING') shoot();
        });

        function requestSensorPermission() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            gyroActive = true;
                            alert("Sensores Activados! Inclina para moverte.");
                            document.getElementById('ios-sensor-btn').style.display = 'none';
                        }
                    })
                    .catch(console.error);
            } else {
                // Android / No-iOS
                gyroActive = true;
                alert("Intentando activar sensores (Android/PC)...");
            }
        }

        // Detectar si es iOS para mostrar bot√≥n
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('ios-sensor-btn').style.display = 'block';
        }


        // --- L√ìGICA DE JUEGO ---
        function shoot() {
            // Bala local sale hacia ARRIBA (y negativo)
            bullets.push({
                x: player.x,
                y: player.y,
                vx: 0,
                vy: -0.015, // Velocidad hacia arriba
                isMine: true,
                color: player.color
            });

            // Enviar evento 'SHOT' para efectos de sonido o flash en el otro lado?
            // Realmente enviamos la bala cuando cruza el borde, 
            // pero para feedback visual inmediato podr√≠amos enviar algo.
        }

        function spawnEnemyBullet(xRel) {
            // La bala enemiga llega desde ARRIBA (y=0) hacia ABAJO
            bullets.push({
                x: xRel, // La misma X relativa (espejo horizontal?) -> Probemos directo
                y: -0.05, // Un poco m√°s arriba del borde
                vx: 0,
                vy: 0.015, // Velocidad hacia abajo (hacia m√≠)
                isMine: false,
                color: enemy.color
            });
        }

        function update(dt) {
            if (gameState !== 'PLAYING') return;

            // F√≠sicas Jugador (Inercia Gyro)
            if (gyroActive) {
                player.x += player.vx;
                player.vx *= 0.9; // Fricci√≥n

                // Limites
                if (player.x < 0) { player.x = 0; player.vx = 0; }
                if (player.x > 1) { player.x = 1; player.vx = 0; }
            }

            // Balas
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;

                // 1. Bala m√≠a sale de la pantalla por ARRIBA
                if (b.isMine && b.y < -0.05) {
                    // Enviar al rival
                    if (conn && conn.open) {
                        conn.send({ type: 'INCOMING_BULLET', x: b.x });
                    }
                    bullets.splice(i, 1);
                    continue;
                }

                // 2. Bala enemiga sale de la pantalla por ABAJO (fall√≥)
                if (!b.isMine && b.y > 1.05) {
                    bullets.splice(i, 1);
                    continue;
                }

                // 3. Colisiones (Bala enemiga me pega)
                if (!b.isMine) {
                    // Hitbox simple
                    const dx = Math.abs(b.x - player.x);
                    const dy = Math.abs(b.y - player.y);
                    // Hitbox size approx 5% width, 5% height
                    if (dx < 0.05 && dy < 0.03) {
                        player.hp -= 10;
                        bullets.splice(i, 1);
                        updateHealthUI();
                        if (player.hp <= 0) gameOver(false); // Perdimos
                    }
                }
            }
        }

        function draw() {
            // Fondo / Trail effect
            CTX.fillStyle = 'rgba(0, 0, 0, 0.2)';
            CTX.fillRect(0, 0, W, H);

            if (gameState !== 'PLAYING') return;

            // Jugador
            const px = player.x * W;
            const py = player.y * H;

            CTX.fillStyle = player.color;
            CTX.shadowBlur = 20;
            CTX.shadowColor = player.color;

            // Dibujar nave (Tri√°ngulo)
            CTX.beginPath();
            CTX.moveTo(px, py - 20);
            CTX.lineTo(px - 15, py + 20);
            CTX.lineTo(px + 15, py + 20);
            CTX.fill();
            CTX.shadowBlur = 0;

            // Balas
            bullets.forEach(b => {
                CTX.fillStyle = b.color;
                CTX.shadowBlur = 10;
                CTX.shadowColor = b.color;
                CTX.beginPath();
                CTX.arc(b.x * W, b.y * H, 6, 0, Math.PI * 2);
                CTX.fill();
                CTX.shadowBlur = 0;
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);

            // Sync Posici√≥n (Opcional, para ver 'fantasma' o solo para l√≥gica de red)
            // Por ahora DUAL cl√°sico no muestra al rival, solo las balas que llegan.
            // Asi que ahorramos red.
        }
        gameLoop();

        function updateHealthUI() {
            const fill = document.getElementById('health-fill');
            fill.style.width = player.hp + '%';
            if (player.hp > 50) fill.style.background = '#0f0';
            else if (player.hp > 20) fill.style.background = '#ff0';
            else fill.style.background = '#f00';

            document.getElementById('health-bar').style.display = 'block';
        }

        function gameOver(win) {
            gameState = 'GAMEOVER';
            document.getElementById('ui-layer').style.display = 'flex';
            document.getElementById('game-over-screen').style.display = 'block';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('health-bar').style.display = 'none';

            const title = document.getElementById('result-title');
            if (win) {
                title.innerText = "¬°VICTORIA!";
                title.style.color = "#0f0";
            } else {
                title.innerText = "DERROTA";
                title.style.color = "#f00";
                // Avisar al otro que gan√≥
                if (conn) conn.send({ type: 'GAME_OVER_YOU_WIN' });
            }
        }

        function restartGame() {
            // Reiniciar stats locales
            player.hp = 100;
            bullets = [];
            updateHealthUI();

            // Enviar solicitud de reinicio
            if (conn) conn.send({ type: 'REQUEST_RESTART' });

            // Esperar confirmaci√≥n o reiniciar directo?
            // Vamos a reiniciar directo y esperar que el otro acepte
            startGame();
        }

        // --- NETWORKING (PEERJS) ---
        let peer;

        function initPeer() {
            const shortId = Math.random().toString(36).substring(2, 6).toUpperCase();
            peer = new Peer(shortId);

            peer.on('open', (id) => {
                myId = id;
                if (isHost) {
                    player.color = '#0ff'; // Host es Cyan
                    enemy.color = '#ff00ff'; // Cliente es Magenta
                    document.getElementById('start-screen').style.display = 'none';
                    document.getElementById('waiting-screen').style.display = 'block';
                    document.getElementById('display-code').innerText = id;
                }
            });

            peer.on('connection', (c) => {
                handleConnection(c);
            });

            peer.on('error', (err) => alert("Error P2P: " + err));
        }

        function joinGame() {
            const code = document.getElementById('room-code').value.toUpperCase();
            if (!code) return;
            isHost = false;
            player.color = '#ff00ff'; // Cliente es Magenta
            enemy.color = '#0ff'; // Host es Cyan

            peer = new Peer();
            peer.on('open', () => {
                const c = peer.connect(code);
                handleConnection(c);
            });
        }

        function handleConnection(c) {
            conn = c;

            conn.on('open', () => {
                console.log("Conectado con:", conn.peer);
                // Ocultar men√∫s UI
                document.querySelectorAll('.menu-screen').forEach(el => el.style.display = 'none');

                // Iniciar Juego inmediatamente
                startGame();
            });

            conn.on('data', (data) => {
                switch (data.type) {
                    case 'INCOMING_BULLET':
                        // Espejo de X: Si rival dispar√≥ en 0.2, aqu√≠ entra en 0.2 o 0.8?
                        // Si estamos frente a frente, mi derecha es tu izquierda.
                        // As√≠ que x = 1.0 - data.x
                        spawnEnemyBullet(1.0 - data.x);
                        break;
                    case 'GAME_OVER_YOU_WIN':
                        gameOver(true);
                        break;
                    case 'REQUEST_RESTART':
                        startGame(); // Reiniciar si el otro lo pide
                        break;
                }
            });

            conn.on('close', () => alert("Rival desconectado"));
        }

        function startGame() {
            gameState = 'PLAYING';
            player.hp = 100;
            bullets = [];
            updateHealthUI();

            // Ocultar UI overlay
            document.querySelectorAll('.menu-screen').forEach(el => el.style.display = 'none');
        }

    </script>
</body>

</html>